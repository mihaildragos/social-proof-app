
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model BillingSite
 * 
 */
export type BillingSite = $Result.DefaultSelection<Prisma.$BillingSitePayload>
/**
 * Model BillingOrganization
 * 
 */
export type BillingOrganization = $Result.DefaultSelection<Prisma.$BillingOrganizationPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model PlanFeature
 * 
 */
export type PlanFeature = $Result.DefaultSelection<Prisma.$PlanFeaturePayload>
/**
 * Model PlanLimit
 * 
 */
export type PlanLimit = $Result.DefaultSelection<Prisma.$PlanLimitPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model UsageRecord
 * 
 */
export type UsageRecord = $Result.DefaultSelection<Prisma.$UsageRecordPayload>
/**
 * Model UsageSummary
 * 
 */
export type UsageSummary = $Result.DefaultSelection<Prisma.$UsageSummaryPayload>
/**
 * Model BillingContact
 * 
 */
export type BillingContact = $Result.DefaultSelection<Prisma.$BillingContactPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model PromotionRedemption
 * 
 */
export type PromotionRedemption = $Result.DefaultSelection<Prisma.$PromotionRedemptionPayload>
/**
 * Model PlanChangeRequest
 * 
 */
export type PlanChangeRequest = $Result.DefaultSelection<Prisma.$PlanChangeRequestPayload>
/**
 * Model SubscriptionHistory
 * 
 */
export type SubscriptionHistory = $Result.DefaultSelection<Prisma.$SubscriptionHistoryPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BillingSites
 * const billingSites = await prisma.billingSite.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BillingSites
   * const billingSites = await prisma.billingSite.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.billingSite`: Exposes CRUD operations for the **BillingSite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingSites
    * const billingSites = await prisma.billingSite.findMany()
    * ```
    */
  get billingSite(): Prisma.BillingSiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingOrganization`: Exposes CRUD operations for the **BillingOrganization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingOrganizations
    * const billingOrganizations = await prisma.billingOrganization.findMany()
    * ```
    */
  get billingOrganization(): Prisma.BillingOrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planFeature`: Exposes CRUD operations for the **PlanFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanFeatures
    * const planFeatures = await prisma.planFeature.findMany()
    * ```
    */
  get planFeature(): Prisma.PlanFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planLimit`: Exposes CRUD operations for the **PlanLimit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanLimits
    * const planLimits = await prisma.planLimit.findMany()
    * ```
    */
  get planLimit(): Prisma.PlanLimitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usageRecord`: Exposes CRUD operations for the **UsageRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageRecords
    * const usageRecords = await prisma.usageRecord.findMany()
    * ```
    */
  get usageRecord(): Prisma.UsageRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usageSummary`: Exposes CRUD operations for the **UsageSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageSummaries
    * const usageSummaries = await prisma.usageSummary.findMany()
    * ```
    */
  get usageSummary(): Prisma.UsageSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingContact`: Exposes CRUD operations for the **BillingContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingContacts
    * const billingContacts = await prisma.billingContact.findMany()
    * ```
    */
  get billingContact(): Prisma.BillingContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotionRedemption`: Exposes CRUD operations for the **PromotionRedemption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionRedemptions
    * const promotionRedemptions = await prisma.promotionRedemption.findMany()
    * ```
    */
  get promotionRedemption(): Prisma.PromotionRedemptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planChangeRequest`: Exposes CRUD operations for the **PlanChangeRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanChangeRequests
    * const planChangeRequests = await prisma.planChangeRequest.findMany()
    * ```
    */
  get planChangeRequest(): Prisma.PlanChangeRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionHistory`: Exposes CRUD operations for the **SubscriptionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionHistories
    * const subscriptionHistories = await prisma.subscriptionHistory.findMany()
    * ```
    */
  get subscriptionHistory(): Prisma.SubscriptionHistoryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BillingSite: 'BillingSite',
    BillingOrganization: 'BillingOrganization',
    Plan: 'Plan',
    PlanFeature: 'PlanFeature',
    PlanLimit: 'PlanLimit',
    Subscription: 'Subscription',
    PaymentMethod: 'PaymentMethod',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    UsageRecord: 'UsageRecord',
    UsageSummary: 'UsageSummary',
    BillingContact: 'BillingContact',
    Promotion: 'Promotion',
    PromotionRedemption: 'PromotionRedemption',
    PlanChangeRequest: 'PlanChangeRequest',
    SubscriptionHistory: 'SubscriptionHistory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "billingSite" | "billingOrganization" | "plan" | "planFeature" | "planLimit" | "subscription" | "paymentMethod" | "invoice" | "invoiceItem" | "usageRecord" | "usageSummary" | "billingContact" | "promotion" | "promotionRedemption" | "planChangeRequest" | "subscriptionHistory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      BillingSite: {
        payload: Prisma.$BillingSitePayload<ExtArgs>
        fields: Prisma.BillingSiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingSiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingSiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSitePayload>
          }
          findFirst: {
            args: Prisma.BillingSiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingSiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSitePayload>
          }
          findMany: {
            args: Prisma.BillingSiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSitePayload>[]
          }
          create: {
            args: Prisma.BillingSiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSitePayload>
          }
          createMany: {
            args: Prisma.BillingSiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingSiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSitePayload>[]
          }
          delete: {
            args: Prisma.BillingSiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSitePayload>
          }
          update: {
            args: Prisma.BillingSiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSitePayload>
          }
          deleteMany: {
            args: Prisma.BillingSiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingSiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingSiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSitePayload>[]
          }
          upsert: {
            args: Prisma.BillingSiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSitePayload>
          }
          aggregate: {
            args: Prisma.BillingSiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingSite>
          }
          groupBy: {
            args: Prisma.BillingSiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingSiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingSiteCountArgs<ExtArgs>
            result: $Utils.Optional<BillingSiteCountAggregateOutputType> | number
          }
        }
      }
      BillingOrganization: {
        payload: Prisma.$BillingOrganizationPayload<ExtArgs>
        fields: Prisma.BillingOrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingOrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingOrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingOrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingOrganizationPayload>
          }
          findFirst: {
            args: Prisma.BillingOrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingOrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingOrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingOrganizationPayload>
          }
          findMany: {
            args: Prisma.BillingOrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingOrganizationPayload>[]
          }
          create: {
            args: Prisma.BillingOrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingOrganizationPayload>
          }
          createMany: {
            args: Prisma.BillingOrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingOrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingOrganizationPayload>[]
          }
          delete: {
            args: Prisma.BillingOrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingOrganizationPayload>
          }
          update: {
            args: Prisma.BillingOrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingOrganizationPayload>
          }
          deleteMany: {
            args: Prisma.BillingOrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingOrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingOrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingOrganizationPayload>[]
          }
          upsert: {
            args: Prisma.BillingOrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingOrganizationPayload>
          }
          aggregate: {
            args: Prisma.BillingOrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingOrganization>
          }
          groupBy: {
            args: Prisma.BillingOrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingOrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingOrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<BillingOrganizationCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      PlanFeature: {
        payload: Prisma.$PlanFeaturePayload<ExtArgs>
        fields: Prisma.PlanFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          findFirst: {
            args: Prisma.PlanFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          findMany: {
            args: Prisma.PlanFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>[]
          }
          create: {
            args: Prisma.PlanFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          createMany: {
            args: Prisma.PlanFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>[]
          }
          delete: {
            args: Prisma.PlanFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          update: {
            args: Prisma.PlanFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          deleteMany: {
            args: Prisma.PlanFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>[]
          }
          upsert: {
            args: Prisma.PlanFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanFeaturePayload>
          }
          aggregate: {
            args: Prisma.PlanFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanFeature>
          }
          groupBy: {
            args: Prisma.PlanFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<PlanFeatureCountAggregateOutputType> | number
          }
        }
      }
      PlanLimit: {
        payload: Prisma.$PlanLimitPayload<ExtArgs>
        fields: Prisma.PlanLimitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanLimitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanLimitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanLimitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanLimitPayload>
          }
          findFirst: {
            args: Prisma.PlanLimitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanLimitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanLimitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanLimitPayload>
          }
          findMany: {
            args: Prisma.PlanLimitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanLimitPayload>[]
          }
          create: {
            args: Prisma.PlanLimitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanLimitPayload>
          }
          createMany: {
            args: Prisma.PlanLimitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanLimitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanLimitPayload>[]
          }
          delete: {
            args: Prisma.PlanLimitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanLimitPayload>
          }
          update: {
            args: Prisma.PlanLimitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanLimitPayload>
          }
          deleteMany: {
            args: Prisma.PlanLimitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanLimitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanLimitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanLimitPayload>[]
          }
          upsert: {
            args: Prisma.PlanLimitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanLimitPayload>
          }
          aggregate: {
            args: Prisma.PlanLimitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanLimit>
          }
          groupBy: {
            args: Prisma.PlanLimitGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanLimitGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanLimitCountArgs<ExtArgs>
            result: $Utils.Optional<PlanLimitCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      UsageRecord: {
        payload: Prisma.$UsageRecordPayload<ExtArgs>
        fields: Prisma.UsageRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          findFirst: {
            args: Prisma.UsageRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          findMany: {
            args: Prisma.UsageRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>[]
          }
          create: {
            args: Prisma.UsageRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          createMany: {
            args: Prisma.UsageRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>[]
          }
          delete: {
            args: Prisma.UsageRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          update: {
            args: Prisma.UsageRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          deleteMany: {
            args: Prisma.UsageRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsageRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>[]
          }
          upsert: {
            args: Prisma.UsageRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageRecordPayload>
          }
          aggregate: {
            args: Prisma.UsageRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageRecord>
          }
          groupBy: {
            args: Prisma.UsageRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageRecordCountArgs<ExtArgs>
            result: $Utils.Optional<UsageRecordCountAggregateOutputType> | number
          }
        }
      }
      UsageSummary: {
        payload: Prisma.$UsageSummaryPayload<ExtArgs>
        fields: Prisma.UsageSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageSummaryPayload>
          }
          findFirst: {
            args: Prisma.UsageSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageSummaryPayload>
          }
          findMany: {
            args: Prisma.UsageSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageSummaryPayload>[]
          }
          create: {
            args: Prisma.UsageSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageSummaryPayload>
          }
          createMany: {
            args: Prisma.UsageSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageSummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageSummaryPayload>[]
          }
          delete: {
            args: Prisma.UsageSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageSummaryPayload>
          }
          update: {
            args: Prisma.UsageSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageSummaryPayload>
          }
          deleteMany: {
            args: Prisma.UsageSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsageSummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageSummaryPayload>[]
          }
          upsert: {
            args: Prisma.UsageSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageSummaryPayload>
          }
          aggregate: {
            args: Prisma.UsageSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageSummary>
          }
          groupBy: {
            args: Prisma.UsageSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<UsageSummaryCountAggregateOutputType> | number
          }
        }
      }
      BillingContact: {
        payload: Prisma.$BillingContactPayload<ExtArgs>
        fields: Prisma.BillingContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingContactPayload>
          }
          findFirst: {
            args: Prisma.BillingContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingContactPayload>
          }
          findMany: {
            args: Prisma.BillingContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingContactPayload>[]
          }
          create: {
            args: Prisma.BillingContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingContactPayload>
          }
          createMany: {
            args: Prisma.BillingContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingContactPayload>[]
          }
          delete: {
            args: Prisma.BillingContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingContactPayload>
          }
          update: {
            args: Prisma.BillingContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingContactPayload>
          }
          deleteMany: {
            args: Prisma.BillingContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingContactPayload>[]
          }
          upsert: {
            args: Prisma.BillingContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingContactPayload>
          }
          aggregate: {
            args: Prisma.BillingContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingContact>
          }
          groupBy: {
            args: Prisma.BillingContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingContactCountArgs<ExtArgs>
            result: $Utils.Optional<BillingContactCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      PromotionRedemption: {
        payload: Prisma.$PromotionRedemptionPayload<ExtArgs>
        fields: Prisma.PromotionRedemptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionRedemptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionRedemptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          findFirst: {
            args: Prisma.PromotionRedemptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionRedemptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          findMany: {
            args: Prisma.PromotionRedemptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>[]
          }
          create: {
            args: Prisma.PromotionRedemptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          createMany: {
            args: Prisma.PromotionRedemptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionRedemptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>[]
          }
          delete: {
            args: Prisma.PromotionRedemptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          update: {
            args: Prisma.PromotionRedemptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionRedemptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionRedemptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionRedemptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>[]
          }
          upsert: {
            args: Prisma.PromotionRedemptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          aggregate: {
            args: Prisma.PromotionRedemptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotionRedemption>
          }
          groupBy: {
            args: Prisma.PromotionRedemptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionRedemptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionRedemptionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionRedemptionCountAggregateOutputType> | number
          }
        }
      }
      PlanChangeRequest: {
        payload: Prisma.$PlanChangeRequestPayload<ExtArgs>
        fields: Prisma.PlanChangeRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanChangeRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanChangeRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanChangeRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanChangeRequestPayload>
          }
          findFirst: {
            args: Prisma.PlanChangeRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanChangeRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanChangeRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanChangeRequestPayload>
          }
          findMany: {
            args: Prisma.PlanChangeRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanChangeRequestPayload>[]
          }
          create: {
            args: Prisma.PlanChangeRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanChangeRequestPayload>
          }
          createMany: {
            args: Prisma.PlanChangeRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanChangeRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanChangeRequestPayload>[]
          }
          delete: {
            args: Prisma.PlanChangeRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanChangeRequestPayload>
          }
          update: {
            args: Prisma.PlanChangeRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanChangeRequestPayload>
          }
          deleteMany: {
            args: Prisma.PlanChangeRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanChangeRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanChangeRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanChangeRequestPayload>[]
          }
          upsert: {
            args: Prisma.PlanChangeRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanChangeRequestPayload>
          }
          aggregate: {
            args: Prisma.PlanChangeRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanChangeRequest>
          }
          groupBy: {
            args: Prisma.PlanChangeRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanChangeRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanChangeRequestCountArgs<ExtArgs>
            result: $Utils.Optional<PlanChangeRequestCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionHistory: {
        payload: Prisma.$SubscriptionHistoryPayload<ExtArgs>
        fields: Prisma.SubscriptionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          findMany: {
            args: Prisma.SubscriptionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>[]
          }
          create: {
            args: Prisma.SubscriptionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          createMany: {
            args: Prisma.SubscriptionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          update: {
            args: Prisma.SubscriptionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionHistory>
          }
          groupBy: {
            args: Prisma.SubscriptionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionHistoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    billingSite?: BillingSiteOmit
    billingOrganization?: BillingOrganizationOmit
    plan?: PlanOmit
    planFeature?: PlanFeatureOmit
    planLimit?: PlanLimitOmit
    subscription?: SubscriptionOmit
    paymentMethod?: PaymentMethodOmit
    invoice?: InvoiceOmit
    invoiceItem?: InvoiceItemOmit
    usageRecord?: UsageRecordOmit
    usageSummary?: UsageSummaryOmit
    billingContact?: BillingContactOmit
    promotion?: PromotionOmit
    promotionRedemption?: PromotionRedemptionOmit
    planChangeRequest?: PlanChangeRequestOmit
    subscriptionHistory?: SubscriptionHistoryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    features: number
    limits: number
    subscriptions: number
    changeRequestsCurrent: number
    changeRequestsNew: number
    historyPrevious: number
    historyNew: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | PlanCountOutputTypeCountFeaturesArgs
    limits?: boolean | PlanCountOutputTypeCountLimitsArgs
    subscriptions?: boolean | PlanCountOutputTypeCountSubscriptionsArgs
    changeRequestsCurrent?: boolean | PlanCountOutputTypeCountChangeRequestsCurrentArgs
    changeRequestsNew?: boolean | PlanCountOutputTypeCountChangeRequestsNewArgs
    historyPrevious?: boolean | PlanCountOutputTypeCountHistoryPreviousArgs
    historyNew?: boolean | PlanCountOutputTypeCountHistoryNewArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanFeatureWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountLimitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanLimitWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountChangeRequestsCurrentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanChangeRequestWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountChangeRequestsNewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanChangeRequestWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountHistoryPreviousArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionHistoryWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountHistoryNewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionHistoryWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    invoices: number
    usageRecords: number
    usageSummaries: number
    promotionRedemptions: number
    history: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | SubscriptionCountOutputTypeCountInvoicesArgs
    usageRecords?: boolean | SubscriptionCountOutputTypeCountUsageRecordsArgs
    usageSummaries?: boolean | SubscriptionCountOutputTypeCountUsageSummariesArgs
    promotionRedemptions?: boolean | SubscriptionCountOutputTypeCountPromotionRedemptionsArgs
    history?: boolean | SubscriptionCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountUsageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageRecordWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountUsageSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageSummaryWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountPromotionRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRedemptionWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionHistoryWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type PromotionCountOutputType
   */

  export type PromotionCountOutputType = {
    redemptions: number
  }

  export type PromotionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemptions?: boolean | PromotionCountOutputTypeCountRedemptionsArgs
  }

  // Custom InputTypes
  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCountOutputType
     */
    select?: PromotionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRedemptionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model BillingSite
   */

  export type AggregateBillingSite = {
    _count: BillingSiteCountAggregateOutputType | null
    _min: BillingSiteMinAggregateOutputType | null
    _max: BillingSiteMaxAggregateOutputType | null
  }

  export type BillingSiteMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type BillingSiteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type BillingSiteCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    organizationId: number
    createdAt: number
    _all: number
  }


  export type BillingSiteMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    organizationId?: true
    createdAt?: true
  }

  export type BillingSiteMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    organizationId?: true
    createdAt?: true
  }

  export type BillingSiteCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    organizationId?: true
    createdAt?: true
    _all?: true
  }

  export type BillingSiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingSite to aggregate.
     */
    where?: BillingSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingSites to fetch.
     */
    orderBy?: BillingSiteOrderByWithRelationInput | BillingSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingSites
    **/
    _count?: true | BillingSiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingSiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingSiteMaxAggregateInputType
  }

  export type GetBillingSiteAggregateType<T extends BillingSiteAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingSite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingSite[P]>
      : GetScalarType<T[P], AggregateBillingSite[P]>
  }




  export type BillingSiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingSiteWhereInput
    orderBy?: BillingSiteOrderByWithAggregationInput | BillingSiteOrderByWithAggregationInput[]
    by: BillingSiteScalarFieldEnum[] | BillingSiteScalarFieldEnum
    having?: BillingSiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingSiteCountAggregateInputType | true
    _min?: BillingSiteMinAggregateInputType
    _max?: BillingSiteMaxAggregateInputType
  }

  export type BillingSiteGroupByOutputType = {
    id: string
    name: string
    domain: string
    organizationId: string
    createdAt: Date
    _count: BillingSiteCountAggregateOutputType | null
    _min: BillingSiteMinAggregateOutputType | null
    _max: BillingSiteMaxAggregateOutputType | null
  }

  type GetBillingSiteGroupByPayload<T extends BillingSiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingSiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingSiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingSiteGroupByOutputType[P]>
            : GetScalarType<T[P], BillingSiteGroupByOutputType[P]>
        }
      >
    >


  export type BillingSiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    organizationId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["billingSite"]>

  export type BillingSiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    organizationId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["billingSite"]>

  export type BillingSiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    organizationId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["billingSite"]>

  export type BillingSiteSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    organizationId?: boolean
    createdAt?: boolean
  }

  export type BillingSiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "domain" | "organizationId" | "createdAt", ExtArgs["result"]["billingSite"]>

  export type $BillingSitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingSite"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string
      organizationId: string
      createdAt: Date
    }, ExtArgs["result"]["billingSite"]>
    composites: {}
  }

  type BillingSiteGetPayload<S extends boolean | null | undefined | BillingSiteDefaultArgs> = $Result.GetResult<Prisma.$BillingSitePayload, S>

  type BillingSiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingSiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingSiteCountAggregateInputType | true
    }

  export interface BillingSiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingSite'], meta: { name: 'BillingSite' } }
    /**
     * Find zero or one BillingSite that matches the filter.
     * @param {BillingSiteFindUniqueArgs} args - Arguments to find a BillingSite
     * @example
     * // Get one BillingSite
     * const billingSite = await prisma.billingSite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingSiteFindUniqueArgs>(args: SelectSubset<T, BillingSiteFindUniqueArgs<ExtArgs>>): Prisma__BillingSiteClient<$Result.GetResult<Prisma.$BillingSitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingSite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingSiteFindUniqueOrThrowArgs} args - Arguments to find a BillingSite
     * @example
     * // Get one BillingSite
     * const billingSite = await prisma.billingSite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingSiteFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingSiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingSiteClient<$Result.GetResult<Prisma.$BillingSitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingSite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSiteFindFirstArgs} args - Arguments to find a BillingSite
     * @example
     * // Get one BillingSite
     * const billingSite = await prisma.billingSite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingSiteFindFirstArgs>(args?: SelectSubset<T, BillingSiteFindFirstArgs<ExtArgs>>): Prisma__BillingSiteClient<$Result.GetResult<Prisma.$BillingSitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingSite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSiteFindFirstOrThrowArgs} args - Arguments to find a BillingSite
     * @example
     * // Get one BillingSite
     * const billingSite = await prisma.billingSite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingSiteFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingSiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingSiteClient<$Result.GetResult<Prisma.$BillingSitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingSites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingSites
     * const billingSites = await prisma.billingSite.findMany()
     * 
     * // Get first 10 BillingSites
     * const billingSites = await prisma.billingSite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingSiteWithIdOnly = await prisma.billingSite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingSiteFindManyArgs>(args?: SelectSubset<T, BillingSiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingSitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingSite.
     * @param {BillingSiteCreateArgs} args - Arguments to create a BillingSite.
     * @example
     * // Create one BillingSite
     * const BillingSite = await prisma.billingSite.create({
     *   data: {
     *     // ... data to create a BillingSite
     *   }
     * })
     * 
     */
    create<T extends BillingSiteCreateArgs>(args: SelectSubset<T, BillingSiteCreateArgs<ExtArgs>>): Prisma__BillingSiteClient<$Result.GetResult<Prisma.$BillingSitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingSites.
     * @param {BillingSiteCreateManyArgs} args - Arguments to create many BillingSites.
     * @example
     * // Create many BillingSites
     * const billingSite = await prisma.billingSite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingSiteCreateManyArgs>(args?: SelectSubset<T, BillingSiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingSites and returns the data saved in the database.
     * @param {BillingSiteCreateManyAndReturnArgs} args - Arguments to create many BillingSites.
     * @example
     * // Create many BillingSites
     * const billingSite = await prisma.billingSite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingSites and only return the `id`
     * const billingSiteWithIdOnly = await prisma.billingSite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingSiteCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingSiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingSitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingSite.
     * @param {BillingSiteDeleteArgs} args - Arguments to delete one BillingSite.
     * @example
     * // Delete one BillingSite
     * const BillingSite = await prisma.billingSite.delete({
     *   where: {
     *     // ... filter to delete one BillingSite
     *   }
     * })
     * 
     */
    delete<T extends BillingSiteDeleteArgs>(args: SelectSubset<T, BillingSiteDeleteArgs<ExtArgs>>): Prisma__BillingSiteClient<$Result.GetResult<Prisma.$BillingSitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingSite.
     * @param {BillingSiteUpdateArgs} args - Arguments to update one BillingSite.
     * @example
     * // Update one BillingSite
     * const billingSite = await prisma.billingSite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingSiteUpdateArgs>(args: SelectSubset<T, BillingSiteUpdateArgs<ExtArgs>>): Prisma__BillingSiteClient<$Result.GetResult<Prisma.$BillingSitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingSites.
     * @param {BillingSiteDeleteManyArgs} args - Arguments to filter BillingSites to delete.
     * @example
     * // Delete a few BillingSites
     * const { count } = await prisma.billingSite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingSiteDeleteManyArgs>(args?: SelectSubset<T, BillingSiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingSites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingSites
     * const billingSite = await prisma.billingSite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingSiteUpdateManyArgs>(args: SelectSubset<T, BillingSiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingSites and returns the data updated in the database.
     * @param {BillingSiteUpdateManyAndReturnArgs} args - Arguments to update many BillingSites.
     * @example
     * // Update many BillingSites
     * const billingSite = await prisma.billingSite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingSites and only return the `id`
     * const billingSiteWithIdOnly = await prisma.billingSite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingSiteUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingSiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingSitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingSite.
     * @param {BillingSiteUpsertArgs} args - Arguments to update or create a BillingSite.
     * @example
     * // Update or create a BillingSite
     * const billingSite = await prisma.billingSite.upsert({
     *   create: {
     *     // ... data to create a BillingSite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingSite we want to update
     *   }
     * })
     */
    upsert<T extends BillingSiteUpsertArgs>(args: SelectSubset<T, BillingSiteUpsertArgs<ExtArgs>>): Prisma__BillingSiteClient<$Result.GetResult<Prisma.$BillingSitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingSites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSiteCountArgs} args - Arguments to filter BillingSites to count.
     * @example
     * // Count the number of BillingSites
     * const count = await prisma.billingSite.count({
     *   where: {
     *     // ... the filter for the BillingSites we want to count
     *   }
     * })
    **/
    count<T extends BillingSiteCountArgs>(
      args?: Subset<T, BillingSiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingSiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingSite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingSiteAggregateArgs>(args: Subset<T, BillingSiteAggregateArgs>): Prisma.PrismaPromise<GetBillingSiteAggregateType<T>>

    /**
     * Group by BillingSite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingSiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingSiteGroupByArgs['orderBy'] }
        : { orderBy?: BillingSiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingSiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingSiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingSite model
   */
  readonly fields: BillingSiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingSite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingSiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingSite model
   */
  interface BillingSiteFieldRefs {
    readonly id: FieldRef<"BillingSite", 'String'>
    readonly name: FieldRef<"BillingSite", 'String'>
    readonly domain: FieldRef<"BillingSite", 'String'>
    readonly organizationId: FieldRef<"BillingSite", 'String'>
    readonly createdAt: FieldRef<"BillingSite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingSite findUnique
   */
  export type BillingSiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
    /**
     * Filter, which BillingSite to fetch.
     */
    where: BillingSiteWhereUniqueInput
  }

  /**
   * BillingSite findUniqueOrThrow
   */
  export type BillingSiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
    /**
     * Filter, which BillingSite to fetch.
     */
    where: BillingSiteWhereUniqueInput
  }

  /**
   * BillingSite findFirst
   */
  export type BillingSiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
    /**
     * Filter, which BillingSite to fetch.
     */
    where?: BillingSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingSites to fetch.
     */
    orderBy?: BillingSiteOrderByWithRelationInput | BillingSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingSites.
     */
    cursor?: BillingSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingSites.
     */
    distinct?: BillingSiteScalarFieldEnum | BillingSiteScalarFieldEnum[]
  }

  /**
   * BillingSite findFirstOrThrow
   */
  export type BillingSiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
    /**
     * Filter, which BillingSite to fetch.
     */
    where?: BillingSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingSites to fetch.
     */
    orderBy?: BillingSiteOrderByWithRelationInput | BillingSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingSites.
     */
    cursor?: BillingSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingSites.
     */
    distinct?: BillingSiteScalarFieldEnum | BillingSiteScalarFieldEnum[]
  }

  /**
   * BillingSite findMany
   */
  export type BillingSiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
    /**
     * Filter, which BillingSites to fetch.
     */
    where?: BillingSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingSites to fetch.
     */
    orderBy?: BillingSiteOrderByWithRelationInput | BillingSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingSites.
     */
    cursor?: BillingSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingSites.
     */
    skip?: number
    distinct?: BillingSiteScalarFieldEnum | BillingSiteScalarFieldEnum[]
  }

  /**
   * BillingSite create
   */
  export type BillingSiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
    /**
     * The data needed to create a BillingSite.
     */
    data: XOR<BillingSiteCreateInput, BillingSiteUncheckedCreateInput>
  }

  /**
   * BillingSite createMany
   */
  export type BillingSiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingSites.
     */
    data: BillingSiteCreateManyInput | BillingSiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingSite createManyAndReturn
   */
  export type BillingSiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
    /**
     * The data used to create many BillingSites.
     */
    data: BillingSiteCreateManyInput | BillingSiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingSite update
   */
  export type BillingSiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
    /**
     * The data needed to update a BillingSite.
     */
    data: XOR<BillingSiteUpdateInput, BillingSiteUncheckedUpdateInput>
    /**
     * Choose, which BillingSite to update.
     */
    where: BillingSiteWhereUniqueInput
  }

  /**
   * BillingSite updateMany
   */
  export type BillingSiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingSites.
     */
    data: XOR<BillingSiteUpdateManyMutationInput, BillingSiteUncheckedUpdateManyInput>
    /**
     * Filter which BillingSites to update
     */
    where?: BillingSiteWhereInput
    /**
     * Limit how many BillingSites to update.
     */
    limit?: number
  }

  /**
   * BillingSite updateManyAndReturn
   */
  export type BillingSiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
    /**
     * The data used to update BillingSites.
     */
    data: XOR<BillingSiteUpdateManyMutationInput, BillingSiteUncheckedUpdateManyInput>
    /**
     * Filter which BillingSites to update
     */
    where?: BillingSiteWhereInput
    /**
     * Limit how many BillingSites to update.
     */
    limit?: number
  }

  /**
   * BillingSite upsert
   */
  export type BillingSiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
    /**
     * The filter to search for the BillingSite to update in case it exists.
     */
    where: BillingSiteWhereUniqueInput
    /**
     * In case the BillingSite found by the `where` argument doesn't exist, create a new BillingSite with this data.
     */
    create: XOR<BillingSiteCreateInput, BillingSiteUncheckedCreateInput>
    /**
     * In case the BillingSite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingSiteUpdateInput, BillingSiteUncheckedUpdateInput>
  }

  /**
   * BillingSite delete
   */
  export type BillingSiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
    /**
     * Filter which BillingSite to delete.
     */
    where: BillingSiteWhereUniqueInput
  }

  /**
   * BillingSite deleteMany
   */
  export type BillingSiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingSites to delete
     */
    where?: BillingSiteWhereInput
    /**
     * Limit how many BillingSites to delete.
     */
    limit?: number
  }

  /**
   * BillingSite without action
   */
  export type BillingSiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSite
     */
    select?: BillingSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSite
     */
    omit?: BillingSiteOmit<ExtArgs> | null
  }


  /**
   * Model BillingOrganization
   */

  export type AggregateBillingOrganization = {
    _count: BillingOrganizationCountAggregateOutputType | null
    _min: BillingOrganizationMinAggregateOutputType | null
    _max: BillingOrganizationMaxAggregateOutputType | null
  }

  export type BillingOrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingOrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingOrganizationCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillingOrganizationMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingOrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingOrganizationCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillingOrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingOrganization to aggregate.
     */
    where?: BillingOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingOrganizations to fetch.
     */
    orderBy?: BillingOrganizationOrderByWithRelationInput | BillingOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingOrganizations
    **/
    _count?: true | BillingOrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingOrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingOrganizationMaxAggregateInputType
  }

  export type GetBillingOrganizationAggregateType<T extends BillingOrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingOrganization[P]>
      : GetScalarType<T[P], AggregateBillingOrganization[P]>
  }




  export type BillingOrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingOrganizationWhereInput
    orderBy?: BillingOrganizationOrderByWithAggregationInput | BillingOrganizationOrderByWithAggregationInput[]
    by: BillingOrganizationScalarFieldEnum[] | BillingOrganizationScalarFieldEnum
    having?: BillingOrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingOrganizationCountAggregateInputType | true
    _min?: BillingOrganizationMinAggregateInputType
    _max?: BillingOrganizationMaxAggregateInputType
  }

  export type BillingOrganizationGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BillingOrganizationCountAggregateOutputType | null
    _min: BillingOrganizationMinAggregateOutputType | null
    _max: BillingOrganizationMaxAggregateOutputType | null
  }

  type GetBillingOrganizationGroupByPayload<T extends BillingOrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingOrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingOrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingOrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], BillingOrganizationGroupByOutputType[P]>
        }
      >
    >


  export type BillingOrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingOrganization"]>

  export type BillingOrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingOrganization"]>

  export type BillingOrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingOrganization"]>

  export type BillingOrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillingOrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["billingOrganization"]>

  export type $BillingOrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingOrganization"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billingOrganization"]>
    composites: {}
  }

  type BillingOrganizationGetPayload<S extends boolean | null | undefined | BillingOrganizationDefaultArgs> = $Result.GetResult<Prisma.$BillingOrganizationPayload, S>

  type BillingOrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingOrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingOrganizationCountAggregateInputType | true
    }

  export interface BillingOrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingOrganization'], meta: { name: 'BillingOrganization' } }
    /**
     * Find zero or one BillingOrganization that matches the filter.
     * @param {BillingOrganizationFindUniqueArgs} args - Arguments to find a BillingOrganization
     * @example
     * // Get one BillingOrganization
     * const billingOrganization = await prisma.billingOrganization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingOrganizationFindUniqueArgs>(args: SelectSubset<T, BillingOrganizationFindUniqueArgs<ExtArgs>>): Prisma__BillingOrganizationClient<$Result.GetResult<Prisma.$BillingOrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingOrganization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingOrganizationFindUniqueOrThrowArgs} args - Arguments to find a BillingOrganization
     * @example
     * // Get one BillingOrganization
     * const billingOrganization = await prisma.billingOrganization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingOrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingOrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingOrganizationClient<$Result.GetResult<Prisma.$BillingOrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingOrganization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingOrganizationFindFirstArgs} args - Arguments to find a BillingOrganization
     * @example
     * // Get one BillingOrganization
     * const billingOrganization = await prisma.billingOrganization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingOrganizationFindFirstArgs>(args?: SelectSubset<T, BillingOrganizationFindFirstArgs<ExtArgs>>): Prisma__BillingOrganizationClient<$Result.GetResult<Prisma.$BillingOrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingOrganization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingOrganizationFindFirstOrThrowArgs} args - Arguments to find a BillingOrganization
     * @example
     * // Get one BillingOrganization
     * const billingOrganization = await prisma.billingOrganization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingOrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingOrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingOrganizationClient<$Result.GetResult<Prisma.$BillingOrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingOrganizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingOrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingOrganizations
     * const billingOrganizations = await prisma.billingOrganization.findMany()
     * 
     * // Get first 10 BillingOrganizations
     * const billingOrganizations = await prisma.billingOrganization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingOrganizationWithIdOnly = await prisma.billingOrganization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingOrganizationFindManyArgs>(args?: SelectSubset<T, BillingOrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingOrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingOrganization.
     * @param {BillingOrganizationCreateArgs} args - Arguments to create a BillingOrganization.
     * @example
     * // Create one BillingOrganization
     * const BillingOrganization = await prisma.billingOrganization.create({
     *   data: {
     *     // ... data to create a BillingOrganization
     *   }
     * })
     * 
     */
    create<T extends BillingOrganizationCreateArgs>(args: SelectSubset<T, BillingOrganizationCreateArgs<ExtArgs>>): Prisma__BillingOrganizationClient<$Result.GetResult<Prisma.$BillingOrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingOrganizations.
     * @param {BillingOrganizationCreateManyArgs} args - Arguments to create many BillingOrganizations.
     * @example
     * // Create many BillingOrganizations
     * const billingOrganization = await prisma.billingOrganization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingOrganizationCreateManyArgs>(args?: SelectSubset<T, BillingOrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingOrganizations and returns the data saved in the database.
     * @param {BillingOrganizationCreateManyAndReturnArgs} args - Arguments to create many BillingOrganizations.
     * @example
     * // Create many BillingOrganizations
     * const billingOrganization = await prisma.billingOrganization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingOrganizations and only return the `id`
     * const billingOrganizationWithIdOnly = await prisma.billingOrganization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingOrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingOrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingOrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingOrganization.
     * @param {BillingOrganizationDeleteArgs} args - Arguments to delete one BillingOrganization.
     * @example
     * // Delete one BillingOrganization
     * const BillingOrganization = await prisma.billingOrganization.delete({
     *   where: {
     *     // ... filter to delete one BillingOrganization
     *   }
     * })
     * 
     */
    delete<T extends BillingOrganizationDeleteArgs>(args: SelectSubset<T, BillingOrganizationDeleteArgs<ExtArgs>>): Prisma__BillingOrganizationClient<$Result.GetResult<Prisma.$BillingOrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingOrganization.
     * @param {BillingOrganizationUpdateArgs} args - Arguments to update one BillingOrganization.
     * @example
     * // Update one BillingOrganization
     * const billingOrganization = await prisma.billingOrganization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingOrganizationUpdateArgs>(args: SelectSubset<T, BillingOrganizationUpdateArgs<ExtArgs>>): Prisma__BillingOrganizationClient<$Result.GetResult<Prisma.$BillingOrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingOrganizations.
     * @param {BillingOrganizationDeleteManyArgs} args - Arguments to filter BillingOrganizations to delete.
     * @example
     * // Delete a few BillingOrganizations
     * const { count } = await prisma.billingOrganization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingOrganizationDeleteManyArgs>(args?: SelectSubset<T, BillingOrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingOrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingOrganizations
     * const billingOrganization = await prisma.billingOrganization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingOrganizationUpdateManyArgs>(args: SelectSubset<T, BillingOrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingOrganizations and returns the data updated in the database.
     * @param {BillingOrganizationUpdateManyAndReturnArgs} args - Arguments to update many BillingOrganizations.
     * @example
     * // Update many BillingOrganizations
     * const billingOrganization = await prisma.billingOrganization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingOrganizations and only return the `id`
     * const billingOrganizationWithIdOnly = await prisma.billingOrganization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingOrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingOrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingOrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingOrganization.
     * @param {BillingOrganizationUpsertArgs} args - Arguments to update or create a BillingOrganization.
     * @example
     * // Update or create a BillingOrganization
     * const billingOrganization = await prisma.billingOrganization.upsert({
     *   create: {
     *     // ... data to create a BillingOrganization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingOrganization we want to update
     *   }
     * })
     */
    upsert<T extends BillingOrganizationUpsertArgs>(args: SelectSubset<T, BillingOrganizationUpsertArgs<ExtArgs>>): Prisma__BillingOrganizationClient<$Result.GetResult<Prisma.$BillingOrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingOrganizationCountArgs} args - Arguments to filter BillingOrganizations to count.
     * @example
     * // Count the number of BillingOrganizations
     * const count = await prisma.billingOrganization.count({
     *   where: {
     *     // ... the filter for the BillingOrganizations we want to count
     *   }
     * })
    **/
    count<T extends BillingOrganizationCountArgs>(
      args?: Subset<T, BillingOrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingOrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingOrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingOrganizationAggregateArgs>(args: Subset<T, BillingOrganizationAggregateArgs>): Prisma.PrismaPromise<GetBillingOrganizationAggregateType<T>>

    /**
     * Group by BillingOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingOrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingOrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingOrganizationGroupByArgs['orderBy'] }
        : { orderBy?: BillingOrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingOrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingOrganization model
   */
  readonly fields: BillingOrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingOrganization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingOrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingOrganization model
   */
  interface BillingOrganizationFieldRefs {
    readonly id: FieldRef<"BillingOrganization", 'String'>
    readonly name: FieldRef<"BillingOrganization", 'String'>
    readonly createdAt: FieldRef<"BillingOrganization", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingOrganization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingOrganization findUnique
   */
  export type BillingOrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
    /**
     * Filter, which BillingOrganization to fetch.
     */
    where: BillingOrganizationWhereUniqueInput
  }

  /**
   * BillingOrganization findUniqueOrThrow
   */
  export type BillingOrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
    /**
     * Filter, which BillingOrganization to fetch.
     */
    where: BillingOrganizationWhereUniqueInput
  }

  /**
   * BillingOrganization findFirst
   */
  export type BillingOrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
    /**
     * Filter, which BillingOrganization to fetch.
     */
    where?: BillingOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingOrganizations to fetch.
     */
    orderBy?: BillingOrganizationOrderByWithRelationInput | BillingOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingOrganizations.
     */
    cursor?: BillingOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingOrganizations.
     */
    distinct?: BillingOrganizationScalarFieldEnum | BillingOrganizationScalarFieldEnum[]
  }

  /**
   * BillingOrganization findFirstOrThrow
   */
  export type BillingOrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
    /**
     * Filter, which BillingOrganization to fetch.
     */
    where?: BillingOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingOrganizations to fetch.
     */
    orderBy?: BillingOrganizationOrderByWithRelationInput | BillingOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingOrganizations.
     */
    cursor?: BillingOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingOrganizations.
     */
    distinct?: BillingOrganizationScalarFieldEnum | BillingOrganizationScalarFieldEnum[]
  }

  /**
   * BillingOrganization findMany
   */
  export type BillingOrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
    /**
     * Filter, which BillingOrganizations to fetch.
     */
    where?: BillingOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingOrganizations to fetch.
     */
    orderBy?: BillingOrganizationOrderByWithRelationInput | BillingOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingOrganizations.
     */
    cursor?: BillingOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingOrganizations.
     */
    skip?: number
    distinct?: BillingOrganizationScalarFieldEnum | BillingOrganizationScalarFieldEnum[]
  }

  /**
   * BillingOrganization create
   */
  export type BillingOrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
    /**
     * The data needed to create a BillingOrganization.
     */
    data: XOR<BillingOrganizationCreateInput, BillingOrganizationUncheckedCreateInput>
  }

  /**
   * BillingOrganization createMany
   */
  export type BillingOrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingOrganizations.
     */
    data: BillingOrganizationCreateManyInput | BillingOrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingOrganization createManyAndReturn
   */
  export type BillingOrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many BillingOrganizations.
     */
    data: BillingOrganizationCreateManyInput | BillingOrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingOrganization update
   */
  export type BillingOrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
    /**
     * The data needed to update a BillingOrganization.
     */
    data: XOR<BillingOrganizationUpdateInput, BillingOrganizationUncheckedUpdateInput>
    /**
     * Choose, which BillingOrganization to update.
     */
    where: BillingOrganizationWhereUniqueInput
  }

  /**
   * BillingOrganization updateMany
   */
  export type BillingOrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingOrganizations.
     */
    data: XOR<BillingOrganizationUpdateManyMutationInput, BillingOrganizationUncheckedUpdateManyInput>
    /**
     * Filter which BillingOrganizations to update
     */
    where?: BillingOrganizationWhereInput
    /**
     * Limit how many BillingOrganizations to update.
     */
    limit?: number
  }

  /**
   * BillingOrganization updateManyAndReturn
   */
  export type BillingOrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
    /**
     * The data used to update BillingOrganizations.
     */
    data: XOR<BillingOrganizationUpdateManyMutationInput, BillingOrganizationUncheckedUpdateManyInput>
    /**
     * Filter which BillingOrganizations to update
     */
    where?: BillingOrganizationWhereInput
    /**
     * Limit how many BillingOrganizations to update.
     */
    limit?: number
  }

  /**
   * BillingOrganization upsert
   */
  export type BillingOrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
    /**
     * The filter to search for the BillingOrganization to update in case it exists.
     */
    where: BillingOrganizationWhereUniqueInput
    /**
     * In case the BillingOrganization found by the `where` argument doesn't exist, create a new BillingOrganization with this data.
     */
    create: XOR<BillingOrganizationCreateInput, BillingOrganizationUncheckedCreateInput>
    /**
     * In case the BillingOrganization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingOrganizationUpdateInput, BillingOrganizationUncheckedUpdateInput>
  }

  /**
   * BillingOrganization delete
   */
  export type BillingOrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
    /**
     * Filter which BillingOrganization to delete.
     */
    where: BillingOrganizationWhereUniqueInput
  }

  /**
   * BillingOrganization deleteMany
   */
  export type BillingOrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingOrganizations to delete
     */
    where?: BillingOrganizationWhereInput
    /**
     * Limit how many BillingOrganizations to delete.
     */
    limit?: number
  }

  /**
   * BillingOrganization without action
   */
  export type BillingOrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingOrganization
     */
    select?: BillingOrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingOrganization
     */
    omit?: BillingOrganizationOmit<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    sortOrder: number | null
  }

  export type PlanSumAggregateOutputType = {
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    sortOrder: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    currency: string | null
    isPublic: boolean | null
    sortOrder: number | null
    stripeProductId: string | null
    stripeMonthlyPriceId: string | null
    stripeYearlyPriceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    currency: string | null
    isPublic: boolean | null
    sortOrder: number | null
    stripeProductId: string | null
    stripeMonthlyPriceId: string | null
    stripeYearlyPriceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    priceMonthly: number
    priceYearly: number
    currency: number
    isPublic: number
    sortOrder: number
    stripeProductId: number
    stripeMonthlyPriceId: number
    stripeYearlyPriceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    priceMonthly?: true
    priceYearly?: true
    sortOrder?: true
  }

  export type PlanSumAggregateInputType = {
    priceMonthly?: true
    priceYearly?: true
    sortOrder?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    currency?: true
    isPublic?: true
    sortOrder?: true
    stripeProductId?: true
    stripeMonthlyPriceId?: true
    stripeYearlyPriceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    currency?: true
    isPublic?: true
    sortOrder?: true
    stripeProductId?: true
    stripeMonthlyPriceId?: true
    stripeYearlyPriceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    currency?: true
    isPublic?: true
    sortOrder?: true
    stripeProductId?: true
    stripeMonthlyPriceId?: true
    stripeYearlyPriceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    priceMonthly: Decimal
    priceYearly: Decimal
    currency: string
    isPublic: boolean
    sortOrder: number
    stripeProductId: string | null
    stripeMonthlyPriceId: string | null
    stripeYearlyPriceId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    currency?: boolean
    isPublic?: boolean
    sortOrder?: boolean
    stripeProductId?: boolean
    stripeMonthlyPriceId?: boolean
    stripeYearlyPriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    features?: boolean | Plan$featuresArgs<ExtArgs>
    limits?: boolean | Plan$limitsArgs<ExtArgs>
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    changeRequestsCurrent?: boolean | Plan$changeRequestsCurrentArgs<ExtArgs>
    changeRequestsNew?: boolean | Plan$changeRequestsNewArgs<ExtArgs>
    historyPrevious?: boolean | Plan$historyPreviousArgs<ExtArgs>
    historyNew?: boolean | Plan$historyNewArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    currency?: boolean
    isPublic?: boolean
    sortOrder?: boolean
    stripeProductId?: boolean
    stripeMonthlyPriceId?: boolean
    stripeYearlyPriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    currency?: boolean
    isPublic?: boolean
    sortOrder?: boolean
    stripeProductId?: boolean
    stripeMonthlyPriceId?: boolean
    stripeYearlyPriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    currency?: boolean
    isPublic?: boolean
    sortOrder?: boolean
    stripeProductId?: boolean
    stripeMonthlyPriceId?: boolean
    stripeYearlyPriceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "displayName" | "description" | "priceMonthly" | "priceYearly" | "currency" | "isPublic" | "sortOrder" | "stripeProductId" | "stripeMonthlyPriceId" | "stripeYearlyPriceId" | "createdAt" | "updatedAt", ExtArgs["result"]["plan"]>
  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | Plan$featuresArgs<ExtArgs>
    limits?: boolean | Plan$limitsArgs<ExtArgs>
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    changeRequestsCurrent?: boolean | Plan$changeRequestsCurrentArgs<ExtArgs>
    changeRequestsNew?: boolean | Plan$changeRequestsNewArgs<ExtArgs>
    historyPrevious?: boolean | Plan$historyPreviousArgs<ExtArgs>
    historyNew?: boolean | Plan$historyNewArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      features: Prisma.$PlanFeaturePayload<ExtArgs>[]
      limits: Prisma.$PlanLimitPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      changeRequestsCurrent: Prisma.$PlanChangeRequestPayload<ExtArgs>[]
      changeRequestsNew: Prisma.$PlanChangeRequestPayload<ExtArgs>[]
      historyPrevious: Prisma.$SubscriptionHistoryPayload<ExtArgs>[]
      historyNew: Prisma.$SubscriptionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      priceMonthly: Prisma.Decimal
      priceYearly: Prisma.Decimal
      currency: string
      isPublic: boolean
      sortOrder: number
      stripeProductId: string | null
      stripeMonthlyPriceId: string | null
      stripeYearlyPriceId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends Plan$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Plan$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    limits<T extends Plan$limitsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$limitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Plan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    changeRequestsCurrent<T extends Plan$changeRequestsCurrentArgs<ExtArgs> = {}>(args?: Subset<T, Plan$changeRequestsCurrentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    changeRequestsNew<T extends Plan$changeRequestsNewArgs<ExtArgs> = {}>(args?: Subset<T, Plan$changeRequestsNewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    historyPrevious<T extends Plan$historyPreviousArgs<ExtArgs> = {}>(args?: Subset<T, Plan$historyPreviousArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    historyNew<T extends Plan$historyNewArgs<ExtArgs> = {}>(args?: Subset<T, Plan$historyNewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly displayName: FieldRef<"Plan", 'String'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly priceMonthly: FieldRef<"Plan", 'Decimal'>
    readonly priceYearly: FieldRef<"Plan", 'Decimal'>
    readonly currency: FieldRef<"Plan", 'String'>
    readonly isPublic: FieldRef<"Plan", 'Boolean'>
    readonly sortOrder: FieldRef<"Plan", 'Int'>
    readonly stripeProductId: FieldRef<"Plan", 'String'>
    readonly stripeMonthlyPriceId: FieldRef<"Plan", 'String'>
    readonly stripeYearlyPriceId: FieldRef<"Plan", 'String'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan.features
   */
  export type Plan$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    where?: PlanFeatureWhereInput
    orderBy?: PlanFeatureOrderByWithRelationInput | PlanFeatureOrderByWithRelationInput[]
    cursor?: PlanFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanFeatureScalarFieldEnum | PlanFeatureScalarFieldEnum[]
  }

  /**
   * Plan.limits
   */
  export type Plan$limitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitInclude<ExtArgs> | null
    where?: PlanLimitWhereInput
    orderBy?: PlanLimitOrderByWithRelationInput | PlanLimitOrderByWithRelationInput[]
    cursor?: PlanLimitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanLimitScalarFieldEnum | PlanLimitScalarFieldEnum[]
  }

  /**
   * Plan.subscriptions
   */
  export type Plan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Plan.changeRequestsCurrent
   */
  export type Plan$changeRequestsCurrentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
    where?: PlanChangeRequestWhereInput
    orderBy?: PlanChangeRequestOrderByWithRelationInput | PlanChangeRequestOrderByWithRelationInput[]
    cursor?: PlanChangeRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanChangeRequestScalarFieldEnum | PlanChangeRequestScalarFieldEnum[]
  }

  /**
   * Plan.changeRequestsNew
   */
  export type Plan$changeRequestsNewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
    where?: PlanChangeRequestWhereInput
    orderBy?: PlanChangeRequestOrderByWithRelationInput | PlanChangeRequestOrderByWithRelationInput[]
    cursor?: PlanChangeRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanChangeRequestScalarFieldEnum | PlanChangeRequestScalarFieldEnum[]
  }

  /**
   * Plan.historyPrevious
   */
  export type Plan$historyPreviousArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    where?: SubscriptionHistoryWhereInput
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    cursor?: SubscriptionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionHistoryScalarFieldEnum | SubscriptionHistoryScalarFieldEnum[]
  }

  /**
   * Plan.historyNew
   */
  export type Plan$historyNewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    where?: SubscriptionHistoryWhereInput
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    cursor?: SubscriptionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionHistoryScalarFieldEnum | SubscriptionHistoryScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model PlanFeature
   */

  export type AggregatePlanFeature = {
    _count: PlanFeatureCountAggregateOutputType | null
    _min: PlanFeatureMinAggregateOutputType | null
    _max: PlanFeatureMaxAggregateOutputType | null
  }

  export type PlanFeatureMinAggregateOutputType = {
    id: string | null
    planId: string | null
    name: string | null
    description: string | null
    featureType: string | null
    isHighlighted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanFeatureMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    name: string | null
    description: string | null
    featureType: string | null
    isHighlighted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanFeatureCountAggregateOutputType = {
    id: number
    planId: number
    name: number
    description: number
    featureType: number
    value: number
    isHighlighted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanFeatureMinAggregateInputType = {
    id?: true
    planId?: true
    name?: true
    description?: true
    featureType?: true
    isHighlighted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanFeatureMaxAggregateInputType = {
    id?: true
    planId?: true
    name?: true
    description?: true
    featureType?: true
    isHighlighted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanFeatureCountAggregateInputType = {
    id?: true
    planId?: true
    name?: true
    description?: true
    featureType?: true
    value?: true
    isHighlighted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanFeature to aggregate.
     */
    where?: PlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatures to fetch.
     */
    orderBy?: PlanFeatureOrderByWithRelationInput | PlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanFeatures
    **/
    _count?: true | PlanFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanFeatureMaxAggregateInputType
  }

  export type GetPlanFeatureAggregateType<T extends PlanFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanFeature[P]>
      : GetScalarType<T[P], AggregatePlanFeature[P]>
  }




  export type PlanFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanFeatureWhereInput
    orderBy?: PlanFeatureOrderByWithAggregationInput | PlanFeatureOrderByWithAggregationInput[]
    by: PlanFeatureScalarFieldEnum[] | PlanFeatureScalarFieldEnum
    having?: PlanFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanFeatureCountAggregateInputType | true
    _min?: PlanFeatureMinAggregateInputType
    _max?: PlanFeatureMaxAggregateInputType
  }

  export type PlanFeatureGroupByOutputType = {
    id: string
    planId: string
    name: string
    description: string | null
    featureType: string
    value: JsonValue
    isHighlighted: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlanFeatureCountAggregateOutputType | null
    _min: PlanFeatureMinAggregateOutputType | null
    _max: PlanFeatureMaxAggregateOutputType | null
  }

  type GetPlanFeatureGroupByPayload<T extends PlanFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], PlanFeatureGroupByOutputType[P]>
        }
      >
    >


  export type PlanFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    name?: boolean
    description?: boolean
    featureType?: boolean
    value?: boolean
    isHighlighted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planFeature"]>

  export type PlanFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    name?: boolean
    description?: boolean
    featureType?: boolean
    value?: boolean
    isHighlighted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planFeature"]>

  export type PlanFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    name?: boolean
    description?: boolean
    featureType?: boolean
    value?: boolean
    isHighlighted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planFeature"]>

  export type PlanFeatureSelectScalar = {
    id?: boolean
    planId?: boolean
    name?: boolean
    description?: boolean
    featureType?: boolean
    value?: boolean
    isHighlighted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "name" | "description" | "featureType" | "value" | "isHighlighted" | "createdAt" | "updatedAt", ExtArgs["result"]["planFeature"]>
  export type PlanFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $PlanFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanFeature"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      name: string
      description: string | null
      featureType: string
      value: Prisma.JsonValue
      isHighlighted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planFeature"]>
    composites: {}
  }

  type PlanFeatureGetPayload<S extends boolean | null | undefined | PlanFeatureDefaultArgs> = $Result.GetResult<Prisma.$PlanFeaturePayload, S>

  type PlanFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanFeatureCountAggregateInputType | true
    }

  export interface PlanFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanFeature'], meta: { name: 'PlanFeature' } }
    /**
     * Find zero or one PlanFeature that matches the filter.
     * @param {PlanFeatureFindUniqueArgs} args - Arguments to find a PlanFeature
     * @example
     * // Get one PlanFeature
     * const planFeature = await prisma.planFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFeatureFindUniqueArgs>(args: SelectSubset<T, PlanFeatureFindUniqueArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFeatureFindUniqueOrThrowArgs} args - Arguments to find a PlanFeature
     * @example
     * // Get one PlanFeature
     * const planFeature = await prisma.planFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureFindFirstArgs} args - Arguments to find a PlanFeature
     * @example
     * // Get one PlanFeature
     * const planFeature = await prisma.planFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFeatureFindFirstArgs>(args?: SelectSubset<T, PlanFeatureFindFirstArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureFindFirstOrThrowArgs} args - Arguments to find a PlanFeature
     * @example
     * // Get one PlanFeature
     * const planFeature = await prisma.planFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanFeatures
     * const planFeatures = await prisma.planFeature.findMany()
     * 
     * // Get first 10 PlanFeatures
     * const planFeatures = await prisma.planFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planFeatureWithIdOnly = await prisma.planFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFeatureFindManyArgs>(args?: SelectSubset<T, PlanFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanFeature.
     * @param {PlanFeatureCreateArgs} args - Arguments to create a PlanFeature.
     * @example
     * // Create one PlanFeature
     * const PlanFeature = await prisma.planFeature.create({
     *   data: {
     *     // ... data to create a PlanFeature
     *   }
     * })
     * 
     */
    create<T extends PlanFeatureCreateArgs>(args: SelectSubset<T, PlanFeatureCreateArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanFeatures.
     * @param {PlanFeatureCreateManyArgs} args - Arguments to create many PlanFeatures.
     * @example
     * // Create many PlanFeatures
     * const planFeature = await prisma.planFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanFeatureCreateManyArgs>(args?: SelectSubset<T, PlanFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanFeatures and returns the data saved in the database.
     * @param {PlanFeatureCreateManyAndReturnArgs} args - Arguments to create many PlanFeatures.
     * @example
     * // Create many PlanFeatures
     * const planFeature = await prisma.planFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanFeatures and only return the `id`
     * const planFeatureWithIdOnly = await prisma.planFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanFeature.
     * @param {PlanFeatureDeleteArgs} args - Arguments to delete one PlanFeature.
     * @example
     * // Delete one PlanFeature
     * const PlanFeature = await prisma.planFeature.delete({
     *   where: {
     *     // ... filter to delete one PlanFeature
     *   }
     * })
     * 
     */
    delete<T extends PlanFeatureDeleteArgs>(args: SelectSubset<T, PlanFeatureDeleteArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanFeature.
     * @param {PlanFeatureUpdateArgs} args - Arguments to update one PlanFeature.
     * @example
     * // Update one PlanFeature
     * const planFeature = await prisma.planFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanFeatureUpdateArgs>(args: SelectSubset<T, PlanFeatureUpdateArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanFeatures.
     * @param {PlanFeatureDeleteManyArgs} args - Arguments to filter PlanFeatures to delete.
     * @example
     * // Delete a few PlanFeatures
     * const { count } = await prisma.planFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanFeatureDeleteManyArgs>(args?: SelectSubset<T, PlanFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanFeatures
     * const planFeature = await prisma.planFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanFeatureUpdateManyArgs>(args: SelectSubset<T, PlanFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanFeatures and returns the data updated in the database.
     * @param {PlanFeatureUpdateManyAndReturnArgs} args - Arguments to update many PlanFeatures.
     * @example
     * // Update many PlanFeatures
     * const planFeature = await prisma.planFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanFeatures and only return the `id`
     * const planFeatureWithIdOnly = await prisma.planFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanFeature.
     * @param {PlanFeatureUpsertArgs} args - Arguments to update or create a PlanFeature.
     * @example
     * // Update or create a PlanFeature
     * const planFeature = await prisma.planFeature.upsert({
     *   create: {
     *     // ... data to create a PlanFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanFeature we want to update
     *   }
     * })
     */
    upsert<T extends PlanFeatureUpsertArgs>(args: SelectSubset<T, PlanFeatureUpsertArgs<ExtArgs>>): Prisma__PlanFeatureClient<$Result.GetResult<Prisma.$PlanFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureCountArgs} args - Arguments to filter PlanFeatures to count.
     * @example
     * // Count the number of PlanFeatures
     * const count = await prisma.planFeature.count({
     *   where: {
     *     // ... the filter for the PlanFeatures we want to count
     *   }
     * })
    **/
    count<T extends PlanFeatureCountArgs>(
      args?: Subset<T, PlanFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanFeatureAggregateArgs>(args: Subset<T, PlanFeatureAggregateArgs>): Prisma.PrismaPromise<GetPlanFeatureAggregateType<T>>

    /**
     * Group by PlanFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanFeatureGroupByArgs['orderBy'] }
        : { orderBy?: PlanFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanFeature model
   */
  readonly fields: PlanFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanFeature model
   */
  interface PlanFeatureFieldRefs {
    readonly id: FieldRef<"PlanFeature", 'String'>
    readonly planId: FieldRef<"PlanFeature", 'String'>
    readonly name: FieldRef<"PlanFeature", 'String'>
    readonly description: FieldRef<"PlanFeature", 'String'>
    readonly featureType: FieldRef<"PlanFeature", 'String'>
    readonly value: FieldRef<"PlanFeature", 'Json'>
    readonly isHighlighted: FieldRef<"PlanFeature", 'Boolean'>
    readonly createdAt: FieldRef<"PlanFeature", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanFeature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanFeature findUnique
   */
  export type PlanFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeature to fetch.
     */
    where: PlanFeatureWhereUniqueInput
  }

  /**
   * PlanFeature findUniqueOrThrow
   */
  export type PlanFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeature to fetch.
     */
    where: PlanFeatureWhereUniqueInput
  }

  /**
   * PlanFeature findFirst
   */
  export type PlanFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeature to fetch.
     */
    where?: PlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatures to fetch.
     */
    orderBy?: PlanFeatureOrderByWithRelationInput | PlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanFeatures.
     */
    cursor?: PlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanFeatures.
     */
    distinct?: PlanFeatureScalarFieldEnum | PlanFeatureScalarFieldEnum[]
  }

  /**
   * PlanFeature findFirstOrThrow
   */
  export type PlanFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeature to fetch.
     */
    where?: PlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatures to fetch.
     */
    orderBy?: PlanFeatureOrderByWithRelationInput | PlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanFeatures.
     */
    cursor?: PlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanFeatures.
     */
    distinct?: PlanFeatureScalarFieldEnum | PlanFeatureScalarFieldEnum[]
  }

  /**
   * PlanFeature findMany
   */
  export type PlanFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PlanFeatures to fetch.
     */
    where?: PlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanFeatures to fetch.
     */
    orderBy?: PlanFeatureOrderByWithRelationInput | PlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanFeatures.
     */
    cursor?: PlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanFeatures.
     */
    skip?: number
    distinct?: PlanFeatureScalarFieldEnum | PlanFeatureScalarFieldEnum[]
  }

  /**
   * PlanFeature create
   */
  export type PlanFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanFeature.
     */
    data: XOR<PlanFeatureCreateInput, PlanFeatureUncheckedCreateInput>
  }

  /**
   * PlanFeature createMany
   */
  export type PlanFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanFeatures.
     */
    data: PlanFeatureCreateManyInput | PlanFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanFeature createManyAndReturn
   */
  export type PlanFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many PlanFeatures.
     */
    data: PlanFeatureCreateManyInput | PlanFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanFeature update
   */
  export type PlanFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanFeature.
     */
    data: XOR<PlanFeatureUpdateInput, PlanFeatureUncheckedUpdateInput>
    /**
     * Choose, which PlanFeature to update.
     */
    where: PlanFeatureWhereUniqueInput
  }

  /**
   * PlanFeature updateMany
   */
  export type PlanFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanFeatures.
     */
    data: XOR<PlanFeatureUpdateManyMutationInput, PlanFeatureUncheckedUpdateManyInput>
    /**
     * Filter which PlanFeatures to update
     */
    where?: PlanFeatureWhereInput
    /**
     * Limit how many PlanFeatures to update.
     */
    limit?: number
  }

  /**
   * PlanFeature updateManyAndReturn
   */
  export type PlanFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * The data used to update PlanFeatures.
     */
    data: XOR<PlanFeatureUpdateManyMutationInput, PlanFeatureUncheckedUpdateManyInput>
    /**
     * Filter which PlanFeatures to update
     */
    where?: PlanFeatureWhereInput
    /**
     * Limit how many PlanFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanFeature upsert
   */
  export type PlanFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanFeature to update in case it exists.
     */
    where: PlanFeatureWhereUniqueInput
    /**
     * In case the PlanFeature found by the `where` argument doesn't exist, create a new PlanFeature with this data.
     */
    create: XOR<PlanFeatureCreateInput, PlanFeatureUncheckedCreateInput>
    /**
     * In case the PlanFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanFeatureUpdateInput, PlanFeatureUncheckedUpdateInput>
  }

  /**
   * PlanFeature delete
   */
  export type PlanFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
    /**
     * Filter which PlanFeature to delete.
     */
    where: PlanFeatureWhereUniqueInput
  }

  /**
   * PlanFeature deleteMany
   */
  export type PlanFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanFeatures to delete
     */
    where?: PlanFeatureWhereInput
    /**
     * Limit how many PlanFeatures to delete.
     */
    limit?: number
  }

  /**
   * PlanFeature without action
   */
  export type PlanFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanFeature
     */
    select?: PlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanFeature
     */
    omit?: PlanFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanFeatureInclude<ExtArgs> | null
  }


  /**
   * Model PlanLimit
   */

  export type AggregatePlanLimit = {
    _count: PlanLimitCountAggregateOutputType | null
    _avg: PlanLimitAvgAggregateOutputType | null
    _sum: PlanLimitSumAggregateOutputType | null
    _min: PlanLimitMinAggregateOutputType | null
    _max: PlanLimitMaxAggregateOutputType | null
  }

  export type PlanLimitAvgAggregateOutputType = {
    maxValue: number | null
    overagePrice: Decimal | null
  }

  export type PlanLimitSumAggregateOutputType = {
    maxValue: number | null
    overagePrice: Decimal | null
  }

  export type PlanLimitMinAggregateOutputType = {
    id: string | null
    planId: string | null
    resourceType: string | null
    maxValue: number | null
    overagePrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanLimitMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    resourceType: string | null
    maxValue: number | null
    overagePrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanLimitCountAggregateOutputType = {
    id: number
    planId: number
    resourceType: number
    maxValue: number
    overagePrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanLimitAvgAggregateInputType = {
    maxValue?: true
    overagePrice?: true
  }

  export type PlanLimitSumAggregateInputType = {
    maxValue?: true
    overagePrice?: true
  }

  export type PlanLimitMinAggregateInputType = {
    id?: true
    planId?: true
    resourceType?: true
    maxValue?: true
    overagePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanLimitMaxAggregateInputType = {
    id?: true
    planId?: true
    resourceType?: true
    maxValue?: true
    overagePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanLimitCountAggregateInputType = {
    id?: true
    planId?: true
    resourceType?: true
    maxValue?: true
    overagePrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanLimitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanLimit to aggregate.
     */
    where?: PlanLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanLimits to fetch.
     */
    orderBy?: PlanLimitOrderByWithRelationInput | PlanLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanLimits
    **/
    _count?: true | PlanLimitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanLimitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanLimitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanLimitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanLimitMaxAggregateInputType
  }

  export type GetPlanLimitAggregateType<T extends PlanLimitAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanLimit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanLimit[P]>
      : GetScalarType<T[P], AggregatePlanLimit[P]>
  }




  export type PlanLimitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanLimitWhereInput
    orderBy?: PlanLimitOrderByWithAggregationInput | PlanLimitOrderByWithAggregationInput[]
    by: PlanLimitScalarFieldEnum[] | PlanLimitScalarFieldEnum
    having?: PlanLimitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanLimitCountAggregateInputType | true
    _avg?: PlanLimitAvgAggregateInputType
    _sum?: PlanLimitSumAggregateInputType
    _min?: PlanLimitMinAggregateInputType
    _max?: PlanLimitMaxAggregateInputType
  }

  export type PlanLimitGroupByOutputType = {
    id: string
    planId: string
    resourceType: string
    maxValue: number
    overagePrice: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: PlanLimitCountAggregateOutputType | null
    _avg: PlanLimitAvgAggregateOutputType | null
    _sum: PlanLimitSumAggregateOutputType | null
    _min: PlanLimitMinAggregateOutputType | null
    _max: PlanLimitMaxAggregateOutputType | null
  }

  type GetPlanLimitGroupByPayload<T extends PlanLimitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanLimitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanLimitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanLimitGroupByOutputType[P]>
            : GetScalarType<T[P], PlanLimitGroupByOutputType[P]>
        }
      >
    >


  export type PlanLimitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    resourceType?: boolean
    maxValue?: boolean
    overagePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planLimit"]>

  export type PlanLimitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    resourceType?: boolean
    maxValue?: boolean
    overagePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planLimit"]>

  export type PlanLimitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    resourceType?: boolean
    maxValue?: boolean
    overagePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planLimit"]>

  export type PlanLimitSelectScalar = {
    id?: boolean
    planId?: boolean
    resourceType?: boolean
    maxValue?: boolean
    overagePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanLimitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "resourceType" | "maxValue" | "overagePrice" | "createdAt" | "updatedAt", ExtArgs["result"]["planLimit"]>
  export type PlanLimitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanLimitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanLimitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $PlanLimitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanLimit"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      resourceType: string
      maxValue: number
      overagePrice: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planLimit"]>
    composites: {}
  }

  type PlanLimitGetPayload<S extends boolean | null | undefined | PlanLimitDefaultArgs> = $Result.GetResult<Prisma.$PlanLimitPayload, S>

  type PlanLimitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanLimitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanLimitCountAggregateInputType | true
    }

  export interface PlanLimitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanLimit'], meta: { name: 'PlanLimit' } }
    /**
     * Find zero or one PlanLimit that matches the filter.
     * @param {PlanLimitFindUniqueArgs} args - Arguments to find a PlanLimit
     * @example
     * // Get one PlanLimit
     * const planLimit = await prisma.planLimit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanLimitFindUniqueArgs>(args: SelectSubset<T, PlanLimitFindUniqueArgs<ExtArgs>>): Prisma__PlanLimitClient<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanLimit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanLimitFindUniqueOrThrowArgs} args - Arguments to find a PlanLimit
     * @example
     * // Get one PlanLimit
     * const planLimit = await prisma.planLimit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanLimitFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanLimitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanLimitClient<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanLimit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanLimitFindFirstArgs} args - Arguments to find a PlanLimit
     * @example
     * // Get one PlanLimit
     * const planLimit = await prisma.planLimit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanLimitFindFirstArgs>(args?: SelectSubset<T, PlanLimitFindFirstArgs<ExtArgs>>): Prisma__PlanLimitClient<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanLimit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanLimitFindFirstOrThrowArgs} args - Arguments to find a PlanLimit
     * @example
     * // Get one PlanLimit
     * const planLimit = await prisma.planLimit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanLimitFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanLimitFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanLimitClient<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanLimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanLimitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanLimits
     * const planLimits = await prisma.planLimit.findMany()
     * 
     * // Get first 10 PlanLimits
     * const planLimits = await prisma.planLimit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planLimitWithIdOnly = await prisma.planLimit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanLimitFindManyArgs>(args?: SelectSubset<T, PlanLimitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanLimit.
     * @param {PlanLimitCreateArgs} args - Arguments to create a PlanLimit.
     * @example
     * // Create one PlanLimit
     * const PlanLimit = await prisma.planLimit.create({
     *   data: {
     *     // ... data to create a PlanLimit
     *   }
     * })
     * 
     */
    create<T extends PlanLimitCreateArgs>(args: SelectSubset<T, PlanLimitCreateArgs<ExtArgs>>): Prisma__PlanLimitClient<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanLimits.
     * @param {PlanLimitCreateManyArgs} args - Arguments to create many PlanLimits.
     * @example
     * // Create many PlanLimits
     * const planLimit = await prisma.planLimit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanLimitCreateManyArgs>(args?: SelectSubset<T, PlanLimitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanLimits and returns the data saved in the database.
     * @param {PlanLimitCreateManyAndReturnArgs} args - Arguments to create many PlanLimits.
     * @example
     * // Create many PlanLimits
     * const planLimit = await prisma.planLimit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanLimits and only return the `id`
     * const planLimitWithIdOnly = await prisma.planLimit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanLimitCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanLimitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanLimit.
     * @param {PlanLimitDeleteArgs} args - Arguments to delete one PlanLimit.
     * @example
     * // Delete one PlanLimit
     * const PlanLimit = await prisma.planLimit.delete({
     *   where: {
     *     // ... filter to delete one PlanLimit
     *   }
     * })
     * 
     */
    delete<T extends PlanLimitDeleteArgs>(args: SelectSubset<T, PlanLimitDeleteArgs<ExtArgs>>): Prisma__PlanLimitClient<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanLimit.
     * @param {PlanLimitUpdateArgs} args - Arguments to update one PlanLimit.
     * @example
     * // Update one PlanLimit
     * const planLimit = await prisma.planLimit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanLimitUpdateArgs>(args: SelectSubset<T, PlanLimitUpdateArgs<ExtArgs>>): Prisma__PlanLimitClient<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanLimits.
     * @param {PlanLimitDeleteManyArgs} args - Arguments to filter PlanLimits to delete.
     * @example
     * // Delete a few PlanLimits
     * const { count } = await prisma.planLimit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanLimitDeleteManyArgs>(args?: SelectSubset<T, PlanLimitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanLimitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanLimits
     * const planLimit = await prisma.planLimit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanLimitUpdateManyArgs>(args: SelectSubset<T, PlanLimitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanLimits and returns the data updated in the database.
     * @param {PlanLimitUpdateManyAndReturnArgs} args - Arguments to update many PlanLimits.
     * @example
     * // Update many PlanLimits
     * const planLimit = await prisma.planLimit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanLimits and only return the `id`
     * const planLimitWithIdOnly = await prisma.planLimit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanLimitUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanLimitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanLimit.
     * @param {PlanLimitUpsertArgs} args - Arguments to update or create a PlanLimit.
     * @example
     * // Update or create a PlanLimit
     * const planLimit = await prisma.planLimit.upsert({
     *   create: {
     *     // ... data to create a PlanLimit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanLimit we want to update
     *   }
     * })
     */
    upsert<T extends PlanLimitUpsertArgs>(args: SelectSubset<T, PlanLimitUpsertArgs<ExtArgs>>): Prisma__PlanLimitClient<$Result.GetResult<Prisma.$PlanLimitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanLimitCountArgs} args - Arguments to filter PlanLimits to count.
     * @example
     * // Count the number of PlanLimits
     * const count = await prisma.planLimit.count({
     *   where: {
     *     // ... the filter for the PlanLimits we want to count
     *   }
     * })
    **/
    count<T extends PlanLimitCountArgs>(
      args?: Subset<T, PlanLimitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanLimitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanLimitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanLimitAggregateArgs>(args: Subset<T, PlanLimitAggregateArgs>): Prisma.PrismaPromise<GetPlanLimitAggregateType<T>>

    /**
     * Group by PlanLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanLimitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanLimitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanLimitGroupByArgs['orderBy'] }
        : { orderBy?: PlanLimitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanLimitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanLimitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanLimit model
   */
  readonly fields: PlanLimitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanLimit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanLimitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanLimit model
   */
  interface PlanLimitFieldRefs {
    readonly id: FieldRef<"PlanLimit", 'String'>
    readonly planId: FieldRef<"PlanLimit", 'String'>
    readonly resourceType: FieldRef<"PlanLimit", 'String'>
    readonly maxValue: FieldRef<"PlanLimit", 'Int'>
    readonly overagePrice: FieldRef<"PlanLimit", 'Decimal'>
    readonly createdAt: FieldRef<"PlanLimit", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanLimit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanLimit findUnique
   */
  export type PlanLimitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitInclude<ExtArgs> | null
    /**
     * Filter, which PlanLimit to fetch.
     */
    where: PlanLimitWhereUniqueInput
  }

  /**
   * PlanLimit findUniqueOrThrow
   */
  export type PlanLimitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitInclude<ExtArgs> | null
    /**
     * Filter, which PlanLimit to fetch.
     */
    where: PlanLimitWhereUniqueInput
  }

  /**
   * PlanLimit findFirst
   */
  export type PlanLimitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitInclude<ExtArgs> | null
    /**
     * Filter, which PlanLimit to fetch.
     */
    where?: PlanLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanLimits to fetch.
     */
    orderBy?: PlanLimitOrderByWithRelationInput | PlanLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanLimits.
     */
    cursor?: PlanLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanLimits.
     */
    distinct?: PlanLimitScalarFieldEnum | PlanLimitScalarFieldEnum[]
  }

  /**
   * PlanLimit findFirstOrThrow
   */
  export type PlanLimitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitInclude<ExtArgs> | null
    /**
     * Filter, which PlanLimit to fetch.
     */
    where?: PlanLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanLimits to fetch.
     */
    orderBy?: PlanLimitOrderByWithRelationInput | PlanLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanLimits.
     */
    cursor?: PlanLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanLimits.
     */
    distinct?: PlanLimitScalarFieldEnum | PlanLimitScalarFieldEnum[]
  }

  /**
   * PlanLimit findMany
   */
  export type PlanLimitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitInclude<ExtArgs> | null
    /**
     * Filter, which PlanLimits to fetch.
     */
    where?: PlanLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanLimits to fetch.
     */
    orderBy?: PlanLimitOrderByWithRelationInput | PlanLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanLimits.
     */
    cursor?: PlanLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanLimits.
     */
    skip?: number
    distinct?: PlanLimitScalarFieldEnum | PlanLimitScalarFieldEnum[]
  }

  /**
   * PlanLimit create
   */
  export type PlanLimitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanLimit.
     */
    data: XOR<PlanLimitCreateInput, PlanLimitUncheckedCreateInput>
  }

  /**
   * PlanLimit createMany
   */
  export type PlanLimitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanLimits.
     */
    data: PlanLimitCreateManyInput | PlanLimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanLimit createManyAndReturn
   */
  export type PlanLimitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * The data used to create many PlanLimits.
     */
    data: PlanLimitCreateManyInput | PlanLimitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanLimit update
   */
  export type PlanLimitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanLimit.
     */
    data: XOR<PlanLimitUpdateInput, PlanLimitUncheckedUpdateInput>
    /**
     * Choose, which PlanLimit to update.
     */
    where: PlanLimitWhereUniqueInput
  }

  /**
   * PlanLimit updateMany
   */
  export type PlanLimitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanLimits.
     */
    data: XOR<PlanLimitUpdateManyMutationInput, PlanLimitUncheckedUpdateManyInput>
    /**
     * Filter which PlanLimits to update
     */
    where?: PlanLimitWhereInput
    /**
     * Limit how many PlanLimits to update.
     */
    limit?: number
  }

  /**
   * PlanLimit updateManyAndReturn
   */
  export type PlanLimitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * The data used to update PlanLimits.
     */
    data: XOR<PlanLimitUpdateManyMutationInput, PlanLimitUncheckedUpdateManyInput>
    /**
     * Filter which PlanLimits to update
     */
    where?: PlanLimitWhereInput
    /**
     * Limit how many PlanLimits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanLimit upsert
   */
  export type PlanLimitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanLimit to update in case it exists.
     */
    where: PlanLimitWhereUniqueInput
    /**
     * In case the PlanLimit found by the `where` argument doesn't exist, create a new PlanLimit with this data.
     */
    create: XOR<PlanLimitCreateInput, PlanLimitUncheckedCreateInput>
    /**
     * In case the PlanLimit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanLimitUpdateInput, PlanLimitUncheckedUpdateInput>
  }

  /**
   * PlanLimit delete
   */
  export type PlanLimitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitInclude<ExtArgs> | null
    /**
     * Filter which PlanLimit to delete.
     */
    where: PlanLimitWhereUniqueInput
  }

  /**
   * PlanLimit deleteMany
   */
  export type PlanLimitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanLimits to delete
     */
    where?: PlanLimitWhereInput
    /**
     * Limit how many PlanLimits to delete.
     */
    limit?: number
  }

  /**
   * PlanLimit without action
   */
  export type PlanLimitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanLimit
     */
    select?: PlanLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanLimit
     */
    omit?: PlanLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanLimitInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    planId: string | null
    billingCycle: string | null
    status: string | null
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelsAtPeriodEnd: boolean | null
    canceledAt: Date | null
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    planId: string | null
    billingCycle: string | null
    status: string | null
    trialEndsAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelsAtPeriodEnd: boolean | null
    canceledAt: Date | null
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    organizationId: number
    planId: number
    billingCycle: number
    status: number
    trialEndsAt: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelsAtPeriodEnd: number
    canceledAt: number
    stripeSubscriptionId: number
    stripeCustomerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    organizationId?: true
    planId?: true
    billingCycle?: true
    status?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelsAtPeriodEnd?: true
    canceledAt?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    organizationId?: true
    planId?: true
    billingCycle?: true
    status?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelsAtPeriodEnd?: true
    canceledAt?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    organizationId?: true
    planId?: true
    billingCycle?: true
    status?: true
    trialEndsAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelsAtPeriodEnd?: true
    canceledAt?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    organizationId: string
    planId: string
    billingCycle: string
    status: string
    trialEndsAt: Date | null
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelsAtPeriodEnd: boolean
    canceledAt: Date | null
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    planId?: boolean
    billingCycle?: boolean
    status?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelsAtPeriodEnd?: boolean
    canceledAt?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    usageRecords?: boolean | Subscription$usageRecordsArgs<ExtArgs>
    usageSummaries?: boolean | Subscription$usageSummariesArgs<ExtArgs>
    promotionRedemptions?: boolean | Subscription$promotionRedemptionsArgs<ExtArgs>
    history?: boolean | Subscription$historyArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    planId?: boolean
    billingCycle?: boolean
    status?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelsAtPeriodEnd?: boolean
    canceledAt?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    planId?: boolean
    billingCycle?: boolean
    status?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelsAtPeriodEnd?: boolean
    canceledAt?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    organizationId?: boolean
    planId?: boolean
    billingCycle?: boolean
    status?: boolean
    trialEndsAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelsAtPeriodEnd?: boolean
    canceledAt?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "planId" | "billingCycle" | "status" | "trialEndsAt" | "currentPeriodStart" | "currentPeriodEnd" | "cancelsAtPeriodEnd" | "canceledAt" | "stripeSubscriptionId" | "stripeCustomerId" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    usageRecords?: boolean | Subscription$usageRecordsArgs<ExtArgs>
    usageSummaries?: boolean | Subscription$usageSummariesArgs<ExtArgs>
    promotionRedemptions?: boolean | Subscription$promotionRedemptionsArgs<ExtArgs>
    history?: boolean | Subscription$historyArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      usageRecords: Prisma.$UsageRecordPayload<ExtArgs>[]
      usageSummaries: Prisma.$UsageSummaryPayload<ExtArgs>[]
      promotionRedemptions: Prisma.$PromotionRedemptionPayload<ExtArgs>[]
      history: Prisma.$SubscriptionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      planId: string
      billingCycle: string
      status: string
      trialEndsAt: Date | null
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelsAtPeriodEnd: boolean
      canceledAt: Date | null
      stripeSubscriptionId: string | null
      stripeCustomerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Subscription$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageRecords<T extends Subscription$usageRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$usageRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageSummaries<T extends Subscription$usageSummariesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$usageSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promotionRedemptions<T extends Subscription$promotionRedemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$promotionRedemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends Subscription$historyArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly organizationId: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly billingCycle: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly trialEndsAt: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelsAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.invoices
   */
  export type Subscription$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Subscription.usageRecords
   */
  export type Subscription$usageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    where?: UsageRecordWhereInput
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    cursor?: UsageRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * Subscription.usageSummaries
   */
  export type Subscription$usageSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryInclude<ExtArgs> | null
    where?: UsageSummaryWhereInput
    orderBy?: UsageSummaryOrderByWithRelationInput | UsageSummaryOrderByWithRelationInput[]
    cursor?: UsageSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageSummaryScalarFieldEnum | UsageSummaryScalarFieldEnum[]
  }

  /**
   * Subscription.promotionRedemptions
   */
  export type Subscription$promotionRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    where?: PromotionRedemptionWhereInput
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    cursor?: PromotionRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * Subscription.history
   */
  export type Subscription$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    where?: SubscriptionHistoryWhereInput
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    cursor?: SubscriptionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionHistoryScalarFieldEnum | SubscriptionHistoryScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    expMonth: number | null
    expYear: number | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    expMonth: number | null
    expYear: number | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    stripePaymentMethodId: string | null
    brand: string | null
    last4: string | null
    expMonth: number | null
    expYear: number | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    stripePaymentMethodId: string | null
    brand: string | null
    last4: string | null
    expMonth: number | null
    expYear: number | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    organizationId: number
    stripePaymentMethodId: number
    brand: number
    last4: number
    expMonth: number
    expYear: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    expMonth?: true
    expYear?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    expMonth?: true
    expYear?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    organizationId?: true
    stripePaymentMethodId?: true
    brand?: true
    last4?: true
    expMonth?: true
    expYear?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    organizationId?: true
    stripePaymentMethodId?: true
    brand?: true
    last4?: true
    expMonth?: true
    expYear?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    organizationId?: true
    stripePaymentMethodId?: true
    brand?: true
    last4?: true
    expMonth?: true
    expYear?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    organizationId: string
    stripePaymentMethodId: string
    brand: string
    last4: string
    expMonth: number
    expYear: number
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    stripePaymentMethodId?: boolean
    brand?: boolean
    last4?: boolean
    expMonth?: boolean
    expYear?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    stripePaymentMethodId?: boolean
    brand?: boolean
    last4?: boolean
    expMonth?: boolean
    expYear?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    stripePaymentMethodId?: boolean
    brand?: boolean
    last4?: boolean
    expMonth?: boolean
    expYear?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    organizationId?: boolean
    stripePaymentMethodId?: boolean
    brand?: boolean
    last4?: boolean
    expMonth?: boolean
    expYear?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "stripePaymentMethodId" | "brand" | "last4" | "expMonth" | "expYear" | "isDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentMethod"]>

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      stripePaymentMethodId: string
      brand: string
      last4: string
      expMonth: number
      expYear: number
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly organizationId: FieldRef<"PaymentMethod", 'String'>
    readonly stripePaymentMethodId: FieldRef<"PaymentMethod", 'String'>
    readonly brand: FieldRef<"PaymentMethod", 'String'>
    readonly last4: FieldRef<"PaymentMethod", 'String'>
    readonly expMonth: FieldRef<"PaymentMethod", 'Int'>
    readonly expYear: FieldRef<"PaymentMethod", 'Int'>
    readonly isDefault: FieldRef<"PaymentMethod", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    subscriptionId: string | null
    stripeInvoiceId: string | null
    number: string | null
    currency: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    status: string | null
    invoicePdfUrl: string | null
    periodStart: Date | null
    periodEnd: Date | null
    dueDate: Date | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    subscriptionId: string | null
    stripeInvoiceId: string | null
    number: string | null
    currency: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    status: string | null
    invoicePdfUrl: string | null
    periodStart: Date | null
    periodEnd: Date | null
    dueDate: Date | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    organizationId: number
    subscriptionId: number
    stripeInvoiceId: number
    number: number
    currency: number
    subtotal: number
    tax: number
    total: number
    status: number
    invoicePdfUrl: number
    periodStart: number
    periodEnd: number
    dueDate: number
    paidAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    number?: true
    currency?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    invoicePdfUrl?: true
    periodStart?: true
    periodEnd?: true
    dueDate?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    number?: true
    currency?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    invoicePdfUrl?: true
    periodStart?: true
    periodEnd?: true
    dueDate?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    number?: true
    currency?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    invoicePdfUrl?: true
    periodStart?: true
    periodEnd?: true
    dueDate?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    organizationId: string
    subscriptionId: string
    stripeInvoiceId: string | null
    number: string | null
    currency: string
    subtotal: Decimal
    tax: Decimal
    total: Decimal
    status: string
    invoicePdfUrl: string | null
    periodStart: Date
    periodEnd: Date
    dueDate: Date | null
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    number?: boolean
    currency?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    invoicePdfUrl?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    dueDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    number?: boolean
    currency?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    invoicePdfUrl?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    dueDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    number?: boolean
    currency?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    invoicePdfUrl?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    dueDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    number?: boolean
    currency?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    invoicePdfUrl?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    dueDate?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "subscriptionId" | "stripeInvoiceId" | "number" | "currency" | "subtotal" | "tax" | "total" | "status" | "invoicePdfUrl" | "periodStart" | "periodEnd" | "dueDate" | "paidAt" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      subscriptionId: string
      stripeInvoiceId: string | null
      number: string | null
      currency: string
      subtotal: Prisma.Decimal
      tax: Prisma.Decimal
      total: Prisma.Decimal
      status: string
      invoicePdfUrl: string | null
      periodStart: Date
      periodEnd: Date
      dueDate: Date | null
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly organizationId: FieldRef<"Invoice", 'String'>
    readonly subscriptionId: FieldRef<"Invoice", 'String'>
    readonly stripeInvoiceId: FieldRef<"Invoice", 'String'>
    readonly number: FieldRef<"Invoice", 'String'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly tax: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly invoicePdfUrl: FieldRef<"Invoice", 'String'>
    readonly periodStart: FieldRef<"Invoice", 'DateTime'>
    readonly periodEnd: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    amount: Decimal | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    amount: Decimal | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    amount: Decimal | null
    type: string | null
    createdAt: Date | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    amount: Decimal | null
    type: string | null
    createdAt: Date | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    quantity: number
    unitPrice: number
    amount: number
    type: number
    createdAt: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    amount?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    amount?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    type?: true
    createdAt?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    type?: true
    createdAt?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    quantity: number
    unitPrice: Decimal
    amount: Decimal
    type: string
    createdAt: Date
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "description" | "quantity" | "unitPrice" | "amount" | "type" | "createdAt", ExtArgs["result"]["invoiceItem"]>
  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      description: string
      quantity: number
      unitPrice: Prisma.Decimal
      amount: Prisma.Decimal
      type: string
      createdAt: Date
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems and returns the data updated in the database.
     * @param {InvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceItems.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Decimal'>
    readonly amount: FieldRef<"InvoiceItem", 'Decimal'>
    readonly type: FieldRef<"InvoiceItem", 'String'>
    readonly createdAt: FieldRef<"InvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceItem updateManyAndReturn
   */
  export type InvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model UsageRecord
   */

  export type AggregateUsageRecord = {
    _count: UsageRecordCountAggregateOutputType | null
    _avg: UsageRecordAvgAggregateOutputType | null
    _sum: UsageRecordSumAggregateOutputType | null
    _min: UsageRecordMinAggregateOutputType | null
    _max: UsageRecordMaxAggregateOutputType | null
  }

  export type UsageRecordAvgAggregateOutputType = {
    quantity: number | null
  }

  export type UsageRecordSumAggregateOutputType = {
    quantity: number | null
  }

  export type UsageRecordMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    subscriptionId: string | null
    resourceType: string | null
    quantity: number | null
    recordedAt: Date | null
  }

  export type UsageRecordMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    subscriptionId: string | null
    resourceType: string | null
    quantity: number | null
    recordedAt: Date | null
  }

  export type UsageRecordCountAggregateOutputType = {
    id: number
    organizationId: number
    subscriptionId: number
    resourceType: number
    quantity: number
    recordedAt: number
    _all: number
  }


  export type UsageRecordAvgAggregateInputType = {
    quantity?: true
  }

  export type UsageRecordSumAggregateInputType = {
    quantity?: true
  }

  export type UsageRecordMinAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    resourceType?: true
    quantity?: true
    recordedAt?: true
  }

  export type UsageRecordMaxAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    resourceType?: true
    quantity?: true
    recordedAt?: true
  }

  export type UsageRecordCountAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    resourceType?: true
    quantity?: true
    recordedAt?: true
    _all?: true
  }

  export type UsageRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageRecord to aggregate.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageRecords
    **/
    _count?: true | UsageRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageRecordMaxAggregateInputType
  }

  export type GetUsageRecordAggregateType<T extends UsageRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageRecord[P]>
      : GetScalarType<T[P], AggregateUsageRecord[P]>
  }




  export type UsageRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageRecordWhereInput
    orderBy?: UsageRecordOrderByWithAggregationInput | UsageRecordOrderByWithAggregationInput[]
    by: UsageRecordScalarFieldEnum[] | UsageRecordScalarFieldEnum
    having?: UsageRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageRecordCountAggregateInputType | true
    _avg?: UsageRecordAvgAggregateInputType
    _sum?: UsageRecordSumAggregateInputType
    _min?: UsageRecordMinAggregateInputType
    _max?: UsageRecordMaxAggregateInputType
  }

  export type UsageRecordGroupByOutputType = {
    id: string
    organizationId: string
    subscriptionId: string
    resourceType: string
    quantity: number
    recordedAt: Date
    _count: UsageRecordCountAggregateOutputType | null
    _avg: UsageRecordAvgAggregateOutputType | null
    _sum: UsageRecordSumAggregateOutputType | null
    _min: UsageRecordMinAggregateOutputType | null
    _max: UsageRecordMaxAggregateOutputType | null
  }

  type GetUsageRecordGroupByPayload<T extends UsageRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageRecordGroupByOutputType[P]>
            : GetScalarType<T[P], UsageRecordGroupByOutputType[P]>
        }
      >
    >


  export type UsageRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    resourceType?: boolean
    quantity?: boolean
    recordedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageRecord"]>

  export type UsageRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    resourceType?: boolean
    quantity?: boolean
    recordedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageRecord"]>

  export type UsageRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    resourceType?: boolean
    quantity?: boolean
    recordedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageRecord"]>

  export type UsageRecordSelectScalar = {
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    resourceType?: boolean
    quantity?: boolean
    recordedAt?: boolean
  }

  export type UsageRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "subscriptionId" | "resourceType" | "quantity" | "recordedAt", ExtArgs["result"]["usageRecord"]>
  export type UsageRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type UsageRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type UsageRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $UsageRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageRecord"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      subscriptionId: string
      resourceType: string
      quantity: number
      recordedAt: Date
    }, ExtArgs["result"]["usageRecord"]>
    composites: {}
  }

  type UsageRecordGetPayload<S extends boolean | null | undefined | UsageRecordDefaultArgs> = $Result.GetResult<Prisma.$UsageRecordPayload, S>

  type UsageRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageRecordCountAggregateInputType | true
    }

  export interface UsageRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageRecord'], meta: { name: 'UsageRecord' } }
    /**
     * Find zero or one UsageRecord that matches the filter.
     * @param {UsageRecordFindUniqueArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageRecordFindUniqueArgs>(args: SelectSubset<T, UsageRecordFindUniqueArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsageRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageRecordFindUniqueOrThrowArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindFirstArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageRecordFindFirstArgs>(args?: SelectSubset<T, UsageRecordFindFirstArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindFirstOrThrowArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsageRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageRecords
     * const usageRecords = await prisma.usageRecord.findMany()
     * 
     * // Get first 10 UsageRecords
     * const usageRecords = await prisma.usageRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageRecordWithIdOnly = await prisma.usageRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageRecordFindManyArgs>(args?: SelectSubset<T, UsageRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsageRecord.
     * @param {UsageRecordCreateArgs} args - Arguments to create a UsageRecord.
     * @example
     * // Create one UsageRecord
     * const UsageRecord = await prisma.usageRecord.create({
     *   data: {
     *     // ... data to create a UsageRecord
     *   }
     * })
     * 
     */
    create<T extends UsageRecordCreateArgs>(args: SelectSubset<T, UsageRecordCreateArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsageRecords.
     * @param {UsageRecordCreateManyArgs} args - Arguments to create many UsageRecords.
     * @example
     * // Create many UsageRecords
     * const usageRecord = await prisma.usageRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageRecordCreateManyArgs>(args?: SelectSubset<T, UsageRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageRecords and returns the data saved in the database.
     * @param {UsageRecordCreateManyAndReturnArgs} args - Arguments to create many UsageRecords.
     * @example
     * // Create many UsageRecords
     * const usageRecord = await prisma.usageRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageRecords and only return the `id`
     * const usageRecordWithIdOnly = await prisma.usageRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsageRecord.
     * @param {UsageRecordDeleteArgs} args - Arguments to delete one UsageRecord.
     * @example
     * // Delete one UsageRecord
     * const UsageRecord = await prisma.usageRecord.delete({
     *   where: {
     *     // ... filter to delete one UsageRecord
     *   }
     * })
     * 
     */
    delete<T extends UsageRecordDeleteArgs>(args: SelectSubset<T, UsageRecordDeleteArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsageRecord.
     * @param {UsageRecordUpdateArgs} args - Arguments to update one UsageRecord.
     * @example
     * // Update one UsageRecord
     * const usageRecord = await prisma.usageRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageRecordUpdateArgs>(args: SelectSubset<T, UsageRecordUpdateArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsageRecords.
     * @param {UsageRecordDeleteManyArgs} args - Arguments to filter UsageRecords to delete.
     * @example
     * // Delete a few UsageRecords
     * const { count } = await prisma.usageRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageRecordDeleteManyArgs>(args?: SelectSubset<T, UsageRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageRecords
     * const usageRecord = await prisma.usageRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageRecordUpdateManyArgs>(args: SelectSubset<T, UsageRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageRecords and returns the data updated in the database.
     * @param {UsageRecordUpdateManyAndReturnArgs} args - Arguments to update many UsageRecords.
     * @example
     * // Update many UsageRecords
     * const usageRecord = await prisma.usageRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsageRecords and only return the `id`
     * const usageRecordWithIdOnly = await prisma.usageRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsageRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, UsageRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsageRecord.
     * @param {UsageRecordUpsertArgs} args - Arguments to update or create a UsageRecord.
     * @example
     * // Update or create a UsageRecord
     * const usageRecord = await prisma.usageRecord.upsert({
     *   create: {
     *     // ... data to create a UsageRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageRecord we want to update
     *   }
     * })
     */
    upsert<T extends UsageRecordUpsertArgs>(args: SelectSubset<T, UsageRecordUpsertArgs<ExtArgs>>): Prisma__UsageRecordClient<$Result.GetResult<Prisma.$UsageRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsageRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordCountArgs} args - Arguments to filter UsageRecords to count.
     * @example
     * // Count the number of UsageRecords
     * const count = await prisma.usageRecord.count({
     *   where: {
     *     // ... the filter for the UsageRecords we want to count
     *   }
     * })
    **/
    count<T extends UsageRecordCountArgs>(
      args?: Subset<T, UsageRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageRecordAggregateArgs>(args: Subset<T, UsageRecordAggregateArgs>): Prisma.PrismaPromise<GetUsageRecordAggregateType<T>>

    /**
     * Group by UsageRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageRecordGroupByArgs['orderBy'] }
        : { orderBy?: UsageRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageRecord model
   */
  readonly fields: UsageRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageRecord model
   */
  interface UsageRecordFieldRefs {
    readonly id: FieldRef<"UsageRecord", 'String'>
    readonly organizationId: FieldRef<"UsageRecord", 'String'>
    readonly subscriptionId: FieldRef<"UsageRecord", 'String'>
    readonly resourceType: FieldRef<"UsageRecord", 'String'>
    readonly quantity: FieldRef<"UsageRecord", 'Int'>
    readonly recordedAt: FieldRef<"UsageRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageRecord findUnique
   */
  export type UsageRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord findUniqueOrThrow
   */
  export type UsageRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord findFirst
   */
  export type UsageRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageRecords.
     */
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord findFirstOrThrow
   */
  export type UsageRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageRecords.
     */
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord findMany
   */
  export type UsageRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter, which UsageRecords to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: UsageRecordOrderByWithRelationInput | UsageRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    distinct?: UsageRecordScalarFieldEnum | UsageRecordScalarFieldEnum[]
  }

  /**
   * UsageRecord create
   */
  export type UsageRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageRecord.
     */
    data: XOR<UsageRecordCreateInput, UsageRecordUncheckedCreateInput>
  }

  /**
   * UsageRecord createMany
   */
  export type UsageRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageRecords.
     */
    data: UsageRecordCreateManyInput | UsageRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageRecord createManyAndReturn
   */
  export type UsageRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * The data used to create many UsageRecords.
     */
    data: UsageRecordCreateManyInput | UsageRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageRecord update
   */
  export type UsageRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageRecord.
     */
    data: XOR<UsageRecordUpdateInput, UsageRecordUncheckedUpdateInput>
    /**
     * Choose, which UsageRecord to update.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord updateMany
   */
  export type UsageRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageRecords.
     */
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyInput>
    /**
     * Filter which UsageRecords to update
     */
    where?: UsageRecordWhereInput
    /**
     * Limit how many UsageRecords to update.
     */
    limit?: number
  }

  /**
   * UsageRecord updateManyAndReturn
   */
  export type UsageRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * The data used to update UsageRecords.
     */
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyInput>
    /**
     * Filter which UsageRecords to update
     */
    where?: UsageRecordWhereInput
    /**
     * Limit how many UsageRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageRecord upsert
   */
  export type UsageRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageRecord to update in case it exists.
     */
    where: UsageRecordWhereUniqueInput
    /**
     * In case the UsageRecord found by the `where` argument doesn't exist, create a new UsageRecord with this data.
     */
    create: XOR<UsageRecordCreateInput, UsageRecordUncheckedCreateInput>
    /**
     * In case the UsageRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageRecordUpdateInput, UsageRecordUncheckedUpdateInput>
  }

  /**
   * UsageRecord delete
   */
  export type UsageRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
    /**
     * Filter which UsageRecord to delete.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord deleteMany
   */
  export type UsageRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageRecords to delete
     */
    where?: UsageRecordWhereInput
    /**
     * Limit how many UsageRecords to delete.
     */
    limit?: number
  }

  /**
   * UsageRecord without action
   */
  export type UsageRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageRecord
     */
    omit?: UsageRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageRecordInclude<ExtArgs> | null
  }


  /**
   * Model UsageSummary
   */

  export type AggregateUsageSummary = {
    _count: UsageSummaryCountAggregateOutputType | null
    _avg: UsageSummaryAvgAggregateOutputType | null
    _sum: UsageSummarySumAggregateOutputType | null
    _min: UsageSummaryMinAggregateOutputType | null
    _max: UsageSummaryMaxAggregateOutputType | null
  }

  export type UsageSummaryAvgAggregateOutputType = {
    includedQuantity: number | null
    usedQuantity: number | null
    overageQuantity: number | null
    overageUnitPrice: Decimal | null
    overageAmount: Decimal | null
  }

  export type UsageSummarySumAggregateOutputType = {
    includedQuantity: number | null
    usedQuantity: number | null
    overageQuantity: number | null
    overageUnitPrice: Decimal | null
    overageAmount: Decimal | null
  }

  export type UsageSummaryMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    subscriptionId: string | null
    resourceType: string | null
    periodStart: Date | null
    periodEnd: Date | null
    includedQuantity: number | null
    usedQuantity: number | null
    overageQuantity: number | null
    overageUnitPrice: Decimal | null
    overageAmount: Decimal | null
    status: string | null
    stripeUsageRecordId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsageSummaryMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    subscriptionId: string | null
    resourceType: string | null
    periodStart: Date | null
    periodEnd: Date | null
    includedQuantity: number | null
    usedQuantity: number | null
    overageQuantity: number | null
    overageUnitPrice: Decimal | null
    overageAmount: Decimal | null
    status: string | null
    stripeUsageRecordId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsageSummaryCountAggregateOutputType = {
    id: number
    organizationId: number
    subscriptionId: number
    resourceType: number
    periodStart: number
    periodEnd: number
    includedQuantity: number
    usedQuantity: number
    overageQuantity: number
    overageUnitPrice: number
    overageAmount: number
    status: number
    stripeUsageRecordId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsageSummaryAvgAggregateInputType = {
    includedQuantity?: true
    usedQuantity?: true
    overageQuantity?: true
    overageUnitPrice?: true
    overageAmount?: true
  }

  export type UsageSummarySumAggregateInputType = {
    includedQuantity?: true
    usedQuantity?: true
    overageQuantity?: true
    overageUnitPrice?: true
    overageAmount?: true
  }

  export type UsageSummaryMinAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    resourceType?: true
    periodStart?: true
    periodEnd?: true
    includedQuantity?: true
    usedQuantity?: true
    overageQuantity?: true
    overageUnitPrice?: true
    overageAmount?: true
    status?: true
    stripeUsageRecordId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsageSummaryMaxAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    resourceType?: true
    periodStart?: true
    periodEnd?: true
    includedQuantity?: true
    usedQuantity?: true
    overageQuantity?: true
    overageUnitPrice?: true
    overageAmount?: true
    status?: true
    stripeUsageRecordId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsageSummaryCountAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    resourceType?: true
    periodStart?: true
    periodEnd?: true
    includedQuantity?: true
    usedQuantity?: true
    overageQuantity?: true
    overageUnitPrice?: true
    overageAmount?: true
    status?: true
    stripeUsageRecordId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsageSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageSummary to aggregate.
     */
    where?: UsageSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageSummaries to fetch.
     */
    orderBy?: UsageSummaryOrderByWithRelationInput | UsageSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageSummaries
    **/
    _count?: true | UsageSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageSummaryMaxAggregateInputType
  }

  export type GetUsageSummaryAggregateType<T extends UsageSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageSummary[P]>
      : GetScalarType<T[P], AggregateUsageSummary[P]>
  }




  export type UsageSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageSummaryWhereInput
    orderBy?: UsageSummaryOrderByWithAggregationInput | UsageSummaryOrderByWithAggregationInput[]
    by: UsageSummaryScalarFieldEnum[] | UsageSummaryScalarFieldEnum
    having?: UsageSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageSummaryCountAggregateInputType | true
    _avg?: UsageSummaryAvgAggregateInputType
    _sum?: UsageSummarySumAggregateInputType
    _min?: UsageSummaryMinAggregateInputType
    _max?: UsageSummaryMaxAggregateInputType
  }

  export type UsageSummaryGroupByOutputType = {
    id: string
    organizationId: string
    subscriptionId: string
    resourceType: string
    periodStart: Date
    periodEnd: Date
    includedQuantity: number
    usedQuantity: number
    overageQuantity: number | null
    overageUnitPrice: Decimal | null
    overageAmount: Decimal
    status: string
    stripeUsageRecordId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UsageSummaryCountAggregateOutputType | null
    _avg: UsageSummaryAvgAggregateOutputType | null
    _sum: UsageSummarySumAggregateOutputType | null
    _min: UsageSummaryMinAggregateOutputType | null
    _max: UsageSummaryMaxAggregateOutputType | null
  }

  type GetUsageSummaryGroupByPayload<T extends UsageSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], UsageSummaryGroupByOutputType[P]>
        }
      >
    >


  export type UsageSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    resourceType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    includedQuantity?: boolean
    usedQuantity?: boolean
    overageQuantity?: boolean
    overageUnitPrice?: boolean
    overageAmount?: boolean
    status?: boolean
    stripeUsageRecordId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageSummary"]>

  export type UsageSummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    resourceType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    includedQuantity?: boolean
    usedQuantity?: boolean
    overageQuantity?: boolean
    overageUnitPrice?: boolean
    overageAmount?: boolean
    status?: boolean
    stripeUsageRecordId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageSummary"]>

  export type UsageSummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    resourceType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    includedQuantity?: boolean
    usedQuantity?: boolean
    overageQuantity?: boolean
    overageUnitPrice?: boolean
    overageAmount?: boolean
    status?: boolean
    stripeUsageRecordId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageSummary"]>

  export type UsageSummarySelectScalar = {
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    resourceType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    includedQuantity?: boolean
    usedQuantity?: boolean
    overageQuantity?: boolean
    overageUnitPrice?: boolean
    overageAmount?: boolean
    status?: boolean
    stripeUsageRecordId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsageSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "subscriptionId" | "resourceType" | "periodStart" | "periodEnd" | "includedQuantity" | "usedQuantity" | "overageQuantity" | "overageUnitPrice" | "overageAmount" | "status" | "stripeUsageRecordId" | "createdAt" | "updatedAt", ExtArgs["result"]["usageSummary"]>
  export type UsageSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type UsageSummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type UsageSummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $UsageSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageSummary"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      subscriptionId: string
      resourceType: string
      periodStart: Date
      periodEnd: Date
      includedQuantity: number
      usedQuantity: number
      overageQuantity: number | null
      overageUnitPrice: Prisma.Decimal | null
      overageAmount: Prisma.Decimal
      status: string
      stripeUsageRecordId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usageSummary"]>
    composites: {}
  }

  type UsageSummaryGetPayload<S extends boolean | null | undefined | UsageSummaryDefaultArgs> = $Result.GetResult<Prisma.$UsageSummaryPayload, S>

  type UsageSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageSummaryCountAggregateInputType | true
    }

  export interface UsageSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageSummary'], meta: { name: 'UsageSummary' } }
    /**
     * Find zero or one UsageSummary that matches the filter.
     * @param {UsageSummaryFindUniqueArgs} args - Arguments to find a UsageSummary
     * @example
     * // Get one UsageSummary
     * const usageSummary = await prisma.usageSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageSummaryFindUniqueArgs>(args: SelectSubset<T, UsageSummaryFindUniqueArgs<ExtArgs>>): Prisma__UsageSummaryClient<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsageSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageSummaryFindUniqueOrThrowArgs} args - Arguments to find a UsageSummary
     * @example
     * // Get one UsageSummary
     * const usageSummary = await prisma.usageSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageSummaryClient<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageSummaryFindFirstArgs} args - Arguments to find a UsageSummary
     * @example
     * // Get one UsageSummary
     * const usageSummary = await prisma.usageSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageSummaryFindFirstArgs>(args?: SelectSubset<T, UsageSummaryFindFirstArgs<ExtArgs>>): Prisma__UsageSummaryClient<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageSummaryFindFirstOrThrowArgs} args - Arguments to find a UsageSummary
     * @example
     * // Get one UsageSummary
     * const usageSummary = await prisma.usageSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageSummaryClient<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsageSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageSummaries
     * const usageSummaries = await prisma.usageSummary.findMany()
     * 
     * // Get first 10 UsageSummaries
     * const usageSummaries = await prisma.usageSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageSummaryWithIdOnly = await prisma.usageSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageSummaryFindManyArgs>(args?: SelectSubset<T, UsageSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsageSummary.
     * @param {UsageSummaryCreateArgs} args - Arguments to create a UsageSummary.
     * @example
     * // Create one UsageSummary
     * const UsageSummary = await prisma.usageSummary.create({
     *   data: {
     *     // ... data to create a UsageSummary
     *   }
     * })
     * 
     */
    create<T extends UsageSummaryCreateArgs>(args: SelectSubset<T, UsageSummaryCreateArgs<ExtArgs>>): Prisma__UsageSummaryClient<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsageSummaries.
     * @param {UsageSummaryCreateManyArgs} args - Arguments to create many UsageSummaries.
     * @example
     * // Create many UsageSummaries
     * const usageSummary = await prisma.usageSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageSummaryCreateManyArgs>(args?: SelectSubset<T, UsageSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageSummaries and returns the data saved in the database.
     * @param {UsageSummaryCreateManyAndReturnArgs} args - Arguments to create many UsageSummaries.
     * @example
     * // Create many UsageSummaries
     * const usageSummary = await prisma.usageSummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageSummaries and only return the `id`
     * const usageSummaryWithIdOnly = await prisma.usageSummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageSummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageSummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsageSummary.
     * @param {UsageSummaryDeleteArgs} args - Arguments to delete one UsageSummary.
     * @example
     * // Delete one UsageSummary
     * const UsageSummary = await prisma.usageSummary.delete({
     *   where: {
     *     // ... filter to delete one UsageSummary
     *   }
     * })
     * 
     */
    delete<T extends UsageSummaryDeleteArgs>(args: SelectSubset<T, UsageSummaryDeleteArgs<ExtArgs>>): Prisma__UsageSummaryClient<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsageSummary.
     * @param {UsageSummaryUpdateArgs} args - Arguments to update one UsageSummary.
     * @example
     * // Update one UsageSummary
     * const usageSummary = await prisma.usageSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageSummaryUpdateArgs>(args: SelectSubset<T, UsageSummaryUpdateArgs<ExtArgs>>): Prisma__UsageSummaryClient<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsageSummaries.
     * @param {UsageSummaryDeleteManyArgs} args - Arguments to filter UsageSummaries to delete.
     * @example
     * // Delete a few UsageSummaries
     * const { count } = await prisma.usageSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageSummaryDeleteManyArgs>(args?: SelectSubset<T, UsageSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageSummaries
     * const usageSummary = await prisma.usageSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageSummaryUpdateManyArgs>(args: SelectSubset<T, UsageSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageSummaries and returns the data updated in the database.
     * @param {UsageSummaryUpdateManyAndReturnArgs} args - Arguments to update many UsageSummaries.
     * @example
     * // Update many UsageSummaries
     * const usageSummary = await prisma.usageSummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsageSummaries and only return the `id`
     * const usageSummaryWithIdOnly = await prisma.usageSummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsageSummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, UsageSummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsageSummary.
     * @param {UsageSummaryUpsertArgs} args - Arguments to update or create a UsageSummary.
     * @example
     * // Update or create a UsageSummary
     * const usageSummary = await prisma.usageSummary.upsert({
     *   create: {
     *     // ... data to create a UsageSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageSummary we want to update
     *   }
     * })
     */
    upsert<T extends UsageSummaryUpsertArgs>(args: SelectSubset<T, UsageSummaryUpsertArgs<ExtArgs>>): Prisma__UsageSummaryClient<$Result.GetResult<Prisma.$UsageSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsageSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageSummaryCountArgs} args - Arguments to filter UsageSummaries to count.
     * @example
     * // Count the number of UsageSummaries
     * const count = await prisma.usageSummary.count({
     *   where: {
     *     // ... the filter for the UsageSummaries we want to count
     *   }
     * })
    **/
    count<T extends UsageSummaryCountArgs>(
      args?: Subset<T, UsageSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageSummaryAggregateArgs>(args: Subset<T, UsageSummaryAggregateArgs>): Prisma.PrismaPromise<GetUsageSummaryAggregateType<T>>

    /**
     * Group by UsageSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageSummaryGroupByArgs['orderBy'] }
        : { orderBy?: UsageSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageSummary model
   */
  readonly fields: UsageSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageSummary model
   */
  interface UsageSummaryFieldRefs {
    readonly id: FieldRef<"UsageSummary", 'String'>
    readonly organizationId: FieldRef<"UsageSummary", 'String'>
    readonly subscriptionId: FieldRef<"UsageSummary", 'String'>
    readonly resourceType: FieldRef<"UsageSummary", 'String'>
    readonly periodStart: FieldRef<"UsageSummary", 'DateTime'>
    readonly periodEnd: FieldRef<"UsageSummary", 'DateTime'>
    readonly includedQuantity: FieldRef<"UsageSummary", 'Int'>
    readonly usedQuantity: FieldRef<"UsageSummary", 'Int'>
    readonly overageQuantity: FieldRef<"UsageSummary", 'Int'>
    readonly overageUnitPrice: FieldRef<"UsageSummary", 'Decimal'>
    readonly overageAmount: FieldRef<"UsageSummary", 'Decimal'>
    readonly status: FieldRef<"UsageSummary", 'String'>
    readonly stripeUsageRecordId: FieldRef<"UsageSummary", 'String'>
    readonly createdAt: FieldRef<"UsageSummary", 'DateTime'>
    readonly updatedAt: FieldRef<"UsageSummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageSummary findUnique
   */
  export type UsageSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryInclude<ExtArgs> | null
    /**
     * Filter, which UsageSummary to fetch.
     */
    where: UsageSummaryWhereUniqueInput
  }

  /**
   * UsageSummary findUniqueOrThrow
   */
  export type UsageSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryInclude<ExtArgs> | null
    /**
     * Filter, which UsageSummary to fetch.
     */
    where: UsageSummaryWhereUniqueInput
  }

  /**
   * UsageSummary findFirst
   */
  export type UsageSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryInclude<ExtArgs> | null
    /**
     * Filter, which UsageSummary to fetch.
     */
    where?: UsageSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageSummaries to fetch.
     */
    orderBy?: UsageSummaryOrderByWithRelationInput | UsageSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageSummaries.
     */
    cursor?: UsageSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageSummaries.
     */
    distinct?: UsageSummaryScalarFieldEnum | UsageSummaryScalarFieldEnum[]
  }

  /**
   * UsageSummary findFirstOrThrow
   */
  export type UsageSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryInclude<ExtArgs> | null
    /**
     * Filter, which UsageSummary to fetch.
     */
    where?: UsageSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageSummaries to fetch.
     */
    orderBy?: UsageSummaryOrderByWithRelationInput | UsageSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageSummaries.
     */
    cursor?: UsageSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageSummaries.
     */
    distinct?: UsageSummaryScalarFieldEnum | UsageSummaryScalarFieldEnum[]
  }

  /**
   * UsageSummary findMany
   */
  export type UsageSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryInclude<ExtArgs> | null
    /**
     * Filter, which UsageSummaries to fetch.
     */
    where?: UsageSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageSummaries to fetch.
     */
    orderBy?: UsageSummaryOrderByWithRelationInput | UsageSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageSummaries.
     */
    cursor?: UsageSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageSummaries.
     */
    skip?: number
    distinct?: UsageSummaryScalarFieldEnum | UsageSummaryScalarFieldEnum[]
  }

  /**
   * UsageSummary create
   */
  export type UsageSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageSummary.
     */
    data: XOR<UsageSummaryCreateInput, UsageSummaryUncheckedCreateInput>
  }

  /**
   * UsageSummary createMany
   */
  export type UsageSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageSummaries.
     */
    data: UsageSummaryCreateManyInput | UsageSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageSummary createManyAndReturn
   */
  export type UsageSummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * The data used to create many UsageSummaries.
     */
    data: UsageSummaryCreateManyInput | UsageSummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageSummary update
   */
  export type UsageSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageSummary.
     */
    data: XOR<UsageSummaryUpdateInput, UsageSummaryUncheckedUpdateInput>
    /**
     * Choose, which UsageSummary to update.
     */
    where: UsageSummaryWhereUniqueInput
  }

  /**
   * UsageSummary updateMany
   */
  export type UsageSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageSummaries.
     */
    data: XOR<UsageSummaryUpdateManyMutationInput, UsageSummaryUncheckedUpdateManyInput>
    /**
     * Filter which UsageSummaries to update
     */
    where?: UsageSummaryWhereInput
    /**
     * Limit how many UsageSummaries to update.
     */
    limit?: number
  }

  /**
   * UsageSummary updateManyAndReturn
   */
  export type UsageSummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * The data used to update UsageSummaries.
     */
    data: XOR<UsageSummaryUpdateManyMutationInput, UsageSummaryUncheckedUpdateManyInput>
    /**
     * Filter which UsageSummaries to update
     */
    where?: UsageSummaryWhereInput
    /**
     * Limit how many UsageSummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageSummary upsert
   */
  export type UsageSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageSummary to update in case it exists.
     */
    where: UsageSummaryWhereUniqueInput
    /**
     * In case the UsageSummary found by the `where` argument doesn't exist, create a new UsageSummary with this data.
     */
    create: XOR<UsageSummaryCreateInput, UsageSummaryUncheckedCreateInput>
    /**
     * In case the UsageSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageSummaryUpdateInput, UsageSummaryUncheckedUpdateInput>
  }

  /**
   * UsageSummary delete
   */
  export type UsageSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryInclude<ExtArgs> | null
    /**
     * Filter which UsageSummary to delete.
     */
    where: UsageSummaryWhereUniqueInput
  }

  /**
   * UsageSummary deleteMany
   */
  export type UsageSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageSummaries to delete
     */
    where?: UsageSummaryWhereInput
    /**
     * Limit how many UsageSummaries to delete.
     */
    limit?: number
  }

  /**
   * UsageSummary without action
   */
  export type UsageSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageSummary
     */
    select?: UsageSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageSummary
     */
    omit?: UsageSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageSummaryInclude<ExtArgs> | null
  }


  /**
   * Model BillingContact
   */

  export type AggregateBillingContact = {
    _count: BillingContactCountAggregateOutputType | null
    _min: BillingContactMinAggregateOutputType | null
    _max: BillingContactMaxAggregateOutputType | null
  }

  export type BillingContactMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    email: string | null
    name: string | null
    phone: string | null
    companyName: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    vatNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingContactMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    email: string | null
    name: string | null
    phone: string | null
    companyName: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    vatNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingContactCountAggregateOutputType = {
    id: number
    organizationId: number
    email: number
    name: number
    phone: number
    companyName: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    postalCode: number
    country: number
    vatNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillingContactMinAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    name?: true
    phone?: true
    companyName?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    vatNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingContactMaxAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    name?: true
    phone?: true
    companyName?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    vatNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingContactCountAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    name?: true
    phone?: true
    companyName?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    vatNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillingContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingContact to aggregate.
     */
    where?: BillingContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingContacts to fetch.
     */
    orderBy?: BillingContactOrderByWithRelationInput | BillingContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingContacts
    **/
    _count?: true | BillingContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingContactMaxAggregateInputType
  }

  export type GetBillingContactAggregateType<T extends BillingContactAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingContact[P]>
      : GetScalarType<T[P], AggregateBillingContact[P]>
  }




  export type BillingContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingContactWhereInput
    orderBy?: BillingContactOrderByWithAggregationInput | BillingContactOrderByWithAggregationInput[]
    by: BillingContactScalarFieldEnum[] | BillingContactScalarFieldEnum
    having?: BillingContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingContactCountAggregateInputType | true
    _min?: BillingContactMinAggregateInputType
    _max?: BillingContactMaxAggregateInputType
  }

  export type BillingContactGroupByOutputType = {
    id: string
    organizationId: string
    email: string
    name: string | null
    phone: string | null
    companyName: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    vatNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: BillingContactCountAggregateOutputType | null
    _min: BillingContactMinAggregateOutputType | null
    _max: BillingContactMaxAggregateOutputType | null
  }

  type GetBillingContactGroupByPayload<T extends BillingContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingContactGroupByOutputType[P]>
            : GetScalarType<T[P], BillingContactGroupByOutputType[P]>
        }
      >
    >


  export type BillingContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    companyName?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    vatNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingContact"]>

  export type BillingContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    companyName?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    vatNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingContact"]>

  export type BillingContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    companyName?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    vatNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingContact"]>

  export type BillingContactSelectScalar = {
    id?: boolean
    organizationId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    companyName?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    vatNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillingContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "email" | "name" | "phone" | "companyName" | "addressLine1" | "addressLine2" | "city" | "state" | "postalCode" | "country" | "vatNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["billingContact"]>

  export type $BillingContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingContact"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      email: string
      name: string | null
      phone: string | null
      companyName: string | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
      vatNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billingContact"]>
    composites: {}
  }

  type BillingContactGetPayload<S extends boolean | null | undefined | BillingContactDefaultArgs> = $Result.GetResult<Prisma.$BillingContactPayload, S>

  type BillingContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingContactCountAggregateInputType | true
    }

  export interface BillingContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingContact'], meta: { name: 'BillingContact' } }
    /**
     * Find zero or one BillingContact that matches the filter.
     * @param {BillingContactFindUniqueArgs} args - Arguments to find a BillingContact
     * @example
     * // Get one BillingContact
     * const billingContact = await prisma.billingContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingContactFindUniqueArgs>(args: SelectSubset<T, BillingContactFindUniqueArgs<ExtArgs>>): Prisma__BillingContactClient<$Result.GetResult<Prisma.$BillingContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingContactFindUniqueOrThrowArgs} args - Arguments to find a BillingContact
     * @example
     * // Get one BillingContact
     * const billingContact = await prisma.billingContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingContactFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingContactClient<$Result.GetResult<Prisma.$BillingContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingContactFindFirstArgs} args - Arguments to find a BillingContact
     * @example
     * // Get one BillingContact
     * const billingContact = await prisma.billingContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingContactFindFirstArgs>(args?: SelectSubset<T, BillingContactFindFirstArgs<ExtArgs>>): Prisma__BillingContactClient<$Result.GetResult<Prisma.$BillingContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingContactFindFirstOrThrowArgs} args - Arguments to find a BillingContact
     * @example
     * // Get one BillingContact
     * const billingContact = await prisma.billingContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingContactFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingContactClient<$Result.GetResult<Prisma.$BillingContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingContacts
     * const billingContacts = await prisma.billingContact.findMany()
     * 
     * // Get first 10 BillingContacts
     * const billingContacts = await prisma.billingContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingContactWithIdOnly = await prisma.billingContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingContactFindManyArgs>(args?: SelectSubset<T, BillingContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingContact.
     * @param {BillingContactCreateArgs} args - Arguments to create a BillingContact.
     * @example
     * // Create one BillingContact
     * const BillingContact = await prisma.billingContact.create({
     *   data: {
     *     // ... data to create a BillingContact
     *   }
     * })
     * 
     */
    create<T extends BillingContactCreateArgs>(args: SelectSubset<T, BillingContactCreateArgs<ExtArgs>>): Prisma__BillingContactClient<$Result.GetResult<Prisma.$BillingContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingContacts.
     * @param {BillingContactCreateManyArgs} args - Arguments to create many BillingContacts.
     * @example
     * // Create many BillingContacts
     * const billingContact = await prisma.billingContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingContactCreateManyArgs>(args?: SelectSubset<T, BillingContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingContacts and returns the data saved in the database.
     * @param {BillingContactCreateManyAndReturnArgs} args - Arguments to create many BillingContacts.
     * @example
     * // Create many BillingContacts
     * const billingContact = await prisma.billingContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingContacts and only return the `id`
     * const billingContactWithIdOnly = await prisma.billingContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingContactCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingContact.
     * @param {BillingContactDeleteArgs} args - Arguments to delete one BillingContact.
     * @example
     * // Delete one BillingContact
     * const BillingContact = await prisma.billingContact.delete({
     *   where: {
     *     // ... filter to delete one BillingContact
     *   }
     * })
     * 
     */
    delete<T extends BillingContactDeleteArgs>(args: SelectSubset<T, BillingContactDeleteArgs<ExtArgs>>): Prisma__BillingContactClient<$Result.GetResult<Prisma.$BillingContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingContact.
     * @param {BillingContactUpdateArgs} args - Arguments to update one BillingContact.
     * @example
     * // Update one BillingContact
     * const billingContact = await prisma.billingContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingContactUpdateArgs>(args: SelectSubset<T, BillingContactUpdateArgs<ExtArgs>>): Prisma__BillingContactClient<$Result.GetResult<Prisma.$BillingContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingContacts.
     * @param {BillingContactDeleteManyArgs} args - Arguments to filter BillingContacts to delete.
     * @example
     * // Delete a few BillingContacts
     * const { count } = await prisma.billingContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingContactDeleteManyArgs>(args?: SelectSubset<T, BillingContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingContacts
     * const billingContact = await prisma.billingContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingContactUpdateManyArgs>(args: SelectSubset<T, BillingContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingContacts and returns the data updated in the database.
     * @param {BillingContactUpdateManyAndReturnArgs} args - Arguments to update many BillingContacts.
     * @example
     * // Update many BillingContacts
     * const billingContact = await prisma.billingContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingContacts and only return the `id`
     * const billingContactWithIdOnly = await prisma.billingContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingContactUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingContact.
     * @param {BillingContactUpsertArgs} args - Arguments to update or create a BillingContact.
     * @example
     * // Update or create a BillingContact
     * const billingContact = await prisma.billingContact.upsert({
     *   create: {
     *     // ... data to create a BillingContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingContact we want to update
     *   }
     * })
     */
    upsert<T extends BillingContactUpsertArgs>(args: SelectSubset<T, BillingContactUpsertArgs<ExtArgs>>): Prisma__BillingContactClient<$Result.GetResult<Prisma.$BillingContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingContactCountArgs} args - Arguments to filter BillingContacts to count.
     * @example
     * // Count the number of BillingContacts
     * const count = await prisma.billingContact.count({
     *   where: {
     *     // ... the filter for the BillingContacts we want to count
     *   }
     * })
    **/
    count<T extends BillingContactCountArgs>(
      args?: Subset<T, BillingContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingContactAggregateArgs>(args: Subset<T, BillingContactAggregateArgs>): Prisma.PrismaPromise<GetBillingContactAggregateType<T>>

    /**
     * Group by BillingContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingContactGroupByArgs['orderBy'] }
        : { orderBy?: BillingContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingContact model
   */
  readonly fields: BillingContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingContact model
   */
  interface BillingContactFieldRefs {
    readonly id: FieldRef<"BillingContact", 'String'>
    readonly organizationId: FieldRef<"BillingContact", 'String'>
    readonly email: FieldRef<"BillingContact", 'String'>
    readonly name: FieldRef<"BillingContact", 'String'>
    readonly phone: FieldRef<"BillingContact", 'String'>
    readonly companyName: FieldRef<"BillingContact", 'String'>
    readonly addressLine1: FieldRef<"BillingContact", 'String'>
    readonly addressLine2: FieldRef<"BillingContact", 'String'>
    readonly city: FieldRef<"BillingContact", 'String'>
    readonly state: FieldRef<"BillingContact", 'String'>
    readonly postalCode: FieldRef<"BillingContact", 'String'>
    readonly country: FieldRef<"BillingContact", 'String'>
    readonly vatNumber: FieldRef<"BillingContact", 'String'>
    readonly createdAt: FieldRef<"BillingContact", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingContact findUnique
   */
  export type BillingContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
    /**
     * Filter, which BillingContact to fetch.
     */
    where: BillingContactWhereUniqueInput
  }

  /**
   * BillingContact findUniqueOrThrow
   */
  export type BillingContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
    /**
     * Filter, which BillingContact to fetch.
     */
    where: BillingContactWhereUniqueInput
  }

  /**
   * BillingContact findFirst
   */
  export type BillingContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
    /**
     * Filter, which BillingContact to fetch.
     */
    where?: BillingContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingContacts to fetch.
     */
    orderBy?: BillingContactOrderByWithRelationInput | BillingContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingContacts.
     */
    cursor?: BillingContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingContacts.
     */
    distinct?: BillingContactScalarFieldEnum | BillingContactScalarFieldEnum[]
  }

  /**
   * BillingContact findFirstOrThrow
   */
  export type BillingContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
    /**
     * Filter, which BillingContact to fetch.
     */
    where?: BillingContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingContacts to fetch.
     */
    orderBy?: BillingContactOrderByWithRelationInput | BillingContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingContacts.
     */
    cursor?: BillingContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingContacts.
     */
    distinct?: BillingContactScalarFieldEnum | BillingContactScalarFieldEnum[]
  }

  /**
   * BillingContact findMany
   */
  export type BillingContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
    /**
     * Filter, which BillingContacts to fetch.
     */
    where?: BillingContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingContacts to fetch.
     */
    orderBy?: BillingContactOrderByWithRelationInput | BillingContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingContacts.
     */
    cursor?: BillingContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingContacts.
     */
    skip?: number
    distinct?: BillingContactScalarFieldEnum | BillingContactScalarFieldEnum[]
  }

  /**
   * BillingContact create
   */
  export type BillingContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
    /**
     * The data needed to create a BillingContact.
     */
    data: XOR<BillingContactCreateInput, BillingContactUncheckedCreateInput>
  }

  /**
   * BillingContact createMany
   */
  export type BillingContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingContacts.
     */
    data: BillingContactCreateManyInput | BillingContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingContact createManyAndReturn
   */
  export type BillingContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
    /**
     * The data used to create many BillingContacts.
     */
    data: BillingContactCreateManyInput | BillingContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingContact update
   */
  export type BillingContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
    /**
     * The data needed to update a BillingContact.
     */
    data: XOR<BillingContactUpdateInput, BillingContactUncheckedUpdateInput>
    /**
     * Choose, which BillingContact to update.
     */
    where: BillingContactWhereUniqueInput
  }

  /**
   * BillingContact updateMany
   */
  export type BillingContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingContacts.
     */
    data: XOR<BillingContactUpdateManyMutationInput, BillingContactUncheckedUpdateManyInput>
    /**
     * Filter which BillingContacts to update
     */
    where?: BillingContactWhereInput
    /**
     * Limit how many BillingContacts to update.
     */
    limit?: number
  }

  /**
   * BillingContact updateManyAndReturn
   */
  export type BillingContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
    /**
     * The data used to update BillingContacts.
     */
    data: XOR<BillingContactUpdateManyMutationInput, BillingContactUncheckedUpdateManyInput>
    /**
     * Filter which BillingContacts to update
     */
    where?: BillingContactWhereInput
    /**
     * Limit how many BillingContacts to update.
     */
    limit?: number
  }

  /**
   * BillingContact upsert
   */
  export type BillingContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
    /**
     * The filter to search for the BillingContact to update in case it exists.
     */
    where: BillingContactWhereUniqueInput
    /**
     * In case the BillingContact found by the `where` argument doesn't exist, create a new BillingContact with this data.
     */
    create: XOR<BillingContactCreateInput, BillingContactUncheckedCreateInput>
    /**
     * In case the BillingContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingContactUpdateInput, BillingContactUncheckedUpdateInput>
  }

  /**
   * BillingContact delete
   */
  export type BillingContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
    /**
     * Filter which BillingContact to delete.
     */
    where: BillingContactWhereUniqueInput
  }

  /**
   * BillingContact deleteMany
   */
  export type BillingContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingContacts to delete
     */
    where?: BillingContactWhereInput
    /**
     * Limit how many BillingContacts to delete.
     */
    limit?: number
  }

  /**
   * BillingContact without action
   */
  export type BillingContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingContact
     */
    select?: BillingContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingContact
     */
    omit?: BillingContactOmit<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    discountValue: Decimal | null
    durationMonths: number | null
    maxRedemptions: number | null
    redemptionCount: number | null
  }

  export type PromotionSumAggregateOutputType = {
    discountValue: Decimal | null
    durationMonths: number | null
    maxRedemptions: number | null
    redemptionCount: number | null
  }

  export type PromotionMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discountType: string | null
    discountValue: Decimal | null
    duration: string | null
    durationMonths: number | null
    maxRedemptions: number | null
    redemptionCount: number | null
    validFrom: Date | null
    validUntil: Date | null
    stripePromotionCodeId: string | null
    stripeCouponId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discountType: string | null
    discountValue: Decimal | null
    duration: string | null
    durationMonths: number | null
    maxRedemptions: number | null
    redemptionCount: number | null
    validFrom: Date | null
    validUntil: Date | null
    stripePromotionCodeId: string | null
    stripeCouponId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    code: number
    description: number
    discountType: number
    discountValue: number
    duration: number
    durationMonths: number
    maxRedemptions: number
    redemptionCount: number
    validFrom: number
    validUntil: number
    stripePromotionCodeId: number
    stripeCouponId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    discountValue?: true
    durationMonths?: true
    maxRedemptions?: true
    redemptionCount?: true
  }

  export type PromotionSumAggregateInputType = {
    discountValue?: true
    durationMonths?: true
    maxRedemptions?: true
    redemptionCount?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    duration?: true
    durationMonths?: true
    maxRedemptions?: true
    redemptionCount?: true
    validFrom?: true
    validUntil?: true
    stripePromotionCodeId?: true
    stripeCouponId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    duration?: true
    durationMonths?: true
    maxRedemptions?: true
    redemptionCount?: true
    validFrom?: true
    validUntil?: true
    stripePromotionCodeId?: true
    stripeCouponId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    duration?: true
    durationMonths?: true
    maxRedemptions?: true
    redemptionCount?: true
    validFrom?: true
    validUntil?: true
    stripePromotionCodeId?: true
    stripeCouponId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: string
    code: string
    description: string | null
    discountType: string
    discountValue: Decimal
    duration: string
    durationMonths: number | null
    maxRedemptions: number | null
    redemptionCount: number
    validFrom: Date
    validUntil: Date | null
    stripePromotionCodeId: string | null
    stripeCouponId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    duration?: boolean
    durationMonths?: boolean
    maxRedemptions?: boolean
    redemptionCount?: boolean
    validFrom?: boolean
    validUntil?: boolean
    stripePromotionCodeId?: boolean
    stripeCouponId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    redemptions?: boolean | Promotion$redemptionsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    duration?: boolean
    durationMonths?: boolean
    maxRedemptions?: boolean
    redemptionCount?: boolean
    validFrom?: boolean
    validUntil?: boolean
    stripePromotionCodeId?: boolean
    stripeCouponId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    duration?: boolean
    durationMonths?: boolean
    maxRedemptions?: boolean
    redemptionCount?: boolean
    validFrom?: boolean
    validUntil?: boolean
    stripePromotionCodeId?: boolean
    stripeCouponId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    duration?: boolean
    durationMonths?: boolean
    maxRedemptions?: boolean
    redemptionCount?: boolean
    validFrom?: boolean
    validUntil?: boolean
    stripePromotionCodeId?: boolean
    stripeCouponId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "discountType" | "discountValue" | "duration" | "durationMonths" | "maxRedemptions" | "redemptionCount" | "validFrom" | "validUntil" | "stripePromotionCodeId" | "stripeCouponId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["promotion"]>
  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemptions?: boolean | Promotion$redemptionsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PromotionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      redemptions: Prisma.$PromotionRedemptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      discountType: string
      discountValue: Prisma.Decimal
      duration: string
      durationMonths: number | null
      maxRedemptions: number | null
      redemptionCount: number
      validFrom: Date
      validUntil: Date | null
      stripePromotionCodeId: string | null
      stripeCouponId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promotions and returns the data saved in the database.
     * @param {PromotionCreateManyAndReturnArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions and returns the data updated in the database.
     * @param {PromotionUpdateManyAndReturnArgs} args - Arguments to update many Promotions.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    redemptions<T extends Promotion$redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'String'>
    readonly code: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly discountType: FieldRef<"Promotion", 'String'>
    readonly discountValue: FieldRef<"Promotion", 'Decimal'>
    readonly duration: FieldRef<"Promotion", 'String'>
    readonly durationMonths: FieldRef<"Promotion", 'Int'>
    readonly maxRedemptions: FieldRef<"Promotion", 'Int'>
    readonly redemptionCount: FieldRef<"Promotion", 'Int'>
    readonly validFrom: FieldRef<"Promotion", 'DateTime'>
    readonly validUntil: FieldRef<"Promotion", 'DateTime'>
    readonly stripePromotionCodeId: FieldRef<"Promotion", 'String'>
    readonly stripeCouponId: FieldRef<"Promotion", 'String'>
    readonly isActive: FieldRef<"Promotion", 'Boolean'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
    readonly updatedAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion createManyAndReturn
   */
  export type PromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion updateManyAndReturn
   */
  export type PromotionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to delete.
     */
    limit?: number
  }

  /**
   * Promotion.redemptions
   */
  export type Promotion$redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    where?: PromotionRedemptionWhereInput
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    cursor?: PromotionRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model PromotionRedemption
   */

  export type AggregatePromotionRedemption = {
    _count: PromotionRedemptionCountAggregateOutputType | null
    _min: PromotionRedemptionMinAggregateOutputType | null
    _max: PromotionRedemptionMaxAggregateOutputType | null
  }

  export type PromotionRedemptionMinAggregateOutputType = {
    id: string | null
    promotionId: string | null
    organizationId: string | null
    subscriptionId: string | null
    appliedAt: Date | null
  }

  export type PromotionRedemptionMaxAggregateOutputType = {
    id: string | null
    promotionId: string | null
    organizationId: string | null
    subscriptionId: string | null
    appliedAt: Date | null
  }

  export type PromotionRedemptionCountAggregateOutputType = {
    id: number
    promotionId: number
    organizationId: number
    subscriptionId: number
    appliedAt: number
    _all: number
  }


  export type PromotionRedemptionMinAggregateInputType = {
    id?: true
    promotionId?: true
    organizationId?: true
    subscriptionId?: true
    appliedAt?: true
  }

  export type PromotionRedemptionMaxAggregateInputType = {
    id?: true
    promotionId?: true
    organizationId?: true
    subscriptionId?: true
    appliedAt?: true
  }

  export type PromotionRedemptionCountAggregateInputType = {
    id?: true
    promotionId?: true
    organizationId?: true
    subscriptionId?: true
    appliedAt?: true
    _all?: true
  }

  export type PromotionRedemptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionRedemption to aggregate.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionRedemptions
    **/
    _count?: true | PromotionRedemptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionRedemptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionRedemptionMaxAggregateInputType
  }

  export type GetPromotionRedemptionAggregateType<T extends PromotionRedemptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionRedemption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionRedemption[P]>
      : GetScalarType<T[P], AggregatePromotionRedemption[P]>
  }




  export type PromotionRedemptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRedemptionWhereInput
    orderBy?: PromotionRedemptionOrderByWithAggregationInput | PromotionRedemptionOrderByWithAggregationInput[]
    by: PromotionRedemptionScalarFieldEnum[] | PromotionRedemptionScalarFieldEnum
    having?: PromotionRedemptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionRedemptionCountAggregateInputType | true
    _min?: PromotionRedemptionMinAggregateInputType
    _max?: PromotionRedemptionMaxAggregateInputType
  }

  export type PromotionRedemptionGroupByOutputType = {
    id: string
    promotionId: string
    organizationId: string
    subscriptionId: string
    appliedAt: Date
    _count: PromotionRedemptionCountAggregateOutputType | null
    _min: PromotionRedemptionMinAggregateOutputType | null
    _max: PromotionRedemptionMaxAggregateOutputType | null
  }

  type GetPromotionRedemptionGroupByPayload<T extends PromotionRedemptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionRedemptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionRedemptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionRedemptionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionRedemptionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionRedemptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    appliedAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRedemption"]>

  export type PromotionRedemptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    appliedAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRedemption"]>

  export type PromotionRedemptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    appliedAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRedemption"]>

  export type PromotionRedemptionSelectScalar = {
    id?: boolean
    promotionId?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    appliedAt?: boolean
  }

  export type PromotionRedemptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promotionId" | "organizationId" | "subscriptionId" | "appliedAt", ExtArgs["result"]["promotionRedemption"]>
  export type PromotionRedemptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PromotionRedemptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PromotionRedemptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $PromotionRedemptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromotionRedemption"
    objects: {
      promotion: Prisma.$PromotionPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promotionId: string
      organizationId: string
      subscriptionId: string
      appliedAt: Date
    }, ExtArgs["result"]["promotionRedemption"]>
    composites: {}
  }

  type PromotionRedemptionGetPayload<S extends boolean | null | undefined | PromotionRedemptionDefaultArgs> = $Result.GetResult<Prisma.$PromotionRedemptionPayload, S>

  type PromotionRedemptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionRedemptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionRedemptionCountAggregateInputType | true
    }

  export interface PromotionRedemptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionRedemption'], meta: { name: 'PromotionRedemption' } }
    /**
     * Find zero or one PromotionRedemption that matches the filter.
     * @param {PromotionRedemptionFindUniqueArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionRedemptionFindUniqueArgs>(args: SelectSubset<T, PromotionRedemptionFindUniqueArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromotionRedemption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionRedemptionFindUniqueOrThrowArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionRedemptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionRedemptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionRedemption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionFindFirstArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionRedemptionFindFirstArgs>(args?: SelectSubset<T, PromotionRedemptionFindFirstArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionRedemption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionFindFirstOrThrowArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionRedemptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionRedemptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromotionRedemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionRedemptions
     * const promotionRedemptions = await prisma.promotionRedemption.findMany()
     * 
     * // Get first 10 PromotionRedemptions
     * const promotionRedemptions = await prisma.promotionRedemption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionRedemptionWithIdOnly = await prisma.promotionRedemption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionRedemptionFindManyArgs>(args?: SelectSubset<T, PromotionRedemptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromotionRedemption.
     * @param {PromotionRedemptionCreateArgs} args - Arguments to create a PromotionRedemption.
     * @example
     * // Create one PromotionRedemption
     * const PromotionRedemption = await prisma.promotionRedemption.create({
     *   data: {
     *     // ... data to create a PromotionRedemption
     *   }
     * })
     * 
     */
    create<T extends PromotionRedemptionCreateArgs>(args: SelectSubset<T, PromotionRedemptionCreateArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromotionRedemptions.
     * @param {PromotionRedemptionCreateManyArgs} args - Arguments to create many PromotionRedemptions.
     * @example
     * // Create many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionRedemptionCreateManyArgs>(args?: SelectSubset<T, PromotionRedemptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromotionRedemptions and returns the data saved in the database.
     * @param {PromotionRedemptionCreateManyAndReturnArgs} args - Arguments to create many PromotionRedemptions.
     * @example
     * // Create many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromotionRedemptions and only return the `id`
     * const promotionRedemptionWithIdOnly = await prisma.promotionRedemption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionRedemptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionRedemptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromotionRedemption.
     * @param {PromotionRedemptionDeleteArgs} args - Arguments to delete one PromotionRedemption.
     * @example
     * // Delete one PromotionRedemption
     * const PromotionRedemption = await prisma.promotionRedemption.delete({
     *   where: {
     *     // ... filter to delete one PromotionRedemption
     *   }
     * })
     * 
     */
    delete<T extends PromotionRedemptionDeleteArgs>(args: SelectSubset<T, PromotionRedemptionDeleteArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromotionRedemption.
     * @param {PromotionRedemptionUpdateArgs} args - Arguments to update one PromotionRedemption.
     * @example
     * // Update one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionRedemptionUpdateArgs>(args: SelectSubset<T, PromotionRedemptionUpdateArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromotionRedemptions.
     * @param {PromotionRedemptionDeleteManyArgs} args - Arguments to filter PromotionRedemptions to delete.
     * @example
     * // Delete a few PromotionRedemptions
     * const { count } = await prisma.promotionRedemption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionRedemptionDeleteManyArgs>(args?: SelectSubset<T, PromotionRedemptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionRedemptionUpdateManyArgs>(args: SelectSubset<T, PromotionRedemptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionRedemptions and returns the data updated in the database.
     * @param {PromotionRedemptionUpdateManyAndReturnArgs} args - Arguments to update many PromotionRedemptions.
     * @example
     * // Update many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromotionRedemptions and only return the `id`
     * const promotionRedemptionWithIdOnly = await prisma.promotionRedemption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionRedemptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionRedemptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromotionRedemption.
     * @param {PromotionRedemptionUpsertArgs} args - Arguments to update or create a PromotionRedemption.
     * @example
     * // Update or create a PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.upsert({
     *   create: {
     *     // ... data to create a PromotionRedemption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionRedemption we want to update
     *   }
     * })
     */
    upsert<T extends PromotionRedemptionUpsertArgs>(args: SelectSubset<T, PromotionRedemptionUpsertArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromotionRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionCountArgs} args - Arguments to filter PromotionRedemptions to count.
     * @example
     * // Count the number of PromotionRedemptions
     * const count = await prisma.promotionRedemption.count({
     *   where: {
     *     // ... the filter for the PromotionRedemptions we want to count
     *   }
     * })
    **/
    count<T extends PromotionRedemptionCountArgs>(
      args?: Subset<T, PromotionRedemptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionRedemptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionRedemptionAggregateArgs>(args: Subset<T, PromotionRedemptionAggregateArgs>): Prisma.PrismaPromise<GetPromotionRedemptionAggregateType<T>>

    /**
     * Group by PromotionRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionRedemptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionRedemptionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionRedemptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionRedemptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionRedemptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromotionRedemption model
   */
  readonly fields: PromotionRedemptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionRedemption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionRedemptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    promotion<T extends PromotionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromotionDefaultArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromotionRedemption model
   */
  interface PromotionRedemptionFieldRefs {
    readonly id: FieldRef<"PromotionRedemption", 'String'>
    readonly promotionId: FieldRef<"PromotionRedemption", 'String'>
    readonly organizationId: FieldRef<"PromotionRedemption", 'String'>
    readonly subscriptionId: FieldRef<"PromotionRedemption", 'String'>
    readonly appliedAt: FieldRef<"PromotionRedemption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromotionRedemption findUnique
   */
  export type PromotionRedemptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption findUniqueOrThrow
   */
  export type PromotionRedemptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption findFirst
   */
  export type PromotionRedemptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionRedemptions.
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionRedemptions.
     */
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * PromotionRedemption findFirstOrThrow
   */
  export type PromotionRedemptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionRedemptions.
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionRedemptions.
     */
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * PromotionRedemption findMany
   */
  export type PromotionRedemptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemptions to fetch.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionRedemptions.
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * PromotionRedemption create
   */
  export type PromotionRedemptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PromotionRedemption.
     */
    data: XOR<PromotionRedemptionCreateInput, PromotionRedemptionUncheckedCreateInput>
  }

  /**
   * PromotionRedemption createMany
   */
  export type PromotionRedemptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionRedemptions.
     */
    data: PromotionRedemptionCreateManyInput | PromotionRedemptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromotionRedemption createManyAndReturn
   */
  export type PromotionRedemptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * The data used to create many PromotionRedemptions.
     */
    data: PromotionRedemptionCreateManyInput | PromotionRedemptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionRedemption update
   */
  export type PromotionRedemptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PromotionRedemption.
     */
    data: XOR<PromotionRedemptionUpdateInput, PromotionRedemptionUncheckedUpdateInput>
    /**
     * Choose, which PromotionRedemption to update.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption updateMany
   */
  export type PromotionRedemptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionRedemptions.
     */
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which PromotionRedemptions to update
     */
    where?: PromotionRedemptionWhereInput
    /**
     * Limit how many PromotionRedemptions to update.
     */
    limit?: number
  }

  /**
   * PromotionRedemption updateManyAndReturn
   */
  export type PromotionRedemptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * The data used to update PromotionRedemptions.
     */
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which PromotionRedemptions to update
     */
    where?: PromotionRedemptionWhereInput
    /**
     * Limit how many PromotionRedemptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionRedemption upsert
   */
  export type PromotionRedemptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PromotionRedemption to update in case it exists.
     */
    where: PromotionRedemptionWhereUniqueInput
    /**
     * In case the PromotionRedemption found by the `where` argument doesn't exist, create a new PromotionRedemption with this data.
     */
    create: XOR<PromotionRedemptionCreateInput, PromotionRedemptionUncheckedCreateInput>
    /**
     * In case the PromotionRedemption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionRedemptionUpdateInput, PromotionRedemptionUncheckedUpdateInput>
  }

  /**
   * PromotionRedemption delete
   */
  export type PromotionRedemptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter which PromotionRedemption to delete.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption deleteMany
   */
  export type PromotionRedemptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionRedemptions to delete
     */
    where?: PromotionRedemptionWhereInput
    /**
     * Limit how many PromotionRedemptions to delete.
     */
    limit?: number
  }

  /**
   * PromotionRedemption without action
   */
  export type PromotionRedemptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
  }


  /**
   * Model PlanChangeRequest
   */

  export type AggregatePlanChangeRequest = {
    _count: PlanChangeRequestCountAggregateOutputType | null
    _min: PlanChangeRequestMinAggregateOutputType | null
    _max: PlanChangeRequestMaxAggregateOutputType | null
  }

  export type PlanChangeRequestMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    currentPlanId: string | null
    requestedPlanId: string | null
    changeType: string | null
    requestedBy: string | null
    reason: string | null
    status: string | null
    processedBy: string | null
    processedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanChangeRequestMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    currentPlanId: string | null
    requestedPlanId: string | null
    changeType: string | null
    requestedBy: string | null
    reason: string | null
    status: string | null
    processedBy: string | null
    processedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanChangeRequestCountAggregateOutputType = {
    id: number
    organizationId: number
    currentPlanId: number
    requestedPlanId: number
    changeType: number
    requestedBy: number
    reason: number
    status: number
    processedBy: number
    processedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanChangeRequestMinAggregateInputType = {
    id?: true
    organizationId?: true
    currentPlanId?: true
    requestedPlanId?: true
    changeType?: true
    requestedBy?: true
    reason?: true
    status?: true
    processedBy?: true
    processedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanChangeRequestMaxAggregateInputType = {
    id?: true
    organizationId?: true
    currentPlanId?: true
    requestedPlanId?: true
    changeType?: true
    requestedBy?: true
    reason?: true
    status?: true
    processedBy?: true
    processedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanChangeRequestCountAggregateInputType = {
    id?: true
    organizationId?: true
    currentPlanId?: true
    requestedPlanId?: true
    changeType?: true
    requestedBy?: true
    reason?: true
    status?: true
    processedBy?: true
    processedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanChangeRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanChangeRequest to aggregate.
     */
    where?: PlanChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanChangeRequests to fetch.
     */
    orderBy?: PlanChangeRequestOrderByWithRelationInput | PlanChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanChangeRequests
    **/
    _count?: true | PlanChangeRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanChangeRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanChangeRequestMaxAggregateInputType
  }

  export type GetPlanChangeRequestAggregateType<T extends PlanChangeRequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanChangeRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanChangeRequest[P]>
      : GetScalarType<T[P], AggregatePlanChangeRequest[P]>
  }




  export type PlanChangeRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanChangeRequestWhereInput
    orderBy?: PlanChangeRequestOrderByWithAggregationInput | PlanChangeRequestOrderByWithAggregationInput[]
    by: PlanChangeRequestScalarFieldEnum[] | PlanChangeRequestScalarFieldEnum
    having?: PlanChangeRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanChangeRequestCountAggregateInputType | true
    _min?: PlanChangeRequestMinAggregateInputType
    _max?: PlanChangeRequestMaxAggregateInputType
  }

  export type PlanChangeRequestGroupByOutputType = {
    id: string
    organizationId: string
    currentPlanId: string
    requestedPlanId: string
    changeType: string
    requestedBy: string
    reason: string | null
    status: string
    processedBy: string | null
    processedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlanChangeRequestCountAggregateOutputType | null
    _min: PlanChangeRequestMinAggregateOutputType | null
    _max: PlanChangeRequestMaxAggregateOutputType | null
  }

  type GetPlanChangeRequestGroupByPayload<T extends PlanChangeRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanChangeRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanChangeRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanChangeRequestGroupByOutputType[P]>
            : GetScalarType<T[P], PlanChangeRequestGroupByOutputType[P]>
        }
      >
    >


  export type PlanChangeRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    currentPlanId?: boolean
    requestedPlanId?: boolean
    changeType?: boolean
    requestedBy?: boolean
    reason?: boolean
    status?: boolean
    processedBy?: boolean
    processedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentPlan?: boolean | PlanDefaultArgs<ExtArgs>
    requestedPlan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planChangeRequest"]>

  export type PlanChangeRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    currentPlanId?: boolean
    requestedPlanId?: boolean
    changeType?: boolean
    requestedBy?: boolean
    reason?: boolean
    status?: boolean
    processedBy?: boolean
    processedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentPlan?: boolean | PlanDefaultArgs<ExtArgs>
    requestedPlan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planChangeRequest"]>

  export type PlanChangeRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    currentPlanId?: boolean
    requestedPlanId?: boolean
    changeType?: boolean
    requestedBy?: boolean
    reason?: boolean
    status?: boolean
    processedBy?: boolean
    processedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentPlan?: boolean | PlanDefaultArgs<ExtArgs>
    requestedPlan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planChangeRequest"]>

  export type PlanChangeRequestSelectScalar = {
    id?: boolean
    organizationId?: boolean
    currentPlanId?: boolean
    requestedPlanId?: boolean
    changeType?: boolean
    requestedBy?: boolean
    reason?: boolean
    status?: boolean
    processedBy?: boolean
    processedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanChangeRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "currentPlanId" | "requestedPlanId" | "changeType" | "requestedBy" | "reason" | "status" | "processedBy" | "processedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["planChangeRequest"]>
  export type PlanChangeRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentPlan?: boolean | PlanDefaultArgs<ExtArgs>
    requestedPlan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanChangeRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentPlan?: boolean | PlanDefaultArgs<ExtArgs>
    requestedPlan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanChangeRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentPlan?: boolean | PlanDefaultArgs<ExtArgs>
    requestedPlan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $PlanChangeRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanChangeRequest"
    objects: {
      currentPlan: Prisma.$PlanPayload<ExtArgs>
      requestedPlan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      currentPlanId: string
      requestedPlanId: string
      changeType: string
      requestedBy: string
      reason: string | null
      status: string
      processedBy: string | null
      processedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planChangeRequest"]>
    composites: {}
  }

  type PlanChangeRequestGetPayload<S extends boolean | null | undefined | PlanChangeRequestDefaultArgs> = $Result.GetResult<Prisma.$PlanChangeRequestPayload, S>

  type PlanChangeRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanChangeRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanChangeRequestCountAggregateInputType | true
    }

  export interface PlanChangeRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanChangeRequest'], meta: { name: 'PlanChangeRequest' } }
    /**
     * Find zero or one PlanChangeRequest that matches the filter.
     * @param {PlanChangeRequestFindUniqueArgs} args - Arguments to find a PlanChangeRequest
     * @example
     * // Get one PlanChangeRequest
     * const planChangeRequest = await prisma.planChangeRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanChangeRequestFindUniqueArgs>(args: SelectSubset<T, PlanChangeRequestFindUniqueArgs<ExtArgs>>): Prisma__PlanChangeRequestClient<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanChangeRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanChangeRequestFindUniqueOrThrowArgs} args - Arguments to find a PlanChangeRequest
     * @example
     * // Get one PlanChangeRequest
     * const planChangeRequest = await prisma.planChangeRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanChangeRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanChangeRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanChangeRequestClient<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanChangeRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanChangeRequestFindFirstArgs} args - Arguments to find a PlanChangeRequest
     * @example
     * // Get one PlanChangeRequest
     * const planChangeRequest = await prisma.planChangeRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanChangeRequestFindFirstArgs>(args?: SelectSubset<T, PlanChangeRequestFindFirstArgs<ExtArgs>>): Prisma__PlanChangeRequestClient<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanChangeRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanChangeRequestFindFirstOrThrowArgs} args - Arguments to find a PlanChangeRequest
     * @example
     * // Get one PlanChangeRequest
     * const planChangeRequest = await prisma.planChangeRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanChangeRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanChangeRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanChangeRequestClient<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanChangeRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanChangeRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanChangeRequests
     * const planChangeRequests = await prisma.planChangeRequest.findMany()
     * 
     * // Get first 10 PlanChangeRequests
     * const planChangeRequests = await prisma.planChangeRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planChangeRequestWithIdOnly = await prisma.planChangeRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanChangeRequestFindManyArgs>(args?: SelectSubset<T, PlanChangeRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanChangeRequest.
     * @param {PlanChangeRequestCreateArgs} args - Arguments to create a PlanChangeRequest.
     * @example
     * // Create one PlanChangeRequest
     * const PlanChangeRequest = await prisma.planChangeRequest.create({
     *   data: {
     *     // ... data to create a PlanChangeRequest
     *   }
     * })
     * 
     */
    create<T extends PlanChangeRequestCreateArgs>(args: SelectSubset<T, PlanChangeRequestCreateArgs<ExtArgs>>): Prisma__PlanChangeRequestClient<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanChangeRequests.
     * @param {PlanChangeRequestCreateManyArgs} args - Arguments to create many PlanChangeRequests.
     * @example
     * // Create many PlanChangeRequests
     * const planChangeRequest = await prisma.planChangeRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanChangeRequestCreateManyArgs>(args?: SelectSubset<T, PlanChangeRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanChangeRequests and returns the data saved in the database.
     * @param {PlanChangeRequestCreateManyAndReturnArgs} args - Arguments to create many PlanChangeRequests.
     * @example
     * // Create many PlanChangeRequests
     * const planChangeRequest = await prisma.planChangeRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanChangeRequests and only return the `id`
     * const planChangeRequestWithIdOnly = await prisma.planChangeRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanChangeRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanChangeRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanChangeRequest.
     * @param {PlanChangeRequestDeleteArgs} args - Arguments to delete one PlanChangeRequest.
     * @example
     * // Delete one PlanChangeRequest
     * const PlanChangeRequest = await prisma.planChangeRequest.delete({
     *   where: {
     *     // ... filter to delete one PlanChangeRequest
     *   }
     * })
     * 
     */
    delete<T extends PlanChangeRequestDeleteArgs>(args: SelectSubset<T, PlanChangeRequestDeleteArgs<ExtArgs>>): Prisma__PlanChangeRequestClient<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanChangeRequest.
     * @param {PlanChangeRequestUpdateArgs} args - Arguments to update one PlanChangeRequest.
     * @example
     * // Update one PlanChangeRequest
     * const planChangeRequest = await prisma.planChangeRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanChangeRequestUpdateArgs>(args: SelectSubset<T, PlanChangeRequestUpdateArgs<ExtArgs>>): Prisma__PlanChangeRequestClient<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanChangeRequests.
     * @param {PlanChangeRequestDeleteManyArgs} args - Arguments to filter PlanChangeRequests to delete.
     * @example
     * // Delete a few PlanChangeRequests
     * const { count } = await prisma.planChangeRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanChangeRequestDeleteManyArgs>(args?: SelectSubset<T, PlanChangeRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanChangeRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanChangeRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanChangeRequests
     * const planChangeRequest = await prisma.planChangeRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanChangeRequestUpdateManyArgs>(args: SelectSubset<T, PlanChangeRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanChangeRequests and returns the data updated in the database.
     * @param {PlanChangeRequestUpdateManyAndReturnArgs} args - Arguments to update many PlanChangeRequests.
     * @example
     * // Update many PlanChangeRequests
     * const planChangeRequest = await prisma.planChangeRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanChangeRequests and only return the `id`
     * const planChangeRequestWithIdOnly = await prisma.planChangeRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanChangeRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanChangeRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanChangeRequest.
     * @param {PlanChangeRequestUpsertArgs} args - Arguments to update or create a PlanChangeRequest.
     * @example
     * // Update or create a PlanChangeRequest
     * const planChangeRequest = await prisma.planChangeRequest.upsert({
     *   create: {
     *     // ... data to create a PlanChangeRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanChangeRequest we want to update
     *   }
     * })
     */
    upsert<T extends PlanChangeRequestUpsertArgs>(args: SelectSubset<T, PlanChangeRequestUpsertArgs<ExtArgs>>): Prisma__PlanChangeRequestClient<$Result.GetResult<Prisma.$PlanChangeRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanChangeRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanChangeRequestCountArgs} args - Arguments to filter PlanChangeRequests to count.
     * @example
     * // Count the number of PlanChangeRequests
     * const count = await prisma.planChangeRequest.count({
     *   where: {
     *     // ... the filter for the PlanChangeRequests we want to count
     *   }
     * })
    **/
    count<T extends PlanChangeRequestCountArgs>(
      args?: Subset<T, PlanChangeRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanChangeRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanChangeRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanChangeRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanChangeRequestAggregateArgs>(args: Subset<T, PlanChangeRequestAggregateArgs>): Prisma.PrismaPromise<GetPlanChangeRequestAggregateType<T>>

    /**
     * Group by PlanChangeRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanChangeRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanChangeRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanChangeRequestGroupByArgs['orderBy'] }
        : { orderBy?: PlanChangeRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanChangeRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanChangeRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanChangeRequest model
   */
  readonly fields: PlanChangeRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanChangeRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanChangeRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currentPlan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requestedPlan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanChangeRequest model
   */
  interface PlanChangeRequestFieldRefs {
    readonly id: FieldRef<"PlanChangeRequest", 'String'>
    readonly organizationId: FieldRef<"PlanChangeRequest", 'String'>
    readonly currentPlanId: FieldRef<"PlanChangeRequest", 'String'>
    readonly requestedPlanId: FieldRef<"PlanChangeRequest", 'String'>
    readonly changeType: FieldRef<"PlanChangeRequest", 'String'>
    readonly requestedBy: FieldRef<"PlanChangeRequest", 'String'>
    readonly reason: FieldRef<"PlanChangeRequest", 'String'>
    readonly status: FieldRef<"PlanChangeRequest", 'String'>
    readonly processedBy: FieldRef<"PlanChangeRequest", 'String'>
    readonly processedAt: FieldRef<"PlanChangeRequest", 'DateTime'>
    readonly notes: FieldRef<"PlanChangeRequest", 'String'>
    readonly createdAt: FieldRef<"PlanChangeRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanChangeRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanChangeRequest findUnique
   */
  export type PlanChangeRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which PlanChangeRequest to fetch.
     */
    where: PlanChangeRequestWhereUniqueInput
  }

  /**
   * PlanChangeRequest findUniqueOrThrow
   */
  export type PlanChangeRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which PlanChangeRequest to fetch.
     */
    where: PlanChangeRequestWhereUniqueInput
  }

  /**
   * PlanChangeRequest findFirst
   */
  export type PlanChangeRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which PlanChangeRequest to fetch.
     */
    where?: PlanChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanChangeRequests to fetch.
     */
    orderBy?: PlanChangeRequestOrderByWithRelationInput | PlanChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanChangeRequests.
     */
    cursor?: PlanChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanChangeRequests.
     */
    distinct?: PlanChangeRequestScalarFieldEnum | PlanChangeRequestScalarFieldEnum[]
  }

  /**
   * PlanChangeRequest findFirstOrThrow
   */
  export type PlanChangeRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which PlanChangeRequest to fetch.
     */
    where?: PlanChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanChangeRequests to fetch.
     */
    orderBy?: PlanChangeRequestOrderByWithRelationInput | PlanChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanChangeRequests.
     */
    cursor?: PlanChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanChangeRequests.
     */
    distinct?: PlanChangeRequestScalarFieldEnum | PlanChangeRequestScalarFieldEnum[]
  }

  /**
   * PlanChangeRequest findMany
   */
  export type PlanChangeRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which PlanChangeRequests to fetch.
     */
    where?: PlanChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanChangeRequests to fetch.
     */
    orderBy?: PlanChangeRequestOrderByWithRelationInput | PlanChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanChangeRequests.
     */
    cursor?: PlanChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanChangeRequests.
     */
    skip?: number
    distinct?: PlanChangeRequestScalarFieldEnum | PlanChangeRequestScalarFieldEnum[]
  }

  /**
   * PlanChangeRequest create
   */
  export type PlanChangeRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanChangeRequest.
     */
    data: XOR<PlanChangeRequestCreateInput, PlanChangeRequestUncheckedCreateInput>
  }

  /**
   * PlanChangeRequest createMany
   */
  export type PlanChangeRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanChangeRequests.
     */
    data: PlanChangeRequestCreateManyInput | PlanChangeRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanChangeRequest createManyAndReturn
   */
  export type PlanChangeRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * The data used to create many PlanChangeRequests.
     */
    data: PlanChangeRequestCreateManyInput | PlanChangeRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanChangeRequest update
   */
  export type PlanChangeRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanChangeRequest.
     */
    data: XOR<PlanChangeRequestUpdateInput, PlanChangeRequestUncheckedUpdateInput>
    /**
     * Choose, which PlanChangeRequest to update.
     */
    where: PlanChangeRequestWhereUniqueInput
  }

  /**
   * PlanChangeRequest updateMany
   */
  export type PlanChangeRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanChangeRequests.
     */
    data: XOR<PlanChangeRequestUpdateManyMutationInput, PlanChangeRequestUncheckedUpdateManyInput>
    /**
     * Filter which PlanChangeRequests to update
     */
    where?: PlanChangeRequestWhereInput
    /**
     * Limit how many PlanChangeRequests to update.
     */
    limit?: number
  }

  /**
   * PlanChangeRequest updateManyAndReturn
   */
  export type PlanChangeRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * The data used to update PlanChangeRequests.
     */
    data: XOR<PlanChangeRequestUpdateManyMutationInput, PlanChangeRequestUncheckedUpdateManyInput>
    /**
     * Filter which PlanChangeRequests to update
     */
    where?: PlanChangeRequestWhereInput
    /**
     * Limit how many PlanChangeRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanChangeRequest upsert
   */
  export type PlanChangeRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanChangeRequest to update in case it exists.
     */
    where: PlanChangeRequestWhereUniqueInput
    /**
     * In case the PlanChangeRequest found by the `where` argument doesn't exist, create a new PlanChangeRequest with this data.
     */
    create: XOR<PlanChangeRequestCreateInput, PlanChangeRequestUncheckedCreateInput>
    /**
     * In case the PlanChangeRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanChangeRequestUpdateInput, PlanChangeRequestUncheckedUpdateInput>
  }

  /**
   * PlanChangeRequest delete
   */
  export type PlanChangeRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
    /**
     * Filter which PlanChangeRequest to delete.
     */
    where: PlanChangeRequestWhereUniqueInput
  }

  /**
   * PlanChangeRequest deleteMany
   */
  export type PlanChangeRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanChangeRequests to delete
     */
    where?: PlanChangeRequestWhereInput
    /**
     * Limit how many PlanChangeRequests to delete.
     */
    limit?: number
  }

  /**
   * PlanChangeRequest without action
   */
  export type PlanChangeRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanChangeRequest
     */
    select?: PlanChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanChangeRequest
     */
    omit?: PlanChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanChangeRequestInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionHistory
   */

  export type AggregateSubscriptionHistory = {
    _count: SubscriptionHistoryCountAggregateOutputType | null
    _min: SubscriptionHistoryMinAggregateOutputType | null
    _max: SubscriptionHistoryMaxAggregateOutputType | null
  }

  export type SubscriptionHistoryMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    subscriptionId: string | null
    previousPlanId: string | null
    newPlanId: string | null
    previousStatus: string | null
    newStatus: string | null
    changeType: string | null
    changeReason: string | null
    changedBy: string | null
    createdAt: Date | null
  }

  export type SubscriptionHistoryMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    subscriptionId: string | null
    previousPlanId: string | null
    newPlanId: string | null
    previousStatus: string | null
    newStatus: string | null
    changeType: string | null
    changeReason: string | null
    changedBy: string | null
    createdAt: Date | null
  }

  export type SubscriptionHistoryCountAggregateOutputType = {
    id: number
    organizationId: number
    subscriptionId: number
    previousPlanId: number
    newPlanId: number
    previousStatus: number
    newStatus: number
    changeType: number
    changeReason: number
    changedBy: number
    createdAt: number
    _all: number
  }


  export type SubscriptionHistoryMinAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    previousPlanId?: true
    newPlanId?: true
    previousStatus?: true
    newStatus?: true
    changeType?: true
    changeReason?: true
    changedBy?: true
    createdAt?: true
  }

  export type SubscriptionHistoryMaxAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    previousPlanId?: true
    newPlanId?: true
    previousStatus?: true
    newStatus?: true
    changeType?: true
    changeReason?: true
    changedBy?: true
    createdAt?: true
  }

  export type SubscriptionHistoryCountAggregateInputType = {
    id?: true
    organizationId?: true
    subscriptionId?: true
    previousPlanId?: true
    newPlanId?: true
    previousStatus?: true
    newStatus?: true
    changeType?: true
    changeReason?: true
    changedBy?: true
    createdAt?: true
    _all?: true
  }

  export type SubscriptionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionHistory to aggregate.
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionHistories to fetch.
     */
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionHistories
    **/
    _count?: true | SubscriptionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionHistoryMaxAggregateInputType
  }

  export type GetSubscriptionHistoryAggregateType<T extends SubscriptionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionHistory[P]>
      : GetScalarType<T[P], AggregateSubscriptionHistory[P]>
  }




  export type SubscriptionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionHistoryWhereInput
    orderBy?: SubscriptionHistoryOrderByWithAggregationInput | SubscriptionHistoryOrderByWithAggregationInput[]
    by: SubscriptionHistoryScalarFieldEnum[] | SubscriptionHistoryScalarFieldEnum
    having?: SubscriptionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionHistoryCountAggregateInputType | true
    _min?: SubscriptionHistoryMinAggregateInputType
    _max?: SubscriptionHistoryMaxAggregateInputType
  }

  export type SubscriptionHistoryGroupByOutputType = {
    id: string
    organizationId: string
    subscriptionId: string
    previousPlanId: string | null
    newPlanId: string | null
    previousStatus: string | null
    newStatus: string | null
    changeType: string
    changeReason: string | null
    changedBy: string | null
    createdAt: Date
    _count: SubscriptionHistoryCountAggregateOutputType | null
    _min: SubscriptionHistoryMinAggregateOutputType | null
    _max: SubscriptionHistoryMaxAggregateOutputType | null
  }

  type GetSubscriptionHistoryGroupByPayload<T extends SubscriptionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    previousPlanId?: boolean
    newPlanId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changeType?: boolean
    changeReason?: boolean
    changedBy?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    previousPlan?: boolean | SubscriptionHistory$previousPlanArgs<ExtArgs>
    newPlan?: boolean | SubscriptionHistory$newPlanArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionHistory"]>

  export type SubscriptionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    previousPlanId?: boolean
    newPlanId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changeType?: boolean
    changeReason?: boolean
    changedBy?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    previousPlan?: boolean | SubscriptionHistory$previousPlanArgs<ExtArgs>
    newPlan?: boolean | SubscriptionHistory$newPlanArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionHistory"]>

  export type SubscriptionHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    previousPlanId?: boolean
    newPlanId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changeType?: boolean
    changeReason?: boolean
    changedBy?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    previousPlan?: boolean | SubscriptionHistory$previousPlanArgs<ExtArgs>
    newPlan?: boolean | SubscriptionHistory$newPlanArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionHistory"]>

  export type SubscriptionHistorySelectScalar = {
    id?: boolean
    organizationId?: boolean
    subscriptionId?: boolean
    previousPlanId?: boolean
    newPlanId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changeType?: boolean
    changeReason?: boolean
    changedBy?: boolean
    createdAt?: boolean
  }

  export type SubscriptionHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "subscriptionId" | "previousPlanId" | "newPlanId" | "previousStatus" | "newStatus" | "changeType" | "changeReason" | "changedBy" | "createdAt", ExtArgs["result"]["subscriptionHistory"]>
  export type SubscriptionHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    previousPlan?: boolean | SubscriptionHistory$previousPlanArgs<ExtArgs>
    newPlan?: boolean | SubscriptionHistory$newPlanArgs<ExtArgs>
  }
  export type SubscriptionHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    previousPlan?: boolean | SubscriptionHistory$previousPlanArgs<ExtArgs>
    newPlan?: boolean | SubscriptionHistory$newPlanArgs<ExtArgs>
  }
  export type SubscriptionHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    previousPlan?: boolean | SubscriptionHistory$previousPlanArgs<ExtArgs>
    newPlan?: boolean | SubscriptionHistory$newPlanArgs<ExtArgs>
  }

  export type $SubscriptionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionHistory"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
      previousPlan: Prisma.$PlanPayload<ExtArgs> | null
      newPlan: Prisma.$PlanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      subscriptionId: string
      previousPlanId: string | null
      newPlanId: string | null
      previousStatus: string | null
      newStatus: string | null
      changeType: string
      changeReason: string | null
      changedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["subscriptionHistory"]>
    composites: {}
  }

  type SubscriptionHistoryGetPayload<S extends boolean | null | undefined | SubscriptionHistoryDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionHistoryPayload, S>

  type SubscriptionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionHistoryCountAggregateInputType | true
    }

  export interface SubscriptionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionHistory'], meta: { name: 'SubscriptionHistory' } }
    /**
     * Find zero or one SubscriptionHistory that matches the filter.
     * @param {SubscriptionHistoryFindUniqueArgs} args - Arguments to find a SubscriptionHistory
     * @example
     * // Get one SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionHistoryFindUniqueArgs>(args: SelectSubset<T, SubscriptionHistoryFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionHistoryFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionHistory
     * @example
     * // Get one SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryFindFirstArgs} args - Arguments to find a SubscriptionHistory
     * @example
     * // Get one SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionHistoryFindFirstArgs>(args?: SelectSubset<T, SubscriptionHistoryFindFirstArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryFindFirstOrThrowArgs} args - Arguments to find a SubscriptionHistory
     * @example
     * // Get one SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionHistories
     * const subscriptionHistories = await prisma.subscriptionHistory.findMany()
     * 
     * // Get first 10 SubscriptionHistories
     * const subscriptionHistories = await prisma.subscriptionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionHistoryWithIdOnly = await prisma.subscriptionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionHistoryFindManyArgs>(args?: SelectSubset<T, SubscriptionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionHistory.
     * @param {SubscriptionHistoryCreateArgs} args - Arguments to create a SubscriptionHistory.
     * @example
     * // Create one SubscriptionHistory
     * const SubscriptionHistory = await prisma.subscriptionHistory.create({
     *   data: {
     *     // ... data to create a SubscriptionHistory
     *   }
     * })
     * 
     */
    create<T extends SubscriptionHistoryCreateArgs>(args: SelectSubset<T, SubscriptionHistoryCreateArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionHistories.
     * @param {SubscriptionHistoryCreateManyArgs} args - Arguments to create many SubscriptionHistories.
     * @example
     * // Create many SubscriptionHistories
     * const subscriptionHistory = await prisma.subscriptionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionHistoryCreateManyArgs>(args?: SelectSubset<T, SubscriptionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionHistories and returns the data saved in the database.
     * @param {SubscriptionHistoryCreateManyAndReturnArgs} args - Arguments to create many SubscriptionHistories.
     * @example
     * // Create many SubscriptionHistories
     * const subscriptionHistory = await prisma.subscriptionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionHistories and only return the `id`
     * const subscriptionHistoryWithIdOnly = await prisma.subscriptionHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionHistory.
     * @param {SubscriptionHistoryDeleteArgs} args - Arguments to delete one SubscriptionHistory.
     * @example
     * // Delete one SubscriptionHistory
     * const SubscriptionHistory = await prisma.subscriptionHistory.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionHistory
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionHistoryDeleteArgs>(args: SelectSubset<T, SubscriptionHistoryDeleteArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionHistory.
     * @param {SubscriptionHistoryUpdateArgs} args - Arguments to update one SubscriptionHistory.
     * @example
     * // Update one SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionHistoryUpdateArgs>(args: SelectSubset<T, SubscriptionHistoryUpdateArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionHistories.
     * @param {SubscriptionHistoryDeleteManyArgs} args - Arguments to filter SubscriptionHistories to delete.
     * @example
     * // Delete a few SubscriptionHistories
     * const { count } = await prisma.subscriptionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionHistoryDeleteManyArgs>(args?: SelectSubset<T, SubscriptionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionHistories
     * const subscriptionHistory = await prisma.subscriptionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionHistoryUpdateManyArgs>(args: SelectSubset<T, SubscriptionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionHistories and returns the data updated in the database.
     * @param {SubscriptionHistoryUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionHistories.
     * @example
     * // Update many SubscriptionHistories
     * const subscriptionHistory = await prisma.subscriptionHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionHistories and only return the `id`
     * const subscriptionHistoryWithIdOnly = await prisma.subscriptionHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionHistory.
     * @param {SubscriptionHistoryUpsertArgs} args - Arguments to update or create a SubscriptionHistory.
     * @example
     * // Update or create a SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.upsert({
     *   create: {
     *     // ... data to create a SubscriptionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionHistory we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionHistoryUpsertArgs>(args: SelectSubset<T, SubscriptionHistoryUpsertArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryCountArgs} args - Arguments to filter SubscriptionHistories to count.
     * @example
     * // Count the number of SubscriptionHistories
     * const count = await prisma.subscriptionHistory.count({
     *   where: {
     *     // ... the filter for the SubscriptionHistories we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionHistoryCountArgs>(
      args?: Subset<T, SubscriptionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionHistoryAggregateArgs>(args: Subset<T, SubscriptionHistoryAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionHistoryAggregateType<T>>

    /**
     * Group by SubscriptionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionHistory model
   */
  readonly fields: SubscriptionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    previousPlan<T extends SubscriptionHistory$previousPlanArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionHistory$previousPlanArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    newPlan<T extends SubscriptionHistory$newPlanArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionHistory$newPlanArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionHistory model
   */
  interface SubscriptionHistoryFieldRefs {
    readonly id: FieldRef<"SubscriptionHistory", 'String'>
    readonly organizationId: FieldRef<"SubscriptionHistory", 'String'>
    readonly subscriptionId: FieldRef<"SubscriptionHistory", 'String'>
    readonly previousPlanId: FieldRef<"SubscriptionHistory", 'String'>
    readonly newPlanId: FieldRef<"SubscriptionHistory", 'String'>
    readonly previousStatus: FieldRef<"SubscriptionHistory", 'String'>
    readonly newStatus: FieldRef<"SubscriptionHistory", 'String'>
    readonly changeType: FieldRef<"SubscriptionHistory", 'String'>
    readonly changeReason: FieldRef<"SubscriptionHistory", 'String'>
    readonly changedBy: FieldRef<"SubscriptionHistory", 'String'>
    readonly createdAt: FieldRef<"SubscriptionHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionHistory findUnique
   */
  export type SubscriptionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionHistory to fetch.
     */
    where: SubscriptionHistoryWhereUniqueInput
  }

  /**
   * SubscriptionHistory findUniqueOrThrow
   */
  export type SubscriptionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionHistory to fetch.
     */
    where: SubscriptionHistoryWhereUniqueInput
  }

  /**
   * SubscriptionHistory findFirst
   */
  export type SubscriptionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionHistory to fetch.
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionHistories to fetch.
     */
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionHistories.
     */
    cursor?: SubscriptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionHistories.
     */
    distinct?: SubscriptionHistoryScalarFieldEnum | SubscriptionHistoryScalarFieldEnum[]
  }

  /**
   * SubscriptionHistory findFirstOrThrow
   */
  export type SubscriptionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionHistory to fetch.
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionHistories to fetch.
     */
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionHistories.
     */
    cursor?: SubscriptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionHistories.
     */
    distinct?: SubscriptionHistoryScalarFieldEnum | SubscriptionHistoryScalarFieldEnum[]
  }

  /**
   * SubscriptionHistory findMany
   */
  export type SubscriptionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionHistories to fetch.
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionHistories to fetch.
     */
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionHistories.
     */
    cursor?: SubscriptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionHistories.
     */
    skip?: number
    distinct?: SubscriptionHistoryScalarFieldEnum | SubscriptionHistoryScalarFieldEnum[]
  }

  /**
   * SubscriptionHistory create
   */
  export type SubscriptionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionHistory.
     */
    data: XOR<SubscriptionHistoryCreateInput, SubscriptionHistoryUncheckedCreateInput>
  }

  /**
   * SubscriptionHistory createMany
   */
  export type SubscriptionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionHistories.
     */
    data: SubscriptionHistoryCreateManyInput | SubscriptionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionHistory createManyAndReturn
   */
  export type SubscriptionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionHistories.
     */
    data: SubscriptionHistoryCreateManyInput | SubscriptionHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionHistory update
   */
  export type SubscriptionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionHistory.
     */
    data: XOR<SubscriptionHistoryUpdateInput, SubscriptionHistoryUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionHistory to update.
     */
    where: SubscriptionHistoryWhereUniqueInput
  }

  /**
   * SubscriptionHistory updateMany
   */
  export type SubscriptionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionHistories.
     */
    data: XOR<SubscriptionHistoryUpdateManyMutationInput, SubscriptionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionHistories to update
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * Limit how many SubscriptionHistories to update.
     */
    limit?: number
  }

  /**
   * SubscriptionHistory updateManyAndReturn
   */
  export type SubscriptionHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionHistories.
     */
    data: XOR<SubscriptionHistoryUpdateManyMutationInput, SubscriptionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionHistories to update
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * Limit how many SubscriptionHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionHistory upsert
   */
  export type SubscriptionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionHistory to update in case it exists.
     */
    where: SubscriptionHistoryWhereUniqueInput
    /**
     * In case the SubscriptionHistory found by the `where` argument doesn't exist, create a new SubscriptionHistory with this data.
     */
    create: XOR<SubscriptionHistoryCreateInput, SubscriptionHistoryUncheckedCreateInput>
    /**
     * In case the SubscriptionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionHistoryUpdateInput, SubscriptionHistoryUncheckedUpdateInput>
  }

  /**
   * SubscriptionHistory delete
   */
  export type SubscriptionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionHistory to delete.
     */
    where: SubscriptionHistoryWhereUniqueInput
  }

  /**
   * SubscriptionHistory deleteMany
   */
  export type SubscriptionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionHistories to delete
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * Limit how many SubscriptionHistories to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionHistory.previousPlan
   */
  export type SubscriptionHistory$previousPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
  }

  /**
   * SubscriptionHistory.newPlan
   */
  export type SubscriptionHistory$newPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
  }

  /**
   * SubscriptionHistory without action
   */
  export type SubscriptionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BillingSiteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    organizationId: 'organizationId',
    createdAt: 'createdAt'
  };

  export type BillingSiteScalarFieldEnum = (typeof BillingSiteScalarFieldEnum)[keyof typeof BillingSiteScalarFieldEnum]


  export const BillingOrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillingOrganizationScalarFieldEnum = (typeof BillingOrganizationScalarFieldEnum)[keyof typeof BillingOrganizationScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    priceMonthly: 'priceMonthly',
    priceYearly: 'priceYearly',
    currency: 'currency',
    isPublic: 'isPublic',
    sortOrder: 'sortOrder',
    stripeProductId: 'stripeProductId',
    stripeMonthlyPriceId: 'stripeMonthlyPriceId',
    stripeYearlyPriceId: 'stripeYearlyPriceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const PlanFeatureScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    name: 'name',
    description: 'description',
    featureType: 'featureType',
    value: 'value',
    isHighlighted: 'isHighlighted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanFeatureScalarFieldEnum = (typeof PlanFeatureScalarFieldEnum)[keyof typeof PlanFeatureScalarFieldEnum]


  export const PlanLimitScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    resourceType: 'resourceType',
    maxValue: 'maxValue',
    overagePrice: 'overagePrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanLimitScalarFieldEnum = (typeof PlanLimitScalarFieldEnum)[keyof typeof PlanLimitScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    planId: 'planId',
    billingCycle: 'billingCycle',
    status: 'status',
    trialEndsAt: 'trialEndsAt',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelsAtPeriodEnd: 'cancelsAtPeriodEnd',
    canceledAt: 'canceledAt',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripeCustomerId: 'stripeCustomerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    stripePaymentMethodId: 'stripePaymentMethodId',
    brand: 'brand',
    last4: 'last4',
    expMonth: 'expMonth',
    expYear: 'expYear',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    subscriptionId: 'subscriptionId',
    stripeInvoiceId: 'stripeInvoiceId',
    number: 'number',
    currency: 'currency',
    subtotal: 'subtotal',
    tax: 'tax',
    total: 'total',
    status: 'status',
    invoicePdfUrl: 'invoicePdfUrl',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    amount: 'amount',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const UsageRecordScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    subscriptionId: 'subscriptionId',
    resourceType: 'resourceType',
    quantity: 'quantity',
    recordedAt: 'recordedAt'
  };

  export type UsageRecordScalarFieldEnum = (typeof UsageRecordScalarFieldEnum)[keyof typeof UsageRecordScalarFieldEnum]


  export const UsageSummaryScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    subscriptionId: 'subscriptionId',
    resourceType: 'resourceType',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    includedQuantity: 'includedQuantity',
    usedQuantity: 'usedQuantity',
    overageQuantity: 'overageQuantity',
    overageUnitPrice: 'overageUnitPrice',
    overageAmount: 'overageAmount',
    status: 'status',
    stripeUsageRecordId: 'stripeUsageRecordId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsageSummaryScalarFieldEnum = (typeof UsageSummaryScalarFieldEnum)[keyof typeof UsageSummaryScalarFieldEnum]


  export const BillingContactScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    email: 'email',
    name: 'name',
    phone: 'phone',
    companyName: 'companyName',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    vatNumber: 'vatNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillingContactScalarFieldEnum = (typeof BillingContactScalarFieldEnum)[keyof typeof BillingContactScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    discountType: 'discountType',
    discountValue: 'discountValue',
    duration: 'duration',
    durationMonths: 'durationMonths',
    maxRedemptions: 'maxRedemptions',
    redemptionCount: 'redemptionCount',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    stripePromotionCodeId: 'stripePromotionCodeId',
    stripeCouponId: 'stripeCouponId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const PromotionRedemptionScalarFieldEnum: {
    id: 'id',
    promotionId: 'promotionId',
    organizationId: 'organizationId',
    subscriptionId: 'subscriptionId',
    appliedAt: 'appliedAt'
  };

  export type PromotionRedemptionScalarFieldEnum = (typeof PromotionRedemptionScalarFieldEnum)[keyof typeof PromotionRedemptionScalarFieldEnum]


  export const PlanChangeRequestScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    currentPlanId: 'currentPlanId',
    requestedPlanId: 'requestedPlanId',
    changeType: 'changeType',
    requestedBy: 'requestedBy',
    reason: 'reason',
    status: 'status',
    processedBy: 'processedBy',
    processedAt: 'processedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanChangeRequestScalarFieldEnum = (typeof PlanChangeRequestScalarFieldEnum)[keyof typeof PlanChangeRequestScalarFieldEnum]


  export const SubscriptionHistoryScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    subscriptionId: 'subscriptionId',
    previousPlanId: 'previousPlanId',
    newPlanId: 'newPlanId',
    previousStatus: 'previousStatus',
    newStatus: 'newStatus',
    changeType: 'changeType',
    changeReason: 'changeReason',
    changedBy: 'changedBy',
    createdAt: 'createdAt'
  };

  export type SubscriptionHistoryScalarFieldEnum = (typeof SubscriptionHistoryScalarFieldEnum)[keyof typeof SubscriptionHistoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type BillingSiteWhereInput = {
    AND?: BillingSiteWhereInput | BillingSiteWhereInput[]
    OR?: BillingSiteWhereInput[]
    NOT?: BillingSiteWhereInput | BillingSiteWhereInput[]
    id?: UuidFilter<"BillingSite"> | string
    name?: StringFilter<"BillingSite"> | string
    domain?: StringFilter<"BillingSite"> | string
    organizationId?: UuidFilter<"BillingSite"> | string
    createdAt?: DateTimeFilter<"BillingSite"> | Date | string
  }

  export type BillingSiteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingSiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingSiteWhereInput | BillingSiteWhereInput[]
    OR?: BillingSiteWhereInput[]
    NOT?: BillingSiteWhereInput | BillingSiteWhereInput[]
    name?: StringFilter<"BillingSite"> | string
    domain?: StringFilter<"BillingSite"> | string
    organizationId?: UuidFilter<"BillingSite"> | string
    createdAt?: DateTimeFilter<"BillingSite"> | Date | string
  }, "id">

  export type BillingSiteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    _count?: BillingSiteCountOrderByAggregateInput
    _max?: BillingSiteMaxOrderByAggregateInput
    _min?: BillingSiteMinOrderByAggregateInput
  }

  export type BillingSiteScalarWhereWithAggregatesInput = {
    AND?: BillingSiteScalarWhereWithAggregatesInput | BillingSiteScalarWhereWithAggregatesInput[]
    OR?: BillingSiteScalarWhereWithAggregatesInput[]
    NOT?: BillingSiteScalarWhereWithAggregatesInput | BillingSiteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BillingSite"> | string
    name?: StringWithAggregatesFilter<"BillingSite"> | string
    domain?: StringWithAggregatesFilter<"BillingSite"> | string
    organizationId?: UuidWithAggregatesFilter<"BillingSite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BillingSite"> | Date | string
  }

  export type BillingOrganizationWhereInput = {
    AND?: BillingOrganizationWhereInput | BillingOrganizationWhereInput[]
    OR?: BillingOrganizationWhereInput[]
    NOT?: BillingOrganizationWhereInput | BillingOrganizationWhereInput[]
    id?: UuidFilter<"BillingOrganization"> | string
    name?: StringFilter<"BillingOrganization"> | string
    createdAt?: DateTimeFilter<"BillingOrganization"> | Date | string
    updatedAt?: DateTimeFilter<"BillingOrganization"> | Date | string
  }

  export type BillingOrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingOrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingOrganizationWhereInput | BillingOrganizationWhereInput[]
    OR?: BillingOrganizationWhereInput[]
    NOT?: BillingOrganizationWhereInput | BillingOrganizationWhereInput[]
    name?: StringFilter<"BillingOrganization"> | string
    createdAt?: DateTimeFilter<"BillingOrganization"> | Date | string
    updatedAt?: DateTimeFilter<"BillingOrganization"> | Date | string
  }, "id">

  export type BillingOrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillingOrganizationCountOrderByAggregateInput
    _max?: BillingOrganizationMaxOrderByAggregateInput
    _min?: BillingOrganizationMinOrderByAggregateInput
  }

  export type BillingOrganizationScalarWhereWithAggregatesInput = {
    AND?: BillingOrganizationScalarWhereWithAggregatesInput | BillingOrganizationScalarWhereWithAggregatesInput[]
    OR?: BillingOrganizationScalarWhereWithAggregatesInput[]
    NOT?: BillingOrganizationScalarWhereWithAggregatesInput | BillingOrganizationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BillingOrganization"> | string
    name?: StringWithAggregatesFilter<"BillingOrganization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BillingOrganization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingOrganization"> | Date | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: UuidFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    displayName?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    priceMonthly?: DecimalFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Plan"> | string
    isPublic?: BoolFilter<"Plan"> | boolean
    sortOrder?: IntFilter<"Plan"> | number
    stripeProductId?: StringNullableFilter<"Plan"> | string | null
    stripeMonthlyPriceId?: StringNullableFilter<"Plan"> | string | null
    stripeYearlyPriceId?: StringNullableFilter<"Plan"> | string | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    features?: PlanFeatureListRelationFilter
    limits?: PlanLimitListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    changeRequestsCurrent?: PlanChangeRequestListRelationFilter
    changeRequestsNew?: PlanChangeRequestListRelationFilter
    historyPrevious?: SubscriptionHistoryListRelationFilter
    historyNew?: SubscriptionHistoryListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    currency?: SortOrder
    isPublic?: SortOrder
    sortOrder?: SortOrder
    stripeProductId?: SortOrderInput | SortOrder
    stripeMonthlyPriceId?: SortOrderInput | SortOrder
    stripeYearlyPriceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    features?: PlanFeatureOrderByRelationAggregateInput
    limits?: PlanLimitOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    changeRequestsCurrent?: PlanChangeRequestOrderByRelationAggregateInput
    changeRequestsNew?: PlanChangeRequestOrderByRelationAggregateInput
    historyPrevious?: SubscriptionHistoryOrderByRelationAggregateInput
    historyNew?: SubscriptionHistoryOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    displayName?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    priceMonthly?: DecimalFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Plan"> | string
    isPublic?: BoolFilter<"Plan"> | boolean
    sortOrder?: IntFilter<"Plan"> | number
    stripeProductId?: StringNullableFilter<"Plan"> | string | null
    stripeMonthlyPriceId?: StringNullableFilter<"Plan"> | string | null
    stripeYearlyPriceId?: StringNullableFilter<"Plan"> | string | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    features?: PlanFeatureListRelationFilter
    limits?: PlanLimitListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    changeRequestsCurrent?: PlanChangeRequestListRelationFilter
    changeRequestsNew?: PlanChangeRequestListRelationFilter
    historyPrevious?: SubscriptionHistoryListRelationFilter
    historyNew?: SubscriptionHistoryListRelationFilter
  }, "id" | "name">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    currency?: SortOrder
    isPublic?: SortOrder
    sortOrder?: SortOrder
    stripeProductId?: SortOrderInput | SortOrder
    stripeMonthlyPriceId?: SortOrderInput | SortOrder
    stripeYearlyPriceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    displayName?: StringWithAggregatesFilter<"Plan"> | string
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    priceMonthly?: DecimalWithAggregatesFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalWithAggregatesFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Plan"> | string
    isPublic?: BoolWithAggregatesFilter<"Plan"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Plan"> | number
    stripeProductId?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    stripeMonthlyPriceId?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    stripeYearlyPriceId?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type PlanFeatureWhereInput = {
    AND?: PlanFeatureWhereInput | PlanFeatureWhereInput[]
    OR?: PlanFeatureWhereInput[]
    NOT?: PlanFeatureWhereInput | PlanFeatureWhereInput[]
    id?: UuidFilter<"PlanFeature"> | string
    planId?: UuidFilter<"PlanFeature"> | string
    name?: StringFilter<"PlanFeature"> | string
    description?: StringNullableFilter<"PlanFeature"> | string | null
    featureType?: StringFilter<"PlanFeature"> | string
    value?: JsonFilter<"PlanFeature">
    isHighlighted?: BoolFilter<"PlanFeature"> | boolean
    createdAt?: DateTimeFilter<"PlanFeature"> | Date | string
    updatedAt?: DateTimeFilter<"PlanFeature"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }

  export type PlanFeatureOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    featureType?: SortOrder
    value?: SortOrder
    isHighlighted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
  }

  export type PlanFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanFeatureWhereInput | PlanFeatureWhereInput[]
    OR?: PlanFeatureWhereInput[]
    NOT?: PlanFeatureWhereInput | PlanFeatureWhereInput[]
    planId?: UuidFilter<"PlanFeature"> | string
    name?: StringFilter<"PlanFeature"> | string
    description?: StringNullableFilter<"PlanFeature"> | string | null
    featureType?: StringFilter<"PlanFeature"> | string
    value?: JsonFilter<"PlanFeature">
    isHighlighted?: BoolFilter<"PlanFeature"> | boolean
    createdAt?: DateTimeFilter<"PlanFeature"> | Date | string
    updatedAt?: DateTimeFilter<"PlanFeature"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }, "id">

  export type PlanFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    featureType?: SortOrder
    value?: SortOrder
    isHighlighted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanFeatureCountOrderByAggregateInput
    _max?: PlanFeatureMaxOrderByAggregateInput
    _min?: PlanFeatureMinOrderByAggregateInput
  }

  export type PlanFeatureScalarWhereWithAggregatesInput = {
    AND?: PlanFeatureScalarWhereWithAggregatesInput | PlanFeatureScalarWhereWithAggregatesInput[]
    OR?: PlanFeatureScalarWhereWithAggregatesInput[]
    NOT?: PlanFeatureScalarWhereWithAggregatesInput | PlanFeatureScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PlanFeature"> | string
    planId?: UuidWithAggregatesFilter<"PlanFeature"> | string
    name?: StringWithAggregatesFilter<"PlanFeature"> | string
    description?: StringNullableWithAggregatesFilter<"PlanFeature"> | string | null
    featureType?: StringWithAggregatesFilter<"PlanFeature"> | string
    value?: JsonWithAggregatesFilter<"PlanFeature">
    isHighlighted?: BoolWithAggregatesFilter<"PlanFeature"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlanFeature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanFeature"> | Date | string
  }

  export type PlanLimitWhereInput = {
    AND?: PlanLimitWhereInput | PlanLimitWhereInput[]
    OR?: PlanLimitWhereInput[]
    NOT?: PlanLimitWhereInput | PlanLimitWhereInput[]
    id?: UuidFilter<"PlanLimit"> | string
    planId?: UuidFilter<"PlanLimit"> | string
    resourceType?: StringFilter<"PlanLimit"> | string
    maxValue?: IntFilter<"PlanLimit"> | number
    overagePrice?: DecimalNullableFilter<"PlanLimit"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PlanLimit"> | Date | string
    updatedAt?: DateTimeFilter<"PlanLimit"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }

  export type PlanLimitOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    resourceType?: SortOrder
    maxValue?: SortOrder
    overagePrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
  }

  export type PlanLimitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unique_plan_resource?: PlanLimitUnique_plan_resourceCompoundUniqueInput
    AND?: PlanLimitWhereInput | PlanLimitWhereInput[]
    OR?: PlanLimitWhereInput[]
    NOT?: PlanLimitWhereInput | PlanLimitWhereInput[]
    planId?: UuidFilter<"PlanLimit"> | string
    resourceType?: StringFilter<"PlanLimit"> | string
    maxValue?: IntFilter<"PlanLimit"> | number
    overagePrice?: DecimalNullableFilter<"PlanLimit"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PlanLimit"> | Date | string
    updatedAt?: DateTimeFilter<"PlanLimit"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }, "id" | "unique_plan_resource">

  export type PlanLimitOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    resourceType?: SortOrder
    maxValue?: SortOrder
    overagePrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanLimitCountOrderByAggregateInput
    _avg?: PlanLimitAvgOrderByAggregateInput
    _max?: PlanLimitMaxOrderByAggregateInput
    _min?: PlanLimitMinOrderByAggregateInput
    _sum?: PlanLimitSumOrderByAggregateInput
  }

  export type PlanLimitScalarWhereWithAggregatesInput = {
    AND?: PlanLimitScalarWhereWithAggregatesInput | PlanLimitScalarWhereWithAggregatesInput[]
    OR?: PlanLimitScalarWhereWithAggregatesInput[]
    NOT?: PlanLimitScalarWhereWithAggregatesInput | PlanLimitScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PlanLimit"> | string
    planId?: UuidWithAggregatesFilter<"PlanLimit"> | string
    resourceType?: StringWithAggregatesFilter<"PlanLimit"> | string
    maxValue?: IntWithAggregatesFilter<"PlanLimit"> | number
    overagePrice?: DecimalNullableWithAggregatesFilter<"PlanLimit"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlanLimit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanLimit"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: UuidFilter<"Subscription"> | string
    organizationId?: UuidFilter<"Subscription"> | string
    planId?: UuidFilter<"Subscription"> | string
    billingCycle?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelsAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    invoices?: InvoiceListRelationFilter
    usageRecords?: UsageRecordListRelationFilter
    usageSummaries?: UsageSummaryListRelationFilter
    promotionRedemptions?: PromotionRedemptionListRelationFilter
    history?: SubscriptionHistoryListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    planId?: SortOrder
    billingCycle?: SortOrder
    status?: SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelsAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    usageRecords?: UsageRecordOrderByRelationAggregateInput
    usageSummaries?: UsageSummaryOrderByRelationAggregateInput
    promotionRedemptions?: PromotionRedemptionOrderByRelationAggregateInput
    history?: SubscriptionHistoryOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    organizationId?: UuidFilter<"Subscription"> | string
    planId?: UuidFilter<"Subscription"> | string
    billingCycle?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelsAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    invoices?: InvoiceListRelationFilter
    usageRecords?: UsageRecordListRelationFilter
    usageSummaries?: UsageSummaryListRelationFilter
    promotionRedemptions?: PromotionRedemptionListRelationFilter
    history?: SubscriptionHistoryListRelationFilter
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    planId?: SortOrder
    billingCycle?: SortOrder
    status?: SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelsAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Subscription"> | string
    organizationId?: UuidWithAggregatesFilter<"Subscription"> | string
    planId?: UuidWithAggregatesFilter<"Subscription"> | string
    billingCycle?: StringWithAggregatesFilter<"Subscription"> | string
    status?: StringWithAggregatesFilter<"Subscription"> | string
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    cancelsAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: UuidFilter<"PaymentMethod"> | string
    organizationId?: UuidFilter<"PaymentMethod"> | string
    stripePaymentMethodId?: StringFilter<"PaymentMethod"> | string
    brand?: StringFilter<"PaymentMethod"> | string
    last4?: StringFilter<"PaymentMethod"> | string
    expMonth?: IntFilter<"PaymentMethod"> | number
    expYear?: IntFilter<"PaymentMethod"> | number
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    stripePaymentMethodId?: SortOrder
    brand?: SortOrder
    last4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    organizationId?: UuidFilter<"PaymentMethod"> | string
    stripePaymentMethodId?: StringFilter<"PaymentMethod"> | string
    brand?: StringFilter<"PaymentMethod"> | string
    last4?: StringFilter<"PaymentMethod"> | string
    expMonth?: IntFilter<"PaymentMethod"> | number
    expYear?: IntFilter<"PaymentMethod"> | number
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    stripePaymentMethodId?: SortOrder
    brand?: SortOrder
    last4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PaymentMethod"> | string
    organizationId?: UuidWithAggregatesFilter<"PaymentMethod"> | string
    stripePaymentMethodId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    brand?: StringWithAggregatesFilter<"PaymentMethod"> | string
    last4?: StringWithAggregatesFilter<"PaymentMethod"> | string
    expMonth?: IntWithAggregatesFilter<"PaymentMethod"> | number
    expYear?: IntWithAggregatesFilter<"PaymentMethod"> | number
    isDefault?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    organizationId?: UuidFilter<"Invoice"> | string
    subscriptionId?: UuidFilter<"Invoice"> | string
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    number?: StringNullableFilter<"Invoice"> | string | null
    currency?: StringFilter<"Invoice"> | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    invoicePdfUrl?: StringNullableFilter<"Invoice"> | string | null
    periodStart?: DateTimeFilter<"Invoice"> | Date | string
    periodEnd?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    items?: InvoiceItemListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    invoicePdfUrl?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    organizationId?: UuidFilter<"Invoice"> | string
    subscriptionId?: UuidFilter<"Invoice"> | string
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    number?: StringNullableFilter<"Invoice"> | string | null
    currency?: StringFilter<"Invoice"> | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    invoicePdfUrl?: StringNullableFilter<"Invoice"> | string | null
    periodStart?: DateTimeFilter<"Invoice"> | Date | string
    periodEnd?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    items?: InvoiceItemListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    invoicePdfUrl?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Invoice"> | string
    organizationId?: UuidWithAggregatesFilter<"Invoice"> | string
    subscriptionId?: UuidWithAggregatesFilter<"Invoice"> | string
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    number?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    subtotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    invoicePdfUrl?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    periodStart?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: UuidFilter<"InvoiceItem"> | string
    invoiceId?: UuidFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"InvoiceItem"> | string
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: UuidFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"InvoiceItem"> | string
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: UuidWithAggregatesFilter<"InvoiceItem"> | string
    description?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    type?: StringWithAggregatesFilter<"InvoiceItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
  }

  export type UsageRecordWhereInput = {
    AND?: UsageRecordWhereInput | UsageRecordWhereInput[]
    OR?: UsageRecordWhereInput[]
    NOT?: UsageRecordWhereInput | UsageRecordWhereInput[]
    id?: UuidFilter<"UsageRecord"> | string
    organizationId?: UuidFilter<"UsageRecord"> | string
    subscriptionId?: UuidFilter<"UsageRecord"> | string
    resourceType?: StringFilter<"UsageRecord"> | string
    quantity?: IntFilter<"UsageRecord"> | number
    recordedAt?: DateTimeFilter<"UsageRecord"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type UsageRecordOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    resourceType?: SortOrder
    quantity?: SortOrder
    recordedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type UsageRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageRecordWhereInput | UsageRecordWhereInput[]
    OR?: UsageRecordWhereInput[]
    NOT?: UsageRecordWhereInput | UsageRecordWhereInput[]
    organizationId?: UuidFilter<"UsageRecord"> | string
    subscriptionId?: UuidFilter<"UsageRecord"> | string
    resourceType?: StringFilter<"UsageRecord"> | string
    quantity?: IntFilter<"UsageRecord"> | number
    recordedAt?: DateTimeFilter<"UsageRecord"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type UsageRecordOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    resourceType?: SortOrder
    quantity?: SortOrder
    recordedAt?: SortOrder
    _count?: UsageRecordCountOrderByAggregateInput
    _avg?: UsageRecordAvgOrderByAggregateInput
    _max?: UsageRecordMaxOrderByAggregateInput
    _min?: UsageRecordMinOrderByAggregateInput
    _sum?: UsageRecordSumOrderByAggregateInput
  }

  export type UsageRecordScalarWhereWithAggregatesInput = {
    AND?: UsageRecordScalarWhereWithAggregatesInput | UsageRecordScalarWhereWithAggregatesInput[]
    OR?: UsageRecordScalarWhereWithAggregatesInput[]
    NOT?: UsageRecordScalarWhereWithAggregatesInput | UsageRecordScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UsageRecord"> | string
    organizationId?: UuidWithAggregatesFilter<"UsageRecord"> | string
    subscriptionId?: UuidWithAggregatesFilter<"UsageRecord"> | string
    resourceType?: StringWithAggregatesFilter<"UsageRecord"> | string
    quantity?: IntWithAggregatesFilter<"UsageRecord"> | number
    recordedAt?: DateTimeWithAggregatesFilter<"UsageRecord"> | Date | string
  }

  export type UsageSummaryWhereInput = {
    AND?: UsageSummaryWhereInput | UsageSummaryWhereInput[]
    OR?: UsageSummaryWhereInput[]
    NOT?: UsageSummaryWhereInput | UsageSummaryWhereInput[]
    id?: UuidFilter<"UsageSummary"> | string
    organizationId?: UuidFilter<"UsageSummary"> | string
    subscriptionId?: UuidFilter<"UsageSummary"> | string
    resourceType?: StringFilter<"UsageSummary"> | string
    periodStart?: DateTimeFilter<"UsageSummary"> | Date | string
    periodEnd?: DateTimeFilter<"UsageSummary"> | Date | string
    includedQuantity?: IntFilter<"UsageSummary"> | number
    usedQuantity?: IntFilter<"UsageSummary"> | number
    overageQuantity?: IntNullableFilter<"UsageSummary"> | number | null
    overageUnitPrice?: DecimalNullableFilter<"UsageSummary"> | Decimal | DecimalJsLike | number | string | null
    overageAmount?: DecimalFilter<"UsageSummary"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"UsageSummary"> | string
    stripeUsageRecordId?: StringNullableFilter<"UsageSummary"> | string | null
    createdAt?: DateTimeFilter<"UsageSummary"> | Date | string
    updatedAt?: DateTimeFilter<"UsageSummary"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type UsageSummaryOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    resourceType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    includedQuantity?: SortOrder
    usedQuantity?: SortOrder
    overageQuantity?: SortOrderInput | SortOrder
    overageUnitPrice?: SortOrderInput | SortOrder
    overageAmount?: SortOrder
    status?: SortOrder
    stripeUsageRecordId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type UsageSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageSummaryWhereInput | UsageSummaryWhereInput[]
    OR?: UsageSummaryWhereInput[]
    NOT?: UsageSummaryWhereInput | UsageSummaryWhereInput[]
    organizationId?: UuidFilter<"UsageSummary"> | string
    subscriptionId?: UuidFilter<"UsageSummary"> | string
    resourceType?: StringFilter<"UsageSummary"> | string
    periodStart?: DateTimeFilter<"UsageSummary"> | Date | string
    periodEnd?: DateTimeFilter<"UsageSummary"> | Date | string
    includedQuantity?: IntFilter<"UsageSummary"> | number
    usedQuantity?: IntFilter<"UsageSummary"> | number
    overageQuantity?: IntNullableFilter<"UsageSummary"> | number | null
    overageUnitPrice?: DecimalNullableFilter<"UsageSummary"> | Decimal | DecimalJsLike | number | string | null
    overageAmount?: DecimalFilter<"UsageSummary"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"UsageSummary"> | string
    stripeUsageRecordId?: StringNullableFilter<"UsageSummary"> | string | null
    createdAt?: DateTimeFilter<"UsageSummary"> | Date | string
    updatedAt?: DateTimeFilter<"UsageSummary"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type UsageSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    resourceType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    includedQuantity?: SortOrder
    usedQuantity?: SortOrder
    overageQuantity?: SortOrderInput | SortOrder
    overageUnitPrice?: SortOrderInput | SortOrder
    overageAmount?: SortOrder
    status?: SortOrder
    stripeUsageRecordId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsageSummaryCountOrderByAggregateInput
    _avg?: UsageSummaryAvgOrderByAggregateInput
    _max?: UsageSummaryMaxOrderByAggregateInput
    _min?: UsageSummaryMinOrderByAggregateInput
    _sum?: UsageSummarySumOrderByAggregateInput
  }

  export type UsageSummaryScalarWhereWithAggregatesInput = {
    AND?: UsageSummaryScalarWhereWithAggregatesInput | UsageSummaryScalarWhereWithAggregatesInput[]
    OR?: UsageSummaryScalarWhereWithAggregatesInput[]
    NOT?: UsageSummaryScalarWhereWithAggregatesInput | UsageSummaryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UsageSummary"> | string
    organizationId?: UuidWithAggregatesFilter<"UsageSummary"> | string
    subscriptionId?: UuidWithAggregatesFilter<"UsageSummary"> | string
    resourceType?: StringWithAggregatesFilter<"UsageSummary"> | string
    periodStart?: DateTimeWithAggregatesFilter<"UsageSummary"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"UsageSummary"> | Date | string
    includedQuantity?: IntWithAggregatesFilter<"UsageSummary"> | number
    usedQuantity?: IntWithAggregatesFilter<"UsageSummary"> | number
    overageQuantity?: IntNullableWithAggregatesFilter<"UsageSummary"> | number | null
    overageUnitPrice?: DecimalNullableWithAggregatesFilter<"UsageSummary"> | Decimal | DecimalJsLike | number | string | null
    overageAmount?: DecimalWithAggregatesFilter<"UsageSummary"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"UsageSummary"> | string
    stripeUsageRecordId?: StringNullableWithAggregatesFilter<"UsageSummary"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UsageSummary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UsageSummary"> | Date | string
  }

  export type BillingContactWhereInput = {
    AND?: BillingContactWhereInput | BillingContactWhereInput[]
    OR?: BillingContactWhereInput[]
    NOT?: BillingContactWhereInput | BillingContactWhereInput[]
    id?: UuidFilter<"BillingContact"> | string
    organizationId?: UuidFilter<"BillingContact"> | string
    email?: StringFilter<"BillingContact"> | string
    name?: StringNullableFilter<"BillingContact"> | string | null
    phone?: StringNullableFilter<"BillingContact"> | string | null
    companyName?: StringNullableFilter<"BillingContact"> | string | null
    addressLine1?: StringNullableFilter<"BillingContact"> | string | null
    addressLine2?: StringNullableFilter<"BillingContact"> | string | null
    city?: StringNullableFilter<"BillingContact"> | string | null
    state?: StringNullableFilter<"BillingContact"> | string | null
    postalCode?: StringNullableFilter<"BillingContact"> | string | null
    country?: StringNullableFilter<"BillingContact"> | string | null
    vatNumber?: StringNullableFilter<"BillingContact"> | string | null
    createdAt?: DateTimeFilter<"BillingContact"> | Date | string
    updatedAt?: DateTimeFilter<"BillingContact"> | Date | string
  }

  export type BillingContactOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingContactWhereInput | BillingContactWhereInput[]
    OR?: BillingContactWhereInput[]
    NOT?: BillingContactWhereInput | BillingContactWhereInput[]
    organizationId?: UuidFilter<"BillingContact"> | string
    email?: StringFilter<"BillingContact"> | string
    name?: StringNullableFilter<"BillingContact"> | string | null
    phone?: StringNullableFilter<"BillingContact"> | string | null
    companyName?: StringNullableFilter<"BillingContact"> | string | null
    addressLine1?: StringNullableFilter<"BillingContact"> | string | null
    addressLine2?: StringNullableFilter<"BillingContact"> | string | null
    city?: StringNullableFilter<"BillingContact"> | string | null
    state?: StringNullableFilter<"BillingContact"> | string | null
    postalCode?: StringNullableFilter<"BillingContact"> | string | null
    country?: StringNullableFilter<"BillingContact"> | string | null
    vatNumber?: StringNullableFilter<"BillingContact"> | string | null
    createdAt?: DateTimeFilter<"BillingContact"> | Date | string
    updatedAt?: DateTimeFilter<"BillingContact"> | Date | string
  }, "id">

  export type BillingContactOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillingContactCountOrderByAggregateInput
    _max?: BillingContactMaxOrderByAggregateInput
    _min?: BillingContactMinOrderByAggregateInput
  }

  export type BillingContactScalarWhereWithAggregatesInput = {
    AND?: BillingContactScalarWhereWithAggregatesInput | BillingContactScalarWhereWithAggregatesInput[]
    OR?: BillingContactScalarWhereWithAggregatesInput[]
    NOT?: BillingContactScalarWhereWithAggregatesInput | BillingContactScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BillingContact"> | string
    organizationId?: UuidWithAggregatesFilter<"BillingContact"> | string
    email?: StringWithAggregatesFilter<"BillingContact"> | string
    name?: StringNullableWithAggregatesFilter<"BillingContact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"BillingContact"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"BillingContact"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"BillingContact"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"BillingContact"> | string | null
    city?: StringNullableWithAggregatesFilter<"BillingContact"> | string | null
    state?: StringNullableWithAggregatesFilter<"BillingContact"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"BillingContact"> | string | null
    country?: StringNullableWithAggregatesFilter<"BillingContact"> | string | null
    vatNumber?: StringNullableWithAggregatesFilter<"BillingContact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BillingContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingContact"> | Date | string
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: UuidFilter<"Promotion"> | string
    code?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    discountType?: StringFilter<"Promotion"> | string
    discountValue?: DecimalFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    duration?: StringFilter<"Promotion"> | string
    durationMonths?: IntNullableFilter<"Promotion"> | number | null
    maxRedemptions?: IntNullableFilter<"Promotion"> | number | null
    redemptionCount?: IntFilter<"Promotion"> | number
    validFrom?: DateTimeFilter<"Promotion"> | Date | string
    validUntil?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    stripePromotionCodeId?: StringNullableFilter<"Promotion"> | string | null
    stripeCouponId?: StringNullableFilter<"Promotion"> | string | null
    isActive?: BoolFilter<"Promotion"> | boolean
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    redemptions?: PromotionRedemptionListRelationFilter
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    duration?: SortOrder
    durationMonths?: SortOrderInput | SortOrder
    maxRedemptions?: SortOrderInput | SortOrder
    redemptionCount?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    stripePromotionCodeId?: SortOrderInput | SortOrder
    stripeCouponId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    redemptions?: PromotionRedemptionOrderByRelationAggregateInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    description?: StringNullableFilter<"Promotion"> | string | null
    discountType?: StringFilter<"Promotion"> | string
    discountValue?: DecimalFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    duration?: StringFilter<"Promotion"> | string
    durationMonths?: IntNullableFilter<"Promotion"> | number | null
    maxRedemptions?: IntNullableFilter<"Promotion"> | number | null
    redemptionCount?: IntFilter<"Promotion"> | number
    validFrom?: DateTimeFilter<"Promotion"> | Date | string
    validUntil?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    stripePromotionCodeId?: StringNullableFilter<"Promotion"> | string | null
    stripeCouponId?: StringNullableFilter<"Promotion"> | string | null
    isActive?: BoolFilter<"Promotion"> | boolean
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    redemptions?: PromotionRedemptionListRelationFilter
  }, "id" | "code">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    duration?: SortOrder
    durationMonths?: SortOrderInput | SortOrder
    maxRedemptions?: SortOrderInput | SortOrder
    redemptionCount?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    stripePromotionCodeId?: SortOrderInput | SortOrder
    stripeCouponId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Promotion"> | string
    code?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    discountType?: StringWithAggregatesFilter<"Promotion"> | string
    discountValue?: DecimalWithAggregatesFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    duration?: StringWithAggregatesFilter<"Promotion"> | string
    durationMonths?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    maxRedemptions?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    redemptionCount?: IntWithAggregatesFilter<"Promotion"> | number
    validFrom?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    validUntil?: DateTimeNullableWithAggregatesFilter<"Promotion"> | Date | string | null
    stripePromotionCodeId?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    stripeCouponId?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    isActive?: BoolWithAggregatesFilter<"Promotion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
  }

  export type PromotionRedemptionWhereInput = {
    AND?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    OR?: PromotionRedemptionWhereInput[]
    NOT?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    id?: UuidFilter<"PromotionRedemption"> | string
    promotionId?: UuidFilter<"PromotionRedemption"> | string
    organizationId?: UuidFilter<"PromotionRedemption"> | string
    subscriptionId?: UuidFilter<"PromotionRedemption"> | string
    appliedAt?: DateTimeFilter<"PromotionRedemption"> | Date | string
    promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type PromotionRedemptionOrderByWithRelationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    appliedAt?: SortOrder
    promotion?: PromotionOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type PromotionRedemptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    OR?: PromotionRedemptionWhereInput[]
    NOT?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    promotionId?: UuidFilter<"PromotionRedemption"> | string
    organizationId?: UuidFilter<"PromotionRedemption"> | string
    subscriptionId?: UuidFilter<"PromotionRedemption"> | string
    appliedAt?: DateTimeFilter<"PromotionRedemption"> | Date | string
    promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type PromotionRedemptionOrderByWithAggregationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    appliedAt?: SortOrder
    _count?: PromotionRedemptionCountOrderByAggregateInput
    _max?: PromotionRedemptionMaxOrderByAggregateInput
    _min?: PromotionRedemptionMinOrderByAggregateInput
  }

  export type PromotionRedemptionScalarWhereWithAggregatesInput = {
    AND?: PromotionRedemptionScalarWhereWithAggregatesInput | PromotionRedemptionScalarWhereWithAggregatesInput[]
    OR?: PromotionRedemptionScalarWhereWithAggregatesInput[]
    NOT?: PromotionRedemptionScalarWhereWithAggregatesInput | PromotionRedemptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PromotionRedemption"> | string
    promotionId?: UuidWithAggregatesFilter<"PromotionRedemption"> | string
    organizationId?: UuidWithAggregatesFilter<"PromotionRedemption"> | string
    subscriptionId?: UuidWithAggregatesFilter<"PromotionRedemption"> | string
    appliedAt?: DateTimeWithAggregatesFilter<"PromotionRedemption"> | Date | string
  }

  export type PlanChangeRequestWhereInput = {
    AND?: PlanChangeRequestWhereInput | PlanChangeRequestWhereInput[]
    OR?: PlanChangeRequestWhereInput[]
    NOT?: PlanChangeRequestWhereInput | PlanChangeRequestWhereInput[]
    id?: UuidFilter<"PlanChangeRequest"> | string
    organizationId?: UuidFilter<"PlanChangeRequest"> | string
    currentPlanId?: UuidFilter<"PlanChangeRequest"> | string
    requestedPlanId?: UuidFilter<"PlanChangeRequest"> | string
    changeType?: StringFilter<"PlanChangeRequest"> | string
    requestedBy?: UuidFilter<"PlanChangeRequest"> | string
    reason?: StringNullableFilter<"PlanChangeRequest"> | string | null
    status?: StringFilter<"PlanChangeRequest"> | string
    processedBy?: UuidNullableFilter<"PlanChangeRequest"> | string | null
    processedAt?: DateTimeNullableFilter<"PlanChangeRequest"> | Date | string | null
    notes?: StringNullableFilter<"PlanChangeRequest"> | string | null
    createdAt?: DateTimeFilter<"PlanChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PlanChangeRequest"> | Date | string
    currentPlan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    requestedPlan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }

  export type PlanChangeRequestOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    currentPlanId?: SortOrder
    requestedPlanId?: SortOrder
    changeType?: SortOrder
    requestedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentPlan?: PlanOrderByWithRelationInput
    requestedPlan?: PlanOrderByWithRelationInput
  }

  export type PlanChangeRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanChangeRequestWhereInput | PlanChangeRequestWhereInput[]
    OR?: PlanChangeRequestWhereInput[]
    NOT?: PlanChangeRequestWhereInput | PlanChangeRequestWhereInput[]
    organizationId?: UuidFilter<"PlanChangeRequest"> | string
    currentPlanId?: UuidFilter<"PlanChangeRequest"> | string
    requestedPlanId?: UuidFilter<"PlanChangeRequest"> | string
    changeType?: StringFilter<"PlanChangeRequest"> | string
    requestedBy?: UuidFilter<"PlanChangeRequest"> | string
    reason?: StringNullableFilter<"PlanChangeRequest"> | string | null
    status?: StringFilter<"PlanChangeRequest"> | string
    processedBy?: UuidNullableFilter<"PlanChangeRequest"> | string | null
    processedAt?: DateTimeNullableFilter<"PlanChangeRequest"> | Date | string | null
    notes?: StringNullableFilter<"PlanChangeRequest"> | string | null
    createdAt?: DateTimeFilter<"PlanChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PlanChangeRequest"> | Date | string
    currentPlan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    requestedPlan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }, "id">

  export type PlanChangeRequestOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    currentPlanId?: SortOrder
    requestedPlanId?: SortOrder
    changeType?: SortOrder
    requestedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanChangeRequestCountOrderByAggregateInput
    _max?: PlanChangeRequestMaxOrderByAggregateInput
    _min?: PlanChangeRequestMinOrderByAggregateInput
  }

  export type PlanChangeRequestScalarWhereWithAggregatesInput = {
    AND?: PlanChangeRequestScalarWhereWithAggregatesInput | PlanChangeRequestScalarWhereWithAggregatesInput[]
    OR?: PlanChangeRequestScalarWhereWithAggregatesInput[]
    NOT?: PlanChangeRequestScalarWhereWithAggregatesInput | PlanChangeRequestScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PlanChangeRequest"> | string
    organizationId?: UuidWithAggregatesFilter<"PlanChangeRequest"> | string
    currentPlanId?: UuidWithAggregatesFilter<"PlanChangeRequest"> | string
    requestedPlanId?: UuidWithAggregatesFilter<"PlanChangeRequest"> | string
    changeType?: StringWithAggregatesFilter<"PlanChangeRequest"> | string
    requestedBy?: UuidWithAggregatesFilter<"PlanChangeRequest"> | string
    reason?: StringNullableWithAggregatesFilter<"PlanChangeRequest"> | string | null
    status?: StringWithAggregatesFilter<"PlanChangeRequest"> | string
    processedBy?: UuidNullableWithAggregatesFilter<"PlanChangeRequest"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"PlanChangeRequest"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"PlanChangeRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlanChangeRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanChangeRequest"> | Date | string
  }

  export type SubscriptionHistoryWhereInput = {
    AND?: SubscriptionHistoryWhereInput | SubscriptionHistoryWhereInput[]
    OR?: SubscriptionHistoryWhereInput[]
    NOT?: SubscriptionHistoryWhereInput | SubscriptionHistoryWhereInput[]
    id?: UuidFilter<"SubscriptionHistory"> | string
    organizationId?: UuidFilter<"SubscriptionHistory"> | string
    subscriptionId?: UuidFilter<"SubscriptionHistory"> | string
    previousPlanId?: UuidNullableFilter<"SubscriptionHistory"> | string | null
    newPlanId?: UuidNullableFilter<"SubscriptionHistory"> | string | null
    previousStatus?: StringNullableFilter<"SubscriptionHistory"> | string | null
    newStatus?: StringNullableFilter<"SubscriptionHistory"> | string | null
    changeType?: StringFilter<"SubscriptionHistory"> | string
    changeReason?: StringNullableFilter<"SubscriptionHistory"> | string | null
    changedBy?: UuidNullableFilter<"SubscriptionHistory"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionHistory"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    previousPlan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
    newPlan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
  }

  export type SubscriptionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    previousPlanId?: SortOrderInput | SortOrder
    newPlanId?: SortOrderInput | SortOrder
    previousStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrderInput | SortOrder
    changeType?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
    previousPlan?: PlanOrderByWithRelationInput
    newPlan?: PlanOrderByWithRelationInput
  }

  export type SubscriptionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionHistoryWhereInput | SubscriptionHistoryWhereInput[]
    OR?: SubscriptionHistoryWhereInput[]
    NOT?: SubscriptionHistoryWhereInput | SubscriptionHistoryWhereInput[]
    organizationId?: UuidFilter<"SubscriptionHistory"> | string
    subscriptionId?: UuidFilter<"SubscriptionHistory"> | string
    previousPlanId?: UuidNullableFilter<"SubscriptionHistory"> | string | null
    newPlanId?: UuidNullableFilter<"SubscriptionHistory"> | string | null
    previousStatus?: StringNullableFilter<"SubscriptionHistory"> | string | null
    newStatus?: StringNullableFilter<"SubscriptionHistory"> | string | null
    changeType?: StringFilter<"SubscriptionHistory"> | string
    changeReason?: StringNullableFilter<"SubscriptionHistory"> | string | null
    changedBy?: UuidNullableFilter<"SubscriptionHistory"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionHistory"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    previousPlan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
    newPlan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
  }, "id">

  export type SubscriptionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    previousPlanId?: SortOrderInput | SortOrder
    newPlanId?: SortOrderInput | SortOrder
    previousStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrderInput | SortOrder
    changeType?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SubscriptionHistoryCountOrderByAggregateInput
    _max?: SubscriptionHistoryMaxOrderByAggregateInput
    _min?: SubscriptionHistoryMinOrderByAggregateInput
  }

  export type SubscriptionHistoryScalarWhereWithAggregatesInput = {
    AND?: SubscriptionHistoryScalarWhereWithAggregatesInput | SubscriptionHistoryScalarWhereWithAggregatesInput[]
    OR?: SubscriptionHistoryScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionHistoryScalarWhereWithAggregatesInput | SubscriptionHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SubscriptionHistory"> | string
    organizationId?: UuidWithAggregatesFilter<"SubscriptionHistory"> | string
    subscriptionId?: UuidWithAggregatesFilter<"SubscriptionHistory"> | string
    previousPlanId?: UuidNullableWithAggregatesFilter<"SubscriptionHistory"> | string | null
    newPlanId?: UuidNullableWithAggregatesFilter<"SubscriptionHistory"> | string | null
    previousStatus?: StringNullableWithAggregatesFilter<"SubscriptionHistory"> | string | null
    newStatus?: StringNullableWithAggregatesFilter<"SubscriptionHistory"> | string | null
    changeType?: StringWithAggregatesFilter<"SubscriptionHistory"> | string
    changeReason?: StringNullableWithAggregatesFilter<"SubscriptionHistory"> | string | null
    changedBy?: UuidNullableWithAggregatesFilter<"SubscriptionHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionHistory"> | Date | string
  }

  export type BillingSiteCreateInput = {
    id?: string
    name: string
    domain: string
    organizationId: string
    createdAt?: Date | string
  }

  export type BillingSiteUncheckedCreateInput = {
    id?: string
    name: string
    domain: string
    organizationId: string
    createdAt?: Date | string
  }

  export type BillingSiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingSiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingSiteCreateManyInput = {
    id?: string
    name: string
    domain: string
    organizationId: string
    createdAt?: Date | string
  }

  export type BillingSiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingSiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingOrganizationCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingOrganizationUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingOrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingOrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingOrganizationCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingOrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingOrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    limits?: PlanLimitCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryCreateNestedManyWithoutNewPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    limits?: PlanLimitUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestUncheckedCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryUncheckedCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryUncheckedCreateNestedManyWithoutNewPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUncheckedUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUncheckedUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUncheckedUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureCreateInput = {
    id?: string
    name: string
    description?: string | null
    featureType: string
    value: JsonNullValueInput | InputJsonValue
    isHighlighted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutFeaturesInput
  }

  export type PlanFeatureUncheckedCreateInput = {
    id?: string
    planId: string
    name: string
    description?: string | null
    featureType: string
    value: JsonNullValueInput | InputJsonValue
    isHighlighted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanFeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type PlanFeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureCreateManyInput = {
    id?: string
    planId: string
    name: string
    description?: string | null
    featureType: string
    value: JsonNullValueInput | InputJsonValue
    isHighlighted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanFeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanLimitCreateInput = {
    id?: string
    resourceType: string
    maxValue: number
    overagePrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutLimitsInput
  }

  export type PlanLimitUncheckedCreateInput = {
    id?: string
    planId: string
    resourceType: string
    maxValue: number
    overagePrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanLimitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    maxValue?: IntFieldUpdateOperationsInput | number
    overagePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutLimitsNestedInput
  }

  export type PlanLimitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    maxValue?: IntFieldUpdateOperationsInput | number
    overagePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanLimitCreateManyInput = {
    id?: string
    planId: string
    resourceType: string
    maxValue: number
    overagePrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanLimitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    maxValue?: IntFieldUpdateOperationsInput | number
    overagePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanLimitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    maxValue?: IntFieldUpdateOperationsInput | number
    overagePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    organizationId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    organizationId: string
    planId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryUncheckedCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUncheckedUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    organizationId: string
    planId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    organizationId: string
    stripePaymentMethodId: string
    brand: string
    last4: string
    expMonth: number
    expYear: number
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    organizationId: string
    stripePaymentMethodId: string
    brand: string
    last4: string
    expMonth: number
    expYear: number
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    expMonth?: IntFieldUpdateOperationsInput | number
    expYear?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    expMonth?: IntFieldUpdateOperationsInput | number
    expYear?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    organizationId: string
    stripePaymentMethodId: string
    brand: string
    last4: string
    expMonth: number
    expYear: number
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    expMonth?: IntFieldUpdateOperationsInput | number
    expYear?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    expMonth?: IntFieldUpdateOperationsInput | number
    expYear?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    organizationId: string
    stripeInvoiceId?: string | null
    number?: string | null
    currency?: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    invoicePdfUrl?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    stripeInvoiceId?: string | null
    number?: string | null
    currency?: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    invoicePdfUrl?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    stripeInvoiceId?: string | null
    number?: string | null
    currency?: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    invoicePdfUrl?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordCreateInput = {
    id?: string
    organizationId: string
    resourceType: string
    quantity: number
    recordedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutUsageRecordsInput
  }

  export type UsageRecordUncheckedCreateInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    resourceType: string
    quantity: number
    recordedAt?: Date | string
  }

  export type UsageRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutUsageRecordsNestedInput
  }

  export type UsageRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordCreateManyInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    resourceType: string
    quantity: number
    recordedAt?: Date | string
  }

  export type UsageRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageSummaryCreateInput = {
    id?: string
    organizationId: string
    resourceType: string
    periodStart: Date | string
    periodEnd: Date | string
    includedQuantity: number
    usedQuantity?: number
    overageQuantity?: number | null
    overageUnitPrice?: Decimal | DecimalJsLike | number | string | null
    overageAmount?: Decimal | DecimalJsLike | number | string
    status: string
    stripeUsageRecordId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutUsageSummariesInput
  }

  export type UsageSummaryUncheckedCreateInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    resourceType: string
    periodStart: Date | string
    periodEnd: Date | string
    includedQuantity: number
    usedQuantity?: number
    overageQuantity?: number | null
    overageUnitPrice?: Decimal | DecimalJsLike | number | string | null
    overageAmount?: Decimal | DecimalJsLike | number | string
    status: string
    stripeUsageRecordId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageSummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    includedQuantity?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    overageQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    overageUnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    stripeUsageRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutUsageSummariesNestedInput
  }

  export type UsageSummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    includedQuantity?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    overageQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    overageUnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    stripeUsageRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageSummaryCreateManyInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    resourceType: string
    periodStart: Date | string
    periodEnd: Date | string
    includedQuantity: number
    usedQuantity?: number
    overageQuantity?: number | null
    overageUnitPrice?: Decimal | DecimalJsLike | number | string | null
    overageAmount?: Decimal | DecimalJsLike | number | string
    status: string
    stripeUsageRecordId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageSummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    includedQuantity?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    overageQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    overageUnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    stripeUsageRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageSummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    includedQuantity?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    overageQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    overageUnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    stripeUsageRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingContactCreateInput = {
    id?: string
    organizationId: string
    email: string
    name?: string | null
    phone?: string | null
    companyName?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    vatNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingContactUncheckedCreateInput = {
    id?: string
    organizationId: string
    email: string
    name?: string | null
    phone?: string | null
    companyName?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    vatNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingContactCreateManyInput = {
    id?: string
    organizationId: string
    email: string
    name?: string | null
    phone?: string | null
    companyName?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    vatNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateInput = {
    id?: string
    code: string
    description?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    duration: string
    durationMonths?: number | null
    maxRedemptions?: number | null
    redemptionCount?: number
    validFrom?: Date | string
    validUntil?: Date | string | null
    stripePromotionCodeId?: string | null
    stripeCouponId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: PromotionRedemptionCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    duration: string
    durationMonths?: number | null
    maxRedemptions?: number | null
    redemptionCount?: number
    validFrom?: Date | string
    validUntil?: Date | string | null
    stripePromotionCodeId?: string | null
    stripeCouponId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: StringFieldUpdateOperationsInput | string
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptionCount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePromotionCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: PromotionRedemptionUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: StringFieldUpdateOperationsInput | string
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptionCount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePromotionCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: PromotionRedemptionUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    duration: string
    durationMonths?: number | null
    maxRedemptions?: number | null
    redemptionCount?: number
    validFrom?: Date | string
    validUntil?: Date | string | null
    stripePromotionCodeId?: string | null
    stripeCouponId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: StringFieldUpdateOperationsInput | string
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptionCount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePromotionCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: StringFieldUpdateOperationsInput | string
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptionCount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePromotionCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionCreateInput = {
    id?: string
    organizationId: string
    appliedAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutRedemptionsInput
    subscription: SubscriptionCreateNestedOneWithoutPromotionRedemptionsInput
  }

  export type PromotionRedemptionUncheckedCreateInput = {
    id?: string
    promotionId: string
    organizationId: string
    subscriptionId: string
    appliedAt?: Date | string
  }

  export type PromotionRedemptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutRedemptionsNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutPromotionRedemptionsNestedInput
  }

  export type PromotionRedemptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionCreateManyInput = {
    id?: string
    promotionId: string
    organizationId: string
    subscriptionId: string
    appliedAt?: Date | string
  }

  export type PromotionRedemptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanChangeRequestCreateInput = {
    id?: string
    organizationId: string
    changeType: string
    requestedBy: string
    reason?: string | null
    status: string
    processedBy?: string | null
    processedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentPlan: PlanCreateNestedOneWithoutChangeRequestsCurrentInput
    requestedPlan: PlanCreateNestedOneWithoutChangeRequestsNewInput
  }

  export type PlanChangeRequestUncheckedCreateInput = {
    id?: string
    organizationId: string
    currentPlanId: string
    requestedPlanId: string
    changeType: string
    requestedBy: string
    reason?: string | null
    status: string
    processedBy?: string | null
    processedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanChangeRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPlan?: PlanUpdateOneRequiredWithoutChangeRequestsCurrentNestedInput
    requestedPlan?: PlanUpdateOneRequiredWithoutChangeRequestsNewNestedInput
  }

  export type PlanChangeRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    currentPlanId?: StringFieldUpdateOperationsInput | string
    requestedPlanId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanChangeRequestCreateManyInput = {
    id?: string
    organizationId: string
    currentPlanId: string
    requestedPlanId: string
    changeType: string
    requestedBy: string
    reason?: string | null
    status: string
    processedBy?: string | null
    processedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanChangeRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanChangeRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    currentPlanId?: StringFieldUpdateOperationsInput | string
    requestedPlanId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryCreateInput = {
    id?: string
    organizationId: string
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutHistoryInput
    previousPlan?: PlanCreateNestedOneWithoutHistoryPreviousInput
    newPlan?: PlanCreateNestedOneWithoutHistoryNewInput
  }

  export type SubscriptionHistoryUncheckedCreateInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    previousPlanId?: string | null
    newPlanId?: string | null
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutHistoryNestedInput
    previousPlan?: PlanUpdateOneWithoutHistoryPreviousNestedInput
    newPlan?: PlanUpdateOneWithoutHistoryNewNestedInput
  }

  export type SubscriptionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    previousPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    newPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryCreateManyInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    previousPlanId?: string | null
    newPlanId?: string | null
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    previousPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    newPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BillingSiteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingSiteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type BillingSiteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BillingOrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingOrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingOrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PlanFeatureListRelationFilter = {
    every?: PlanFeatureWhereInput
    some?: PlanFeatureWhereInput
    none?: PlanFeatureWhereInput
  }

  export type PlanLimitListRelationFilter = {
    every?: PlanLimitWhereInput
    some?: PlanLimitWhereInput
    none?: PlanLimitWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type PlanChangeRequestListRelationFilter = {
    every?: PlanChangeRequestWhereInput
    some?: PlanChangeRequestWhereInput
    none?: PlanChangeRequestWhereInput
  }

  export type SubscriptionHistoryListRelationFilter = {
    every?: SubscriptionHistoryWhereInput
    some?: SubscriptionHistoryWhereInput
    none?: SubscriptionHistoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PlanFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanLimitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanChangeRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    currency?: SortOrder
    isPublic?: SortOrder
    sortOrder?: SortOrder
    stripeProductId?: SortOrder
    stripeMonthlyPriceId?: SortOrder
    stripeYearlyPriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    sortOrder?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    currency?: SortOrder
    isPublic?: SortOrder
    sortOrder?: SortOrder
    stripeProductId?: SortOrder
    stripeMonthlyPriceId?: SortOrder
    stripeYearlyPriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    currency?: SortOrder
    isPublic?: SortOrder
    sortOrder?: SortOrder
    stripeProductId?: SortOrder
    stripeMonthlyPriceId?: SortOrder
    stripeYearlyPriceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    sortOrder?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PlanScalarRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type PlanFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    featureType?: SortOrder
    value?: SortOrder
    isHighlighted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    featureType?: SortOrder
    isHighlighted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    featureType?: SortOrder
    isHighlighted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type PlanLimitUnique_plan_resourceCompoundUniqueInput = {
    planId: string
    resourceType: string
  }

  export type PlanLimitCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    resourceType?: SortOrder
    maxValue?: SortOrder
    overagePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanLimitAvgOrderByAggregateInput = {
    maxValue?: SortOrder
    overagePrice?: SortOrder
  }

  export type PlanLimitMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    resourceType?: SortOrder
    maxValue?: SortOrder
    overagePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanLimitMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    resourceType?: SortOrder
    maxValue?: SortOrder
    overagePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanLimitSumOrderByAggregateInput = {
    maxValue?: SortOrder
    overagePrice?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type UsageRecordListRelationFilter = {
    every?: UsageRecordWhereInput
    some?: UsageRecordWhereInput
    none?: UsageRecordWhereInput
  }

  export type UsageSummaryListRelationFilter = {
    every?: UsageSummaryWhereInput
    some?: UsageSummaryWhereInput
    none?: UsageSummaryWhereInput
  }

  export type PromotionRedemptionListRelationFilter = {
    every?: PromotionRedemptionWhereInput
    some?: PromotionRedemptionWhereInput
    none?: PromotionRedemptionWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageSummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionRedemptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    planId?: SortOrder
    billingCycle?: SortOrder
    status?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelsAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    planId?: SortOrder
    billingCycle?: SortOrder
    status?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelsAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    planId?: SortOrder
    billingCycle?: SortOrder
    status?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelsAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    stripePaymentMethodId?: SortOrder
    brand?: SortOrder
    last4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    expMonth?: SortOrder
    expYear?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    stripePaymentMethodId?: SortOrder
    brand?: SortOrder
    last4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    stripePaymentMethodId?: SortOrder
    brand?: SortOrder
    last4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    expMonth?: SortOrder
    expYear?: SortOrder
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    number?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    invoicePdfUrl?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    number?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    invoicePdfUrl?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    number?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    invoicePdfUrl?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
  }

  export type UsageRecordCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    resourceType?: SortOrder
    quantity?: SortOrder
    recordedAt?: SortOrder
  }

  export type UsageRecordAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UsageRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    resourceType?: SortOrder
    quantity?: SortOrder
    recordedAt?: SortOrder
  }

  export type UsageRecordMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    resourceType?: SortOrder
    quantity?: SortOrder
    recordedAt?: SortOrder
  }

  export type UsageRecordSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UsageSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    resourceType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    includedQuantity?: SortOrder
    usedQuantity?: SortOrder
    overageQuantity?: SortOrder
    overageUnitPrice?: SortOrder
    overageAmount?: SortOrder
    status?: SortOrder
    stripeUsageRecordId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageSummaryAvgOrderByAggregateInput = {
    includedQuantity?: SortOrder
    usedQuantity?: SortOrder
    overageQuantity?: SortOrder
    overageUnitPrice?: SortOrder
    overageAmount?: SortOrder
  }

  export type UsageSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    resourceType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    includedQuantity?: SortOrder
    usedQuantity?: SortOrder
    overageQuantity?: SortOrder
    overageUnitPrice?: SortOrder
    overageAmount?: SortOrder
    status?: SortOrder
    stripeUsageRecordId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    resourceType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    includedQuantity?: SortOrder
    usedQuantity?: SortOrder
    overageQuantity?: SortOrder
    overageUnitPrice?: SortOrder
    overageAmount?: SortOrder
    status?: SortOrder
    stripeUsageRecordId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageSummarySumOrderByAggregateInput = {
    includedQuantity?: SortOrder
    usedQuantity?: SortOrder
    overageQuantity?: SortOrder
    overageUnitPrice?: SortOrder
    overageAmount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BillingContactCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    companyName?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    vatNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingContactMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    companyName?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    vatNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingContactMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    companyName?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    vatNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    duration?: SortOrder
    durationMonths?: SortOrder
    maxRedemptions?: SortOrder
    redemptionCount?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    stripePromotionCodeId?: SortOrder
    stripeCouponId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    discountValue?: SortOrder
    durationMonths?: SortOrder
    maxRedemptions?: SortOrder
    redemptionCount?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    duration?: SortOrder
    durationMonths?: SortOrder
    maxRedemptions?: SortOrder
    redemptionCount?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    stripePromotionCodeId?: SortOrder
    stripeCouponId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    duration?: SortOrder
    durationMonths?: SortOrder
    maxRedemptions?: SortOrder
    redemptionCount?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    stripePromotionCodeId?: SortOrder
    stripeCouponId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    discountValue?: SortOrder
    durationMonths?: SortOrder
    maxRedemptions?: SortOrder
    redemptionCount?: SortOrder
  }

  export type PromotionScalarRelationFilter = {
    is?: PromotionWhereInput
    isNot?: PromotionWhereInput
  }

  export type PromotionRedemptionCountOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    appliedAt?: SortOrder
  }

  export type PromotionRedemptionMaxOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    appliedAt?: SortOrder
  }

  export type PromotionRedemptionMinOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    appliedAt?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type PlanChangeRequestCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    currentPlanId?: SortOrder
    requestedPlanId?: SortOrder
    changeType?: SortOrder
    requestedBy?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanChangeRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    currentPlanId?: SortOrder
    requestedPlanId?: SortOrder
    changeType?: SortOrder
    requestedBy?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanChangeRequestMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    currentPlanId?: SortOrder
    requestedPlanId?: SortOrder
    changeType?: SortOrder
    requestedBy?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PlanNullableScalarRelationFilter = {
    is?: PlanWhereInput | null
    isNot?: PlanWhereInput | null
  }

  export type SubscriptionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    previousPlanId?: SortOrder
    newPlanId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changeType?: SortOrder
    changeReason?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    previousPlanId?: SortOrder
    newPlanId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changeType?: SortOrder
    changeReason?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    subscriptionId?: SortOrder
    previousPlanId?: SortOrder
    newPlanId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changeType?: SortOrder
    changeReason?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PlanFeatureCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput> | PlanFeatureCreateWithoutPlanInput[] | PlanFeatureUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureCreateOrConnectWithoutPlanInput | PlanFeatureCreateOrConnectWithoutPlanInput[]
    createMany?: PlanFeatureCreateManyPlanInputEnvelope
    connect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
  }

  export type PlanLimitCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanLimitCreateWithoutPlanInput, PlanLimitUncheckedCreateWithoutPlanInput> | PlanLimitCreateWithoutPlanInput[] | PlanLimitUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanLimitCreateOrConnectWithoutPlanInput | PlanLimitCreateOrConnectWithoutPlanInput[]
    createMany?: PlanLimitCreateManyPlanInputEnvelope
    connect?: PlanLimitWhereUniqueInput | PlanLimitWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type PlanChangeRequestCreateNestedManyWithoutCurrentPlanInput = {
    create?: XOR<PlanChangeRequestCreateWithoutCurrentPlanInput, PlanChangeRequestUncheckedCreateWithoutCurrentPlanInput> | PlanChangeRequestCreateWithoutCurrentPlanInput[] | PlanChangeRequestUncheckedCreateWithoutCurrentPlanInput[]
    connectOrCreate?: PlanChangeRequestCreateOrConnectWithoutCurrentPlanInput | PlanChangeRequestCreateOrConnectWithoutCurrentPlanInput[]
    createMany?: PlanChangeRequestCreateManyCurrentPlanInputEnvelope
    connect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
  }

  export type PlanChangeRequestCreateNestedManyWithoutRequestedPlanInput = {
    create?: XOR<PlanChangeRequestCreateWithoutRequestedPlanInput, PlanChangeRequestUncheckedCreateWithoutRequestedPlanInput> | PlanChangeRequestCreateWithoutRequestedPlanInput[] | PlanChangeRequestUncheckedCreateWithoutRequestedPlanInput[]
    connectOrCreate?: PlanChangeRequestCreateOrConnectWithoutRequestedPlanInput | PlanChangeRequestCreateOrConnectWithoutRequestedPlanInput[]
    createMany?: PlanChangeRequestCreateManyRequestedPlanInputEnvelope
    connect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
  }

  export type SubscriptionHistoryCreateNestedManyWithoutPreviousPlanInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutPreviousPlanInput, SubscriptionHistoryUncheckedCreateWithoutPreviousPlanInput> | SubscriptionHistoryCreateWithoutPreviousPlanInput[] | SubscriptionHistoryUncheckedCreateWithoutPreviousPlanInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutPreviousPlanInput | SubscriptionHistoryCreateOrConnectWithoutPreviousPlanInput[]
    createMany?: SubscriptionHistoryCreateManyPreviousPlanInputEnvelope
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
  }

  export type SubscriptionHistoryCreateNestedManyWithoutNewPlanInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutNewPlanInput, SubscriptionHistoryUncheckedCreateWithoutNewPlanInput> | SubscriptionHistoryCreateWithoutNewPlanInput[] | SubscriptionHistoryUncheckedCreateWithoutNewPlanInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutNewPlanInput | SubscriptionHistoryCreateOrConnectWithoutNewPlanInput[]
    createMany?: SubscriptionHistoryCreateManyNewPlanInputEnvelope
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
  }

  export type PlanFeatureUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput> | PlanFeatureCreateWithoutPlanInput[] | PlanFeatureUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureCreateOrConnectWithoutPlanInput | PlanFeatureCreateOrConnectWithoutPlanInput[]
    createMany?: PlanFeatureCreateManyPlanInputEnvelope
    connect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
  }

  export type PlanLimitUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanLimitCreateWithoutPlanInput, PlanLimitUncheckedCreateWithoutPlanInput> | PlanLimitCreateWithoutPlanInput[] | PlanLimitUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanLimitCreateOrConnectWithoutPlanInput | PlanLimitCreateOrConnectWithoutPlanInput[]
    createMany?: PlanLimitCreateManyPlanInputEnvelope
    connect?: PlanLimitWhereUniqueInput | PlanLimitWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type PlanChangeRequestUncheckedCreateNestedManyWithoutCurrentPlanInput = {
    create?: XOR<PlanChangeRequestCreateWithoutCurrentPlanInput, PlanChangeRequestUncheckedCreateWithoutCurrentPlanInput> | PlanChangeRequestCreateWithoutCurrentPlanInput[] | PlanChangeRequestUncheckedCreateWithoutCurrentPlanInput[]
    connectOrCreate?: PlanChangeRequestCreateOrConnectWithoutCurrentPlanInput | PlanChangeRequestCreateOrConnectWithoutCurrentPlanInput[]
    createMany?: PlanChangeRequestCreateManyCurrentPlanInputEnvelope
    connect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
  }

  export type PlanChangeRequestUncheckedCreateNestedManyWithoutRequestedPlanInput = {
    create?: XOR<PlanChangeRequestCreateWithoutRequestedPlanInput, PlanChangeRequestUncheckedCreateWithoutRequestedPlanInput> | PlanChangeRequestCreateWithoutRequestedPlanInput[] | PlanChangeRequestUncheckedCreateWithoutRequestedPlanInput[]
    connectOrCreate?: PlanChangeRequestCreateOrConnectWithoutRequestedPlanInput | PlanChangeRequestCreateOrConnectWithoutRequestedPlanInput[]
    createMany?: PlanChangeRequestCreateManyRequestedPlanInputEnvelope
    connect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
  }

  export type SubscriptionHistoryUncheckedCreateNestedManyWithoutPreviousPlanInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutPreviousPlanInput, SubscriptionHistoryUncheckedCreateWithoutPreviousPlanInput> | SubscriptionHistoryCreateWithoutPreviousPlanInput[] | SubscriptionHistoryUncheckedCreateWithoutPreviousPlanInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutPreviousPlanInput | SubscriptionHistoryCreateOrConnectWithoutPreviousPlanInput[]
    createMany?: SubscriptionHistoryCreateManyPreviousPlanInputEnvelope
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
  }

  export type SubscriptionHistoryUncheckedCreateNestedManyWithoutNewPlanInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutNewPlanInput, SubscriptionHistoryUncheckedCreateWithoutNewPlanInput> | SubscriptionHistoryCreateWithoutNewPlanInput[] | SubscriptionHistoryUncheckedCreateWithoutNewPlanInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutNewPlanInput | SubscriptionHistoryCreateOrConnectWithoutNewPlanInput[]
    createMany?: SubscriptionHistoryCreateManyNewPlanInputEnvelope
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlanFeatureUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput> | PlanFeatureCreateWithoutPlanInput[] | PlanFeatureUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureCreateOrConnectWithoutPlanInput | PlanFeatureCreateOrConnectWithoutPlanInput[]
    upsert?: PlanFeatureUpsertWithWhereUniqueWithoutPlanInput | PlanFeatureUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanFeatureCreateManyPlanInputEnvelope
    set?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    disconnect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    delete?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    connect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    update?: PlanFeatureUpdateWithWhereUniqueWithoutPlanInput | PlanFeatureUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanFeatureUpdateManyWithWhereWithoutPlanInput | PlanFeatureUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanFeatureScalarWhereInput | PlanFeatureScalarWhereInput[]
  }

  export type PlanLimitUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanLimitCreateWithoutPlanInput, PlanLimitUncheckedCreateWithoutPlanInput> | PlanLimitCreateWithoutPlanInput[] | PlanLimitUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanLimitCreateOrConnectWithoutPlanInput | PlanLimitCreateOrConnectWithoutPlanInput[]
    upsert?: PlanLimitUpsertWithWhereUniqueWithoutPlanInput | PlanLimitUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanLimitCreateManyPlanInputEnvelope
    set?: PlanLimitWhereUniqueInput | PlanLimitWhereUniqueInput[]
    disconnect?: PlanLimitWhereUniqueInput | PlanLimitWhereUniqueInput[]
    delete?: PlanLimitWhereUniqueInput | PlanLimitWhereUniqueInput[]
    connect?: PlanLimitWhereUniqueInput | PlanLimitWhereUniqueInput[]
    update?: PlanLimitUpdateWithWhereUniqueWithoutPlanInput | PlanLimitUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanLimitUpdateManyWithWhereWithoutPlanInput | PlanLimitUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanLimitScalarWhereInput | PlanLimitScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PlanChangeRequestUpdateManyWithoutCurrentPlanNestedInput = {
    create?: XOR<PlanChangeRequestCreateWithoutCurrentPlanInput, PlanChangeRequestUncheckedCreateWithoutCurrentPlanInput> | PlanChangeRequestCreateWithoutCurrentPlanInput[] | PlanChangeRequestUncheckedCreateWithoutCurrentPlanInput[]
    connectOrCreate?: PlanChangeRequestCreateOrConnectWithoutCurrentPlanInput | PlanChangeRequestCreateOrConnectWithoutCurrentPlanInput[]
    upsert?: PlanChangeRequestUpsertWithWhereUniqueWithoutCurrentPlanInput | PlanChangeRequestUpsertWithWhereUniqueWithoutCurrentPlanInput[]
    createMany?: PlanChangeRequestCreateManyCurrentPlanInputEnvelope
    set?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    disconnect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    delete?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    connect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    update?: PlanChangeRequestUpdateWithWhereUniqueWithoutCurrentPlanInput | PlanChangeRequestUpdateWithWhereUniqueWithoutCurrentPlanInput[]
    updateMany?: PlanChangeRequestUpdateManyWithWhereWithoutCurrentPlanInput | PlanChangeRequestUpdateManyWithWhereWithoutCurrentPlanInput[]
    deleteMany?: PlanChangeRequestScalarWhereInput | PlanChangeRequestScalarWhereInput[]
  }

  export type PlanChangeRequestUpdateManyWithoutRequestedPlanNestedInput = {
    create?: XOR<PlanChangeRequestCreateWithoutRequestedPlanInput, PlanChangeRequestUncheckedCreateWithoutRequestedPlanInput> | PlanChangeRequestCreateWithoutRequestedPlanInput[] | PlanChangeRequestUncheckedCreateWithoutRequestedPlanInput[]
    connectOrCreate?: PlanChangeRequestCreateOrConnectWithoutRequestedPlanInput | PlanChangeRequestCreateOrConnectWithoutRequestedPlanInput[]
    upsert?: PlanChangeRequestUpsertWithWhereUniqueWithoutRequestedPlanInput | PlanChangeRequestUpsertWithWhereUniqueWithoutRequestedPlanInput[]
    createMany?: PlanChangeRequestCreateManyRequestedPlanInputEnvelope
    set?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    disconnect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    delete?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    connect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    update?: PlanChangeRequestUpdateWithWhereUniqueWithoutRequestedPlanInput | PlanChangeRequestUpdateWithWhereUniqueWithoutRequestedPlanInput[]
    updateMany?: PlanChangeRequestUpdateManyWithWhereWithoutRequestedPlanInput | PlanChangeRequestUpdateManyWithWhereWithoutRequestedPlanInput[]
    deleteMany?: PlanChangeRequestScalarWhereInput | PlanChangeRequestScalarWhereInput[]
  }

  export type SubscriptionHistoryUpdateManyWithoutPreviousPlanNestedInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutPreviousPlanInput, SubscriptionHistoryUncheckedCreateWithoutPreviousPlanInput> | SubscriptionHistoryCreateWithoutPreviousPlanInput[] | SubscriptionHistoryUncheckedCreateWithoutPreviousPlanInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutPreviousPlanInput | SubscriptionHistoryCreateOrConnectWithoutPreviousPlanInput[]
    upsert?: SubscriptionHistoryUpsertWithWhereUniqueWithoutPreviousPlanInput | SubscriptionHistoryUpsertWithWhereUniqueWithoutPreviousPlanInput[]
    createMany?: SubscriptionHistoryCreateManyPreviousPlanInputEnvelope
    set?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    disconnect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    delete?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    update?: SubscriptionHistoryUpdateWithWhereUniqueWithoutPreviousPlanInput | SubscriptionHistoryUpdateWithWhereUniqueWithoutPreviousPlanInput[]
    updateMany?: SubscriptionHistoryUpdateManyWithWhereWithoutPreviousPlanInput | SubscriptionHistoryUpdateManyWithWhereWithoutPreviousPlanInput[]
    deleteMany?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
  }

  export type SubscriptionHistoryUpdateManyWithoutNewPlanNestedInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutNewPlanInput, SubscriptionHistoryUncheckedCreateWithoutNewPlanInput> | SubscriptionHistoryCreateWithoutNewPlanInput[] | SubscriptionHistoryUncheckedCreateWithoutNewPlanInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutNewPlanInput | SubscriptionHistoryCreateOrConnectWithoutNewPlanInput[]
    upsert?: SubscriptionHistoryUpsertWithWhereUniqueWithoutNewPlanInput | SubscriptionHistoryUpsertWithWhereUniqueWithoutNewPlanInput[]
    createMany?: SubscriptionHistoryCreateManyNewPlanInputEnvelope
    set?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    disconnect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    delete?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    update?: SubscriptionHistoryUpdateWithWhereUniqueWithoutNewPlanInput | SubscriptionHistoryUpdateWithWhereUniqueWithoutNewPlanInput[]
    updateMany?: SubscriptionHistoryUpdateManyWithWhereWithoutNewPlanInput | SubscriptionHistoryUpdateManyWithWhereWithoutNewPlanInput[]
    deleteMany?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
  }

  export type PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput> | PlanFeatureCreateWithoutPlanInput[] | PlanFeatureUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanFeatureCreateOrConnectWithoutPlanInput | PlanFeatureCreateOrConnectWithoutPlanInput[]
    upsert?: PlanFeatureUpsertWithWhereUniqueWithoutPlanInput | PlanFeatureUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanFeatureCreateManyPlanInputEnvelope
    set?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    disconnect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    delete?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    connect?: PlanFeatureWhereUniqueInput | PlanFeatureWhereUniqueInput[]
    update?: PlanFeatureUpdateWithWhereUniqueWithoutPlanInput | PlanFeatureUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanFeatureUpdateManyWithWhereWithoutPlanInput | PlanFeatureUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanFeatureScalarWhereInput | PlanFeatureScalarWhereInput[]
  }

  export type PlanLimitUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanLimitCreateWithoutPlanInput, PlanLimitUncheckedCreateWithoutPlanInput> | PlanLimitCreateWithoutPlanInput[] | PlanLimitUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanLimitCreateOrConnectWithoutPlanInput | PlanLimitCreateOrConnectWithoutPlanInput[]
    upsert?: PlanLimitUpsertWithWhereUniqueWithoutPlanInput | PlanLimitUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanLimitCreateManyPlanInputEnvelope
    set?: PlanLimitWhereUniqueInput | PlanLimitWhereUniqueInput[]
    disconnect?: PlanLimitWhereUniqueInput | PlanLimitWhereUniqueInput[]
    delete?: PlanLimitWhereUniqueInput | PlanLimitWhereUniqueInput[]
    connect?: PlanLimitWhereUniqueInput | PlanLimitWhereUniqueInput[]
    update?: PlanLimitUpdateWithWhereUniqueWithoutPlanInput | PlanLimitUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanLimitUpdateManyWithWhereWithoutPlanInput | PlanLimitUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanLimitScalarWhereInput | PlanLimitScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PlanChangeRequestUncheckedUpdateManyWithoutCurrentPlanNestedInput = {
    create?: XOR<PlanChangeRequestCreateWithoutCurrentPlanInput, PlanChangeRequestUncheckedCreateWithoutCurrentPlanInput> | PlanChangeRequestCreateWithoutCurrentPlanInput[] | PlanChangeRequestUncheckedCreateWithoutCurrentPlanInput[]
    connectOrCreate?: PlanChangeRequestCreateOrConnectWithoutCurrentPlanInput | PlanChangeRequestCreateOrConnectWithoutCurrentPlanInput[]
    upsert?: PlanChangeRequestUpsertWithWhereUniqueWithoutCurrentPlanInput | PlanChangeRequestUpsertWithWhereUniqueWithoutCurrentPlanInput[]
    createMany?: PlanChangeRequestCreateManyCurrentPlanInputEnvelope
    set?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    disconnect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    delete?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    connect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    update?: PlanChangeRequestUpdateWithWhereUniqueWithoutCurrentPlanInput | PlanChangeRequestUpdateWithWhereUniqueWithoutCurrentPlanInput[]
    updateMany?: PlanChangeRequestUpdateManyWithWhereWithoutCurrentPlanInput | PlanChangeRequestUpdateManyWithWhereWithoutCurrentPlanInput[]
    deleteMany?: PlanChangeRequestScalarWhereInput | PlanChangeRequestScalarWhereInput[]
  }

  export type PlanChangeRequestUncheckedUpdateManyWithoutRequestedPlanNestedInput = {
    create?: XOR<PlanChangeRequestCreateWithoutRequestedPlanInput, PlanChangeRequestUncheckedCreateWithoutRequestedPlanInput> | PlanChangeRequestCreateWithoutRequestedPlanInput[] | PlanChangeRequestUncheckedCreateWithoutRequestedPlanInput[]
    connectOrCreate?: PlanChangeRequestCreateOrConnectWithoutRequestedPlanInput | PlanChangeRequestCreateOrConnectWithoutRequestedPlanInput[]
    upsert?: PlanChangeRequestUpsertWithWhereUniqueWithoutRequestedPlanInput | PlanChangeRequestUpsertWithWhereUniqueWithoutRequestedPlanInput[]
    createMany?: PlanChangeRequestCreateManyRequestedPlanInputEnvelope
    set?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    disconnect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    delete?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    connect?: PlanChangeRequestWhereUniqueInput | PlanChangeRequestWhereUniqueInput[]
    update?: PlanChangeRequestUpdateWithWhereUniqueWithoutRequestedPlanInput | PlanChangeRequestUpdateWithWhereUniqueWithoutRequestedPlanInput[]
    updateMany?: PlanChangeRequestUpdateManyWithWhereWithoutRequestedPlanInput | PlanChangeRequestUpdateManyWithWhereWithoutRequestedPlanInput[]
    deleteMany?: PlanChangeRequestScalarWhereInput | PlanChangeRequestScalarWhereInput[]
  }

  export type SubscriptionHistoryUncheckedUpdateManyWithoutPreviousPlanNestedInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutPreviousPlanInput, SubscriptionHistoryUncheckedCreateWithoutPreviousPlanInput> | SubscriptionHistoryCreateWithoutPreviousPlanInput[] | SubscriptionHistoryUncheckedCreateWithoutPreviousPlanInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutPreviousPlanInput | SubscriptionHistoryCreateOrConnectWithoutPreviousPlanInput[]
    upsert?: SubscriptionHistoryUpsertWithWhereUniqueWithoutPreviousPlanInput | SubscriptionHistoryUpsertWithWhereUniqueWithoutPreviousPlanInput[]
    createMany?: SubscriptionHistoryCreateManyPreviousPlanInputEnvelope
    set?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    disconnect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    delete?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    update?: SubscriptionHistoryUpdateWithWhereUniqueWithoutPreviousPlanInput | SubscriptionHistoryUpdateWithWhereUniqueWithoutPreviousPlanInput[]
    updateMany?: SubscriptionHistoryUpdateManyWithWhereWithoutPreviousPlanInput | SubscriptionHistoryUpdateManyWithWhereWithoutPreviousPlanInput[]
    deleteMany?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
  }

  export type SubscriptionHistoryUncheckedUpdateManyWithoutNewPlanNestedInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutNewPlanInput, SubscriptionHistoryUncheckedCreateWithoutNewPlanInput> | SubscriptionHistoryCreateWithoutNewPlanInput[] | SubscriptionHistoryUncheckedCreateWithoutNewPlanInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutNewPlanInput | SubscriptionHistoryCreateOrConnectWithoutNewPlanInput[]
    upsert?: SubscriptionHistoryUpsertWithWhereUniqueWithoutNewPlanInput | SubscriptionHistoryUpsertWithWhereUniqueWithoutNewPlanInput[]
    createMany?: SubscriptionHistoryCreateManyNewPlanInputEnvelope
    set?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    disconnect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    delete?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    update?: SubscriptionHistoryUpdateWithWhereUniqueWithoutNewPlanInput | SubscriptionHistoryUpdateWithWhereUniqueWithoutNewPlanInput[]
    updateMany?: SubscriptionHistoryUpdateManyWithWhereWithoutNewPlanInput | SubscriptionHistoryUpdateManyWithWhereWithoutNewPlanInput[]
    deleteMany?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<PlanCreateWithoutFeaturesInput, PlanUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PlanCreateOrConnectWithoutFeaturesInput
    connect?: PlanWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<PlanCreateWithoutFeaturesInput, PlanUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PlanCreateOrConnectWithoutFeaturesInput
    upsert?: PlanUpsertWithoutFeaturesInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutFeaturesInput, PlanUpdateWithoutFeaturesInput>, PlanUncheckedUpdateWithoutFeaturesInput>
  }

  export type PlanCreateNestedOneWithoutLimitsInput = {
    create?: XOR<PlanCreateWithoutLimitsInput, PlanUncheckedCreateWithoutLimitsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutLimitsInput
    connect?: PlanWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PlanUpdateOneRequiredWithoutLimitsNestedInput = {
    create?: XOR<PlanCreateWithoutLimitsInput, PlanUncheckedCreateWithoutLimitsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutLimitsInput
    upsert?: PlanUpsertWithoutLimitsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutLimitsInput, PlanUpdateWithoutLimitsInput>, PlanUncheckedUpdateWithoutLimitsInput>
  }

  export type PlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UsageRecordCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
  }

  export type UsageSummaryCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UsageSummaryCreateWithoutSubscriptionInput, UsageSummaryUncheckedCreateWithoutSubscriptionInput> | UsageSummaryCreateWithoutSubscriptionInput[] | UsageSummaryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageSummaryCreateOrConnectWithoutSubscriptionInput | UsageSummaryCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UsageSummaryCreateManySubscriptionInputEnvelope
    connect?: UsageSummaryWhereUniqueInput | UsageSummaryWhereUniqueInput[]
  }

  export type PromotionRedemptionCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PromotionRedemptionCreateWithoutSubscriptionInput, PromotionRedemptionUncheckedCreateWithoutSubscriptionInput> | PromotionRedemptionCreateWithoutSubscriptionInput[] | PromotionRedemptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutSubscriptionInput | PromotionRedemptionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PromotionRedemptionCreateManySubscriptionInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type SubscriptionHistoryCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput> | SubscriptionHistoryCreateWithoutSubscriptionInput[] | SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput | SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriptionHistoryCreateManySubscriptionInputEnvelope
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
  }

  export type UsageSummaryUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UsageSummaryCreateWithoutSubscriptionInput, UsageSummaryUncheckedCreateWithoutSubscriptionInput> | UsageSummaryCreateWithoutSubscriptionInput[] | UsageSummaryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageSummaryCreateOrConnectWithoutSubscriptionInput | UsageSummaryCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UsageSummaryCreateManySubscriptionInputEnvelope
    connect?: UsageSummaryWhereUniqueInput | UsageSummaryWhereUniqueInput[]
  }

  export type PromotionRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PromotionRedemptionCreateWithoutSubscriptionInput, PromotionRedemptionUncheckedCreateWithoutSubscriptionInput> | PromotionRedemptionCreateWithoutSubscriptionInput[] | PromotionRedemptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutSubscriptionInput | PromotionRedemptionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PromotionRedemptionCreateManySubscriptionInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type SubscriptionHistoryUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput> | SubscriptionHistoryCreateWithoutSubscriptionInput[] | SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput | SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriptionHistoryCreateManySubscriptionInputEnvelope
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: PlanUpsertWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutSubscriptionsInput, PlanUpdateWithoutSubscriptionsInput>, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type InvoiceUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UsageRecordUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    set?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    disconnect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    delete?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    update?: UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UsageRecordUpdateManyWithWhereWithoutSubscriptionInput | UsageRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
  }

  export type UsageSummaryUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UsageSummaryCreateWithoutSubscriptionInput, UsageSummaryUncheckedCreateWithoutSubscriptionInput> | UsageSummaryCreateWithoutSubscriptionInput[] | UsageSummaryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageSummaryCreateOrConnectWithoutSubscriptionInput | UsageSummaryCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UsageSummaryUpsertWithWhereUniqueWithoutSubscriptionInput | UsageSummaryUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UsageSummaryCreateManySubscriptionInputEnvelope
    set?: UsageSummaryWhereUniqueInput | UsageSummaryWhereUniqueInput[]
    disconnect?: UsageSummaryWhereUniqueInput | UsageSummaryWhereUniqueInput[]
    delete?: UsageSummaryWhereUniqueInput | UsageSummaryWhereUniqueInput[]
    connect?: UsageSummaryWhereUniqueInput | UsageSummaryWhereUniqueInput[]
    update?: UsageSummaryUpdateWithWhereUniqueWithoutSubscriptionInput | UsageSummaryUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UsageSummaryUpdateManyWithWhereWithoutSubscriptionInput | UsageSummaryUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UsageSummaryScalarWhereInput | UsageSummaryScalarWhereInput[]
  }

  export type PromotionRedemptionUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutSubscriptionInput, PromotionRedemptionUncheckedCreateWithoutSubscriptionInput> | PromotionRedemptionCreateWithoutSubscriptionInput[] | PromotionRedemptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutSubscriptionInput | PromotionRedemptionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutSubscriptionInput | PromotionRedemptionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PromotionRedemptionCreateManySubscriptionInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutSubscriptionInput | PromotionRedemptionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutSubscriptionInput | PromotionRedemptionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type SubscriptionHistoryUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput> | SubscriptionHistoryCreateWithoutSubscriptionInput[] | SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput | SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriptionHistoryUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriptionHistoryUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriptionHistoryCreateManySubscriptionInputEnvelope
    set?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    disconnect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    delete?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    update?: SubscriptionHistoryUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriptionHistoryUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriptionHistoryUpdateManyWithWhereWithoutSubscriptionInput | SubscriptionHistoryUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput> | UsageRecordCreateWithoutSubscriptionInput[] | UsageRecordUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageRecordCreateOrConnectWithoutSubscriptionInput | UsageRecordCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UsageRecordCreateManySubscriptionInputEnvelope
    set?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    disconnect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    delete?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    connect?: UsageRecordWhereUniqueInput | UsageRecordWhereUniqueInput[]
    update?: UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput | UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UsageRecordUpdateManyWithWhereWithoutSubscriptionInput | UsageRecordUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
  }

  export type UsageSummaryUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UsageSummaryCreateWithoutSubscriptionInput, UsageSummaryUncheckedCreateWithoutSubscriptionInput> | UsageSummaryCreateWithoutSubscriptionInput[] | UsageSummaryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UsageSummaryCreateOrConnectWithoutSubscriptionInput | UsageSummaryCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UsageSummaryUpsertWithWhereUniqueWithoutSubscriptionInput | UsageSummaryUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UsageSummaryCreateManySubscriptionInputEnvelope
    set?: UsageSummaryWhereUniqueInput | UsageSummaryWhereUniqueInput[]
    disconnect?: UsageSummaryWhereUniqueInput | UsageSummaryWhereUniqueInput[]
    delete?: UsageSummaryWhereUniqueInput | UsageSummaryWhereUniqueInput[]
    connect?: UsageSummaryWhereUniqueInput | UsageSummaryWhereUniqueInput[]
    update?: UsageSummaryUpdateWithWhereUniqueWithoutSubscriptionInput | UsageSummaryUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UsageSummaryUpdateManyWithWhereWithoutSubscriptionInput | UsageSummaryUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UsageSummaryScalarWhereInput | UsageSummaryScalarWhereInput[]
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutSubscriptionInput, PromotionRedemptionUncheckedCreateWithoutSubscriptionInput> | PromotionRedemptionCreateWithoutSubscriptionInput[] | PromotionRedemptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutSubscriptionInput | PromotionRedemptionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutSubscriptionInput | PromotionRedemptionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PromotionRedemptionCreateManySubscriptionInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutSubscriptionInput | PromotionRedemptionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutSubscriptionInput | PromotionRedemptionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput> | SubscriptionHistoryCreateWithoutSubscriptionInput[] | SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput | SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriptionHistoryUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriptionHistoryUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriptionHistoryCreateManySubscriptionInputEnvelope
    set?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    disconnect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    delete?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    update?: SubscriptionHistoryUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriptionHistoryUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriptionHistoryUpdateManyWithWhereWithoutSubscriptionInput | SubscriptionHistoryUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
  }

  export type SubscriptionCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    upsert?: SubscriptionUpsertWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutInvoicesInput, SubscriptionUpdateWithoutInvoicesInput>, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type SubscriptionCreateNestedOneWithoutUsageRecordsInput = {
    create?: XOR<SubscriptionCreateWithoutUsageRecordsInput, SubscriptionUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageRecordsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutUsageRecordsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUsageRecordsInput, SubscriptionUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageRecordsInput
    upsert?: SubscriptionUpsertWithoutUsageRecordsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUsageRecordsInput, SubscriptionUpdateWithoutUsageRecordsInput>, SubscriptionUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type SubscriptionCreateNestedOneWithoutUsageSummariesInput = {
    create?: XOR<SubscriptionCreateWithoutUsageSummariesInput, SubscriptionUncheckedCreateWithoutUsageSummariesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageSummariesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SubscriptionUpdateOneRequiredWithoutUsageSummariesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUsageSummariesInput, SubscriptionUncheckedCreateWithoutUsageSummariesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUsageSummariesInput
    upsert?: SubscriptionUpsertWithoutUsageSummariesInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUsageSummariesInput, SubscriptionUpdateWithoutUsageSummariesInput>, SubscriptionUncheckedUpdateWithoutUsageSummariesInput>
  }

  export type PromotionRedemptionCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput> | PromotionRedemptionCreateWithoutPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutPromotionInput | PromotionRedemptionCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionRedemptionCreateManyPromotionInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type PromotionRedemptionUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput> | PromotionRedemptionCreateWithoutPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutPromotionInput | PromotionRedemptionCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionRedemptionCreateManyPromotionInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type PromotionRedemptionUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput> | PromotionRedemptionCreateWithoutPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutPromotionInput | PromotionRedemptionCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutPromotionInput | PromotionRedemptionUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionRedemptionCreateManyPromotionInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutPromotionInput | PromotionRedemptionUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutPromotionInput | PromotionRedemptionUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput> | PromotionRedemptionCreateWithoutPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutPromotionInput | PromotionRedemptionCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutPromotionInput | PromotionRedemptionUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionRedemptionCreateManyPromotionInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutPromotionInput | PromotionRedemptionUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutPromotionInput | PromotionRedemptionUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type PromotionCreateNestedOneWithoutRedemptionsInput = {
    create?: XOR<PromotionCreateWithoutRedemptionsInput, PromotionUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutRedemptionsInput
    connect?: PromotionWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutPromotionRedemptionsInput = {
    create?: XOR<SubscriptionCreateWithoutPromotionRedemptionsInput, SubscriptionUncheckedCreateWithoutPromotionRedemptionsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPromotionRedemptionsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type PromotionUpdateOneRequiredWithoutRedemptionsNestedInput = {
    create?: XOR<PromotionCreateWithoutRedemptionsInput, PromotionUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutRedemptionsInput
    upsert?: PromotionUpsertWithoutRedemptionsInput
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutRedemptionsInput, PromotionUpdateWithoutRedemptionsInput>, PromotionUncheckedUpdateWithoutRedemptionsInput>
  }

  export type SubscriptionUpdateOneRequiredWithoutPromotionRedemptionsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPromotionRedemptionsInput, SubscriptionUncheckedCreateWithoutPromotionRedemptionsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPromotionRedemptionsInput
    upsert?: SubscriptionUpsertWithoutPromotionRedemptionsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutPromotionRedemptionsInput, SubscriptionUpdateWithoutPromotionRedemptionsInput>, SubscriptionUncheckedUpdateWithoutPromotionRedemptionsInput>
  }

  export type PlanCreateNestedOneWithoutChangeRequestsCurrentInput = {
    create?: XOR<PlanCreateWithoutChangeRequestsCurrentInput, PlanUncheckedCreateWithoutChangeRequestsCurrentInput>
    connectOrCreate?: PlanCreateOrConnectWithoutChangeRequestsCurrentInput
    connect?: PlanWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutChangeRequestsNewInput = {
    create?: XOR<PlanCreateWithoutChangeRequestsNewInput, PlanUncheckedCreateWithoutChangeRequestsNewInput>
    connectOrCreate?: PlanCreateOrConnectWithoutChangeRequestsNewInput
    connect?: PlanWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutChangeRequestsCurrentNestedInput = {
    create?: XOR<PlanCreateWithoutChangeRequestsCurrentInput, PlanUncheckedCreateWithoutChangeRequestsCurrentInput>
    connectOrCreate?: PlanCreateOrConnectWithoutChangeRequestsCurrentInput
    upsert?: PlanUpsertWithoutChangeRequestsCurrentInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutChangeRequestsCurrentInput, PlanUpdateWithoutChangeRequestsCurrentInput>, PlanUncheckedUpdateWithoutChangeRequestsCurrentInput>
  }

  export type PlanUpdateOneRequiredWithoutChangeRequestsNewNestedInput = {
    create?: XOR<PlanCreateWithoutChangeRequestsNewInput, PlanUncheckedCreateWithoutChangeRequestsNewInput>
    connectOrCreate?: PlanCreateOrConnectWithoutChangeRequestsNewInput
    upsert?: PlanUpsertWithoutChangeRequestsNewInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutChangeRequestsNewInput, PlanUpdateWithoutChangeRequestsNewInput>, PlanUncheckedUpdateWithoutChangeRequestsNewInput>
  }

  export type SubscriptionCreateNestedOneWithoutHistoryInput = {
    create?: XOR<SubscriptionCreateWithoutHistoryInput, SubscriptionUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutHistoryInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutHistoryPreviousInput = {
    create?: XOR<PlanCreateWithoutHistoryPreviousInput, PlanUncheckedCreateWithoutHistoryPreviousInput>
    connectOrCreate?: PlanCreateOrConnectWithoutHistoryPreviousInput
    connect?: PlanWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutHistoryNewInput = {
    create?: XOR<PlanCreateWithoutHistoryNewInput, PlanUncheckedCreateWithoutHistoryNewInput>
    connectOrCreate?: PlanCreateOrConnectWithoutHistoryNewInput
    connect?: PlanWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<SubscriptionCreateWithoutHistoryInput, SubscriptionUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutHistoryInput
    upsert?: SubscriptionUpsertWithoutHistoryInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutHistoryInput, SubscriptionUpdateWithoutHistoryInput>, SubscriptionUncheckedUpdateWithoutHistoryInput>
  }

  export type PlanUpdateOneWithoutHistoryPreviousNestedInput = {
    create?: XOR<PlanCreateWithoutHistoryPreviousInput, PlanUncheckedCreateWithoutHistoryPreviousInput>
    connectOrCreate?: PlanCreateOrConnectWithoutHistoryPreviousInput
    upsert?: PlanUpsertWithoutHistoryPreviousInput
    disconnect?: PlanWhereInput | boolean
    delete?: PlanWhereInput | boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutHistoryPreviousInput, PlanUpdateWithoutHistoryPreviousInput>, PlanUncheckedUpdateWithoutHistoryPreviousInput>
  }

  export type PlanUpdateOneWithoutHistoryNewNestedInput = {
    create?: XOR<PlanCreateWithoutHistoryNewInput, PlanUncheckedCreateWithoutHistoryNewInput>
    connectOrCreate?: PlanCreateOrConnectWithoutHistoryNewInput
    upsert?: PlanUpsertWithoutHistoryNewInput
    disconnect?: PlanWhereInput | boolean
    delete?: PlanWhereInput | boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutHistoryNewInput, PlanUpdateWithoutHistoryNewInput>, PlanUncheckedUpdateWithoutHistoryNewInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PlanFeatureCreateWithoutPlanInput = {
    id?: string
    name: string
    description?: string | null
    featureType: string
    value: JsonNullValueInput | InputJsonValue
    isHighlighted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanFeatureUncheckedCreateWithoutPlanInput = {
    id?: string
    name: string
    description?: string | null
    featureType: string
    value: JsonNullValueInput | InputJsonValue
    isHighlighted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanFeatureCreateOrConnectWithoutPlanInput = {
    where: PlanFeatureWhereUniqueInput
    create: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput>
  }

  export type PlanFeatureCreateManyPlanInputEnvelope = {
    data: PlanFeatureCreateManyPlanInput | PlanFeatureCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanLimitCreateWithoutPlanInput = {
    id?: string
    resourceType: string
    maxValue: number
    overagePrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanLimitUncheckedCreateWithoutPlanInput = {
    id?: string
    resourceType: string
    maxValue: number
    overagePrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanLimitCreateOrConnectWithoutPlanInput = {
    where: PlanLimitWhereUniqueInput
    create: XOR<PlanLimitCreateWithoutPlanInput, PlanLimitUncheckedCreateWithoutPlanInput>
  }

  export type PlanLimitCreateManyPlanInputEnvelope = {
    data: PlanLimitCreateManyPlanInput | PlanLimitCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    organizationId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    organizationId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryUncheckedCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanChangeRequestCreateWithoutCurrentPlanInput = {
    id?: string
    organizationId: string
    changeType: string
    requestedBy: string
    reason?: string | null
    status: string
    processedBy?: string | null
    processedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedPlan: PlanCreateNestedOneWithoutChangeRequestsNewInput
  }

  export type PlanChangeRequestUncheckedCreateWithoutCurrentPlanInput = {
    id?: string
    organizationId: string
    requestedPlanId: string
    changeType: string
    requestedBy: string
    reason?: string | null
    status: string
    processedBy?: string | null
    processedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanChangeRequestCreateOrConnectWithoutCurrentPlanInput = {
    where: PlanChangeRequestWhereUniqueInput
    create: XOR<PlanChangeRequestCreateWithoutCurrentPlanInput, PlanChangeRequestUncheckedCreateWithoutCurrentPlanInput>
  }

  export type PlanChangeRequestCreateManyCurrentPlanInputEnvelope = {
    data: PlanChangeRequestCreateManyCurrentPlanInput | PlanChangeRequestCreateManyCurrentPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanChangeRequestCreateWithoutRequestedPlanInput = {
    id?: string
    organizationId: string
    changeType: string
    requestedBy: string
    reason?: string | null
    status: string
    processedBy?: string | null
    processedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentPlan: PlanCreateNestedOneWithoutChangeRequestsCurrentInput
  }

  export type PlanChangeRequestUncheckedCreateWithoutRequestedPlanInput = {
    id?: string
    organizationId: string
    currentPlanId: string
    changeType: string
    requestedBy: string
    reason?: string | null
    status: string
    processedBy?: string | null
    processedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanChangeRequestCreateOrConnectWithoutRequestedPlanInput = {
    where: PlanChangeRequestWhereUniqueInput
    create: XOR<PlanChangeRequestCreateWithoutRequestedPlanInput, PlanChangeRequestUncheckedCreateWithoutRequestedPlanInput>
  }

  export type PlanChangeRequestCreateManyRequestedPlanInputEnvelope = {
    data: PlanChangeRequestCreateManyRequestedPlanInput | PlanChangeRequestCreateManyRequestedPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionHistoryCreateWithoutPreviousPlanInput = {
    id?: string
    organizationId: string
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutHistoryInput
    newPlan?: PlanCreateNestedOneWithoutHistoryNewInput
  }

  export type SubscriptionHistoryUncheckedCreateWithoutPreviousPlanInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    newPlanId?: string | null
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionHistoryCreateOrConnectWithoutPreviousPlanInput = {
    where: SubscriptionHistoryWhereUniqueInput
    create: XOR<SubscriptionHistoryCreateWithoutPreviousPlanInput, SubscriptionHistoryUncheckedCreateWithoutPreviousPlanInput>
  }

  export type SubscriptionHistoryCreateManyPreviousPlanInputEnvelope = {
    data: SubscriptionHistoryCreateManyPreviousPlanInput | SubscriptionHistoryCreateManyPreviousPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionHistoryCreateWithoutNewPlanInput = {
    id?: string
    organizationId: string
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutHistoryInput
    previousPlan?: PlanCreateNestedOneWithoutHistoryPreviousInput
  }

  export type SubscriptionHistoryUncheckedCreateWithoutNewPlanInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    previousPlanId?: string | null
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionHistoryCreateOrConnectWithoutNewPlanInput = {
    where: SubscriptionHistoryWhereUniqueInput
    create: XOR<SubscriptionHistoryCreateWithoutNewPlanInput, SubscriptionHistoryUncheckedCreateWithoutNewPlanInput>
  }

  export type SubscriptionHistoryCreateManyNewPlanInputEnvelope = {
    data: SubscriptionHistoryCreateManyNewPlanInput | SubscriptionHistoryCreateManyNewPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanFeatureUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanFeatureWhereUniqueInput
    update: XOR<PlanFeatureUpdateWithoutPlanInput, PlanFeatureUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanFeatureCreateWithoutPlanInput, PlanFeatureUncheckedCreateWithoutPlanInput>
  }

  export type PlanFeatureUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanFeatureWhereUniqueInput
    data: XOR<PlanFeatureUpdateWithoutPlanInput, PlanFeatureUncheckedUpdateWithoutPlanInput>
  }

  export type PlanFeatureUpdateManyWithWhereWithoutPlanInput = {
    where: PlanFeatureScalarWhereInput
    data: XOR<PlanFeatureUpdateManyMutationInput, PlanFeatureUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanFeatureScalarWhereInput = {
    AND?: PlanFeatureScalarWhereInput | PlanFeatureScalarWhereInput[]
    OR?: PlanFeatureScalarWhereInput[]
    NOT?: PlanFeatureScalarWhereInput | PlanFeatureScalarWhereInput[]
    id?: UuidFilter<"PlanFeature"> | string
    planId?: UuidFilter<"PlanFeature"> | string
    name?: StringFilter<"PlanFeature"> | string
    description?: StringNullableFilter<"PlanFeature"> | string | null
    featureType?: StringFilter<"PlanFeature"> | string
    value?: JsonFilter<"PlanFeature">
    isHighlighted?: BoolFilter<"PlanFeature"> | boolean
    createdAt?: DateTimeFilter<"PlanFeature"> | Date | string
    updatedAt?: DateTimeFilter<"PlanFeature"> | Date | string
  }

  export type PlanLimitUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanLimitWhereUniqueInput
    update: XOR<PlanLimitUpdateWithoutPlanInput, PlanLimitUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanLimitCreateWithoutPlanInput, PlanLimitUncheckedCreateWithoutPlanInput>
  }

  export type PlanLimitUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanLimitWhereUniqueInput
    data: XOR<PlanLimitUpdateWithoutPlanInput, PlanLimitUncheckedUpdateWithoutPlanInput>
  }

  export type PlanLimitUpdateManyWithWhereWithoutPlanInput = {
    where: PlanLimitScalarWhereInput
    data: XOR<PlanLimitUpdateManyMutationInput, PlanLimitUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanLimitScalarWhereInput = {
    AND?: PlanLimitScalarWhereInput | PlanLimitScalarWhereInput[]
    OR?: PlanLimitScalarWhereInput[]
    NOT?: PlanLimitScalarWhereInput | PlanLimitScalarWhereInput[]
    id?: UuidFilter<"PlanLimit"> | string
    planId?: UuidFilter<"PlanLimit"> | string
    resourceType?: StringFilter<"PlanLimit"> | string
    maxValue?: IntFilter<"PlanLimit"> | number
    overagePrice?: DecimalNullableFilter<"PlanLimit"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PlanLimit"> | Date | string
    updatedAt?: DateTimeFilter<"PlanLimit"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: UuidFilter<"Subscription"> | string
    organizationId?: UuidFilter<"Subscription"> | string
    planId?: UuidFilter<"Subscription"> | string
    billingCycle?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelsAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type PlanChangeRequestUpsertWithWhereUniqueWithoutCurrentPlanInput = {
    where: PlanChangeRequestWhereUniqueInput
    update: XOR<PlanChangeRequestUpdateWithoutCurrentPlanInput, PlanChangeRequestUncheckedUpdateWithoutCurrentPlanInput>
    create: XOR<PlanChangeRequestCreateWithoutCurrentPlanInput, PlanChangeRequestUncheckedCreateWithoutCurrentPlanInput>
  }

  export type PlanChangeRequestUpdateWithWhereUniqueWithoutCurrentPlanInput = {
    where: PlanChangeRequestWhereUniqueInput
    data: XOR<PlanChangeRequestUpdateWithoutCurrentPlanInput, PlanChangeRequestUncheckedUpdateWithoutCurrentPlanInput>
  }

  export type PlanChangeRequestUpdateManyWithWhereWithoutCurrentPlanInput = {
    where: PlanChangeRequestScalarWhereInput
    data: XOR<PlanChangeRequestUpdateManyMutationInput, PlanChangeRequestUncheckedUpdateManyWithoutCurrentPlanInput>
  }

  export type PlanChangeRequestScalarWhereInput = {
    AND?: PlanChangeRequestScalarWhereInput | PlanChangeRequestScalarWhereInput[]
    OR?: PlanChangeRequestScalarWhereInput[]
    NOT?: PlanChangeRequestScalarWhereInput | PlanChangeRequestScalarWhereInput[]
    id?: UuidFilter<"PlanChangeRequest"> | string
    organizationId?: UuidFilter<"PlanChangeRequest"> | string
    currentPlanId?: UuidFilter<"PlanChangeRequest"> | string
    requestedPlanId?: UuidFilter<"PlanChangeRequest"> | string
    changeType?: StringFilter<"PlanChangeRequest"> | string
    requestedBy?: UuidFilter<"PlanChangeRequest"> | string
    reason?: StringNullableFilter<"PlanChangeRequest"> | string | null
    status?: StringFilter<"PlanChangeRequest"> | string
    processedBy?: UuidNullableFilter<"PlanChangeRequest"> | string | null
    processedAt?: DateTimeNullableFilter<"PlanChangeRequest"> | Date | string | null
    notes?: StringNullableFilter<"PlanChangeRequest"> | string | null
    createdAt?: DateTimeFilter<"PlanChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PlanChangeRequest"> | Date | string
  }

  export type PlanChangeRequestUpsertWithWhereUniqueWithoutRequestedPlanInput = {
    where: PlanChangeRequestWhereUniqueInput
    update: XOR<PlanChangeRequestUpdateWithoutRequestedPlanInput, PlanChangeRequestUncheckedUpdateWithoutRequestedPlanInput>
    create: XOR<PlanChangeRequestCreateWithoutRequestedPlanInput, PlanChangeRequestUncheckedCreateWithoutRequestedPlanInput>
  }

  export type PlanChangeRequestUpdateWithWhereUniqueWithoutRequestedPlanInput = {
    where: PlanChangeRequestWhereUniqueInput
    data: XOR<PlanChangeRequestUpdateWithoutRequestedPlanInput, PlanChangeRequestUncheckedUpdateWithoutRequestedPlanInput>
  }

  export type PlanChangeRequestUpdateManyWithWhereWithoutRequestedPlanInput = {
    where: PlanChangeRequestScalarWhereInput
    data: XOR<PlanChangeRequestUpdateManyMutationInput, PlanChangeRequestUncheckedUpdateManyWithoutRequestedPlanInput>
  }

  export type SubscriptionHistoryUpsertWithWhereUniqueWithoutPreviousPlanInput = {
    where: SubscriptionHistoryWhereUniqueInput
    update: XOR<SubscriptionHistoryUpdateWithoutPreviousPlanInput, SubscriptionHistoryUncheckedUpdateWithoutPreviousPlanInput>
    create: XOR<SubscriptionHistoryCreateWithoutPreviousPlanInput, SubscriptionHistoryUncheckedCreateWithoutPreviousPlanInput>
  }

  export type SubscriptionHistoryUpdateWithWhereUniqueWithoutPreviousPlanInput = {
    where: SubscriptionHistoryWhereUniqueInput
    data: XOR<SubscriptionHistoryUpdateWithoutPreviousPlanInput, SubscriptionHistoryUncheckedUpdateWithoutPreviousPlanInput>
  }

  export type SubscriptionHistoryUpdateManyWithWhereWithoutPreviousPlanInput = {
    where: SubscriptionHistoryScalarWhereInput
    data: XOR<SubscriptionHistoryUpdateManyMutationInput, SubscriptionHistoryUncheckedUpdateManyWithoutPreviousPlanInput>
  }

  export type SubscriptionHistoryScalarWhereInput = {
    AND?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
    OR?: SubscriptionHistoryScalarWhereInput[]
    NOT?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
    id?: UuidFilter<"SubscriptionHistory"> | string
    organizationId?: UuidFilter<"SubscriptionHistory"> | string
    subscriptionId?: UuidFilter<"SubscriptionHistory"> | string
    previousPlanId?: UuidNullableFilter<"SubscriptionHistory"> | string | null
    newPlanId?: UuidNullableFilter<"SubscriptionHistory"> | string | null
    previousStatus?: StringNullableFilter<"SubscriptionHistory"> | string | null
    newStatus?: StringNullableFilter<"SubscriptionHistory"> | string | null
    changeType?: StringFilter<"SubscriptionHistory"> | string
    changeReason?: StringNullableFilter<"SubscriptionHistory"> | string | null
    changedBy?: UuidNullableFilter<"SubscriptionHistory"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionHistory"> | Date | string
  }

  export type SubscriptionHistoryUpsertWithWhereUniqueWithoutNewPlanInput = {
    where: SubscriptionHistoryWhereUniqueInput
    update: XOR<SubscriptionHistoryUpdateWithoutNewPlanInput, SubscriptionHistoryUncheckedUpdateWithoutNewPlanInput>
    create: XOR<SubscriptionHistoryCreateWithoutNewPlanInput, SubscriptionHistoryUncheckedCreateWithoutNewPlanInput>
  }

  export type SubscriptionHistoryUpdateWithWhereUniqueWithoutNewPlanInput = {
    where: SubscriptionHistoryWhereUniqueInput
    data: XOR<SubscriptionHistoryUpdateWithoutNewPlanInput, SubscriptionHistoryUncheckedUpdateWithoutNewPlanInput>
  }

  export type SubscriptionHistoryUpdateManyWithWhereWithoutNewPlanInput = {
    where: SubscriptionHistoryScalarWhereInput
    data: XOR<SubscriptionHistoryUpdateManyMutationInput, SubscriptionHistoryUncheckedUpdateManyWithoutNewPlanInput>
  }

  export type PlanCreateWithoutFeaturesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    limits?: PlanLimitCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryCreateNestedManyWithoutNewPlanInput
  }

  export type PlanUncheckedCreateWithoutFeaturesInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    limits?: PlanLimitUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestUncheckedCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryUncheckedCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryUncheckedCreateNestedManyWithoutNewPlanInput
  }

  export type PlanCreateOrConnectWithoutFeaturesInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutFeaturesInput, PlanUncheckedCreateWithoutFeaturesInput>
  }

  export type PlanUpsertWithoutFeaturesInput = {
    update: XOR<PlanUpdateWithoutFeaturesInput, PlanUncheckedUpdateWithoutFeaturesInput>
    create: XOR<PlanCreateWithoutFeaturesInput, PlanUncheckedCreateWithoutFeaturesInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutFeaturesInput, PlanUncheckedUpdateWithoutFeaturesInput>
  }

  export type PlanUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    limits?: PlanLimitUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    limits?: PlanLimitUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUncheckedUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUncheckedUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUncheckedUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanCreateWithoutLimitsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryCreateNestedManyWithoutNewPlanInput
  }

  export type PlanUncheckedCreateWithoutLimitsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestUncheckedCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryUncheckedCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryUncheckedCreateNestedManyWithoutNewPlanInput
  }

  export type PlanCreateOrConnectWithoutLimitsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutLimitsInput, PlanUncheckedCreateWithoutLimitsInput>
  }

  export type PlanUpsertWithoutLimitsInput = {
    update: XOR<PlanUpdateWithoutLimitsInput, PlanUncheckedUpdateWithoutLimitsInput>
    create: XOR<PlanCreateWithoutLimitsInput, PlanUncheckedCreateWithoutLimitsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutLimitsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutLimitsInput, PlanUncheckedUpdateWithoutLimitsInput>
  }

  export type PlanUpdateWithoutLimitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutLimitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUncheckedUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUncheckedUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUncheckedUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    limits?: PlanLimitCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryCreateNestedManyWithoutNewPlanInput
  }

  export type PlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    limits?: PlanLimitUncheckedCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestUncheckedCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryUncheckedCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryUncheckedCreateNestedManyWithoutNewPlanInput
  }

  export type PlanCreateOrConnectWithoutSubscriptionsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type InvoiceCreateWithoutSubscriptionInput = {
    id?: string
    organizationId: string
    stripeInvoiceId?: string | null
    number?: string | null
    currency?: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    invoicePdfUrl?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    organizationId: string
    stripeInvoiceId?: string | null
    number?: string | null
    currency?: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    invoicePdfUrl?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceCreateManySubscriptionInputEnvelope = {
    data: InvoiceCreateManySubscriptionInput | InvoiceCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UsageRecordCreateWithoutSubscriptionInput = {
    id?: string
    organizationId: string
    resourceType: string
    quantity: number
    recordedAt?: Date | string
  }

  export type UsageRecordUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    organizationId: string
    resourceType: string
    quantity: number
    recordedAt?: Date | string
  }

  export type UsageRecordCreateOrConnectWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    create: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type UsageRecordCreateManySubscriptionInputEnvelope = {
    data: UsageRecordCreateManySubscriptionInput | UsageRecordCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UsageSummaryCreateWithoutSubscriptionInput = {
    id?: string
    organizationId: string
    resourceType: string
    periodStart: Date | string
    periodEnd: Date | string
    includedQuantity: number
    usedQuantity?: number
    overageQuantity?: number | null
    overageUnitPrice?: Decimal | DecimalJsLike | number | string | null
    overageAmount?: Decimal | DecimalJsLike | number | string
    status: string
    stripeUsageRecordId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageSummaryUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    organizationId: string
    resourceType: string
    periodStart: Date | string
    periodEnd: Date | string
    includedQuantity: number
    usedQuantity?: number
    overageQuantity?: number | null
    overageUnitPrice?: Decimal | DecimalJsLike | number | string | null
    overageAmount?: Decimal | DecimalJsLike | number | string
    status: string
    stripeUsageRecordId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageSummaryCreateOrConnectWithoutSubscriptionInput = {
    where: UsageSummaryWhereUniqueInput
    create: XOR<UsageSummaryCreateWithoutSubscriptionInput, UsageSummaryUncheckedCreateWithoutSubscriptionInput>
  }

  export type UsageSummaryCreateManySubscriptionInputEnvelope = {
    data: UsageSummaryCreateManySubscriptionInput | UsageSummaryCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type PromotionRedemptionCreateWithoutSubscriptionInput = {
    id?: string
    organizationId: string
    appliedAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutRedemptionsInput
  }

  export type PromotionRedemptionUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    promotionId: string
    organizationId: string
    appliedAt?: Date | string
  }

  export type PromotionRedemptionCreateOrConnectWithoutSubscriptionInput = {
    where: PromotionRedemptionWhereUniqueInput
    create: XOR<PromotionRedemptionCreateWithoutSubscriptionInput, PromotionRedemptionUncheckedCreateWithoutSubscriptionInput>
  }

  export type PromotionRedemptionCreateManySubscriptionInputEnvelope = {
    data: PromotionRedemptionCreateManySubscriptionInput | PromotionRedemptionCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionHistoryCreateWithoutSubscriptionInput = {
    id?: string
    organizationId: string
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
    previousPlan?: PlanCreateNestedOneWithoutHistoryPreviousInput
    newPlan?: PlanCreateNestedOneWithoutHistoryNewInput
  }

  export type SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    organizationId: string
    previousPlanId?: string | null
    newPlanId?: string | null
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput = {
    where: SubscriptionHistoryWhereUniqueInput
    create: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionHistoryCreateManySubscriptionInputEnvelope = {
    data: SubscriptionHistoryCreateManySubscriptionInput | SubscriptionHistoryCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type PlanUpsertWithoutSubscriptionsInput = {
    update: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUncheckedUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUncheckedUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUncheckedUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUncheckedUpdateManyWithoutNewPlanNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSubscriptionInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    organizationId?: UuidFilter<"Invoice"> | string
    subscriptionId?: UuidFilter<"Invoice"> | string
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    number?: StringNullableFilter<"Invoice"> | string | null
    currency?: StringFilter<"Invoice"> | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    invoicePdfUrl?: StringNullableFilter<"Invoice"> | string | null
    periodStart?: DateTimeFilter<"Invoice"> | Date | string
    periodEnd?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    update: XOR<UsageRecordUpdateWithoutSubscriptionInput, UsageRecordUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UsageRecordCreateWithoutSubscriptionInput, UsageRecordUncheckedCreateWithoutSubscriptionInput>
  }

  export type UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: UsageRecordWhereUniqueInput
    data: XOR<UsageRecordUpdateWithoutSubscriptionInput, UsageRecordUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UsageRecordUpdateManyWithWhereWithoutSubscriptionInput = {
    where: UsageRecordScalarWhereInput
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UsageRecordScalarWhereInput = {
    AND?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
    OR?: UsageRecordScalarWhereInput[]
    NOT?: UsageRecordScalarWhereInput | UsageRecordScalarWhereInput[]
    id?: UuidFilter<"UsageRecord"> | string
    organizationId?: UuidFilter<"UsageRecord"> | string
    subscriptionId?: UuidFilter<"UsageRecord"> | string
    resourceType?: StringFilter<"UsageRecord"> | string
    quantity?: IntFilter<"UsageRecord"> | number
    recordedAt?: DateTimeFilter<"UsageRecord"> | Date | string
  }

  export type UsageSummaryUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: UsageSummaryWhereUniqueInput
    update: XOR<UsageSummaryUpdateWithoutSubscriptionInput, UsageSummaryUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UsageSummaryCreateWithoutSubscriptionInput, UsageSummaryUncheckedCreateWithoutSubscriptionInput>
  }

  export type UsageSummaryUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: UsageSummaryWhereUniqueInput
    data: XOR<UsageSummaryUpdateWithoutSubscriptionInput, UsageSummaryUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UsageSummaryUpdateManyWithWhereWithoutSubscriptionInput = {
    where: UsageSummaryScalarWhereInput
    data: XOR<UsageSummaryUpdateManyMutationInput, UsageSummaryUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UsageSummaryScalarWhereInput = {
    AND?: UsageSummaryScalarWhereInput | UsageSummaryScalarWhereInput[]
    OR?: UsageSummaryScalarWhereInput[]
    NOT?: UsageSummaryScalarWhereInput | UsageSummaryScalarWhereInput[]
    id?: UuidFilter<"UsageSummary"> | string
    organizationId?: UuidFilter<"UsageSummary"> | string
    subscriptionId?: UuidFilter<"UsageSummary"> | string
    resourceType?: StringFilter<"UsageSummary"> | string
    periodStart?: DateTimeFilter<"UsageSummary"> | Date | string
    periodEnd?: DateTimeFilter<"UsageSummary"> | Date | string
    includedQuantity?: IntFilter<"UsageSummary"> | number
    usedQuantity?: IntFilter<"UsageSummary"> | number
    overageQuantity?: IntNullableFilter<"UsageSummary"> | number | null
    overageUnitPrice?: DecimalNullableFilter<"UsageSummary"> | Decimal | DecimalJsLike | number | string | null
    overageAmount?: DecimalFilter<"UsageSummary"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"UsageSummary"> | string
    stripeUsageRecordId?: StringNullableFilter<"UsageSummary"> | string | null
    createdAt?: DateTimeFilter<"UsageSummary"> | Date | string
    updatedAt?: DateTimeFilter<"UsageSummary"> | Date | string
  }

  export type PromotionRedemptionUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PromotionRedemptionWhereUniqueInput
    update: XOR<PromotionRedemptionUpdateWithoutSubscriptionInput, PromotionRedemptionUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PromotionRedemptionCreateWithoutSubscriptionInput, PromotionRedemptionUncheckedCreateWithoutSubscriptionInput>
  }

  export type PromotionRedemptionUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PromotionRedemptionWhereUniqueInput
    data: XOR<PromotionRedemptionUpdateWithoutSubscriptionInput, PromotionRedemptionUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PromotionRedemptionUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PromotionRedemptionScalarWhereInput
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type PromotionRedemptionScalarWhereInput = {
    AND?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
    OR?: PromotionRedemptionScalarWhereInput[]
    NOT?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
    id?: UuidFilter<"PromotionRedemption"> | string
    promotionId?: UuidFilter<"PromotionRedemption"> | string
    organizationId?: UuidFilter<"PromotionRedemption"> | string
    subscriptionId?: UuidFilter<"PromotionRedemption"> | string
    appliedAt?: DateTimeFilter<"PromotionRedemption"> | Date | string
  }

  export type SubscriptionHistoryUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriptionHistoryWhereUniqueInput
    update: XOR<SubscriptionHistoryUpdateWithoutSubscriptionInput, SubscriptionHistoryUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionHistoryUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriptionHistoryWhereUniqueInput
    data: XOR<SubscriptionHistoryUpdateWithoutSubscriptionInput, SubscriptionHistoryUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionHistoryUpdateManyWithWhereWithoutSubscriptionInput = {
    where: SubscriptionHistoryScalarWhereInput
    data: XOR<SubscriptionHistoryUpdateManyMutationInput, SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type SubscriptionCreateWithoutInvoicesInput = {
    id?: string
    organizationId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutInvoicesInput = {
    id?: string
    organizationId: string
    planId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryUncheckedCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutInvoicesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithoutInvoicesInput = {
    update: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type SubscriptionUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUncheckedUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: UuidFilter<"InvoiceItem"> | string
    invoiceId?: UuidFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"InvoiceItem"> | string
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    organizationId: string
    stripeInvoiceId?: string | null
    number?: string | null
    currency?: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    invoicePdfUrl?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    stripeInvoiceId?: string | null
    number?: string | null
    currency?: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    invoicePdfUrl?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateWithoutUsageRecordsInput = {
    id?: string
    organizationId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUsageRecordsInput = {
    id?: string
    organizationId: string
    planId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryUncheckedCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUsageRecordsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUsageRecordsInput, SubscriptionUncheckedCreateWithoutUsageRecordsInput>
  }

  export type SubscriptionUpsertWithoutUsageRecordsInput = {
    update: XOR<SubscriptionUpdateWithoutUsageRecordsInput, SubscriptionUncheckedUpdateWithoutUsageRecordsInput>
    create: XOR<SubscriptionCreateWithoutUsageRecordsInput, SubscriptionUncheckedCreateWithoutUsageRecordsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUsageRecordsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUsageRecordsInput, SubscriptionUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type SubscriptionUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUncheckedUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateWithoutUsageSummariesInput = {
    id?: string
    organizationId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUsageSummariesInput = {
    id?: string
    organizationId: string
    planId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUsageSummariesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUsageSummariesInput, SubscriptionUncheckedCreateWithoutUsageSummariesInput>
  }

  export type SubscriptionUpsertWithoutUsageSummariesInput = {
    update: XOR<SubscriptionUpdateWithoutUsageSummariesInput, SubscriptionUncheckedUpdateWithoutUsageSummariesInput>
    create: XOR<SubscriptionCreateWithoutUsageSummariesInput, SubscriptionUncheckedCreateWithoutUsageSummariesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUsageSummariesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUsageSummariesInput, SubscriptionUncheckedUpdateWithoutUsageSummariesInput>
  }

  export type SubscriptionUpdateWithoutUsageSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUsageSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type PromotionRedemptionCreateWithoutPromotionInput = {
    id?: string
    organizationId: string
    appliedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutPromotionRedemptionsInput
  }

  export type PromotionRedemptionUncheckedCreateWithoutPromotionInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    appliedAt?: Date | string
  }

  export type PromotionRedemptionCreateOrConnectWithoutPromotionInput = {
    where: PromotionRedemptionWhereUniqueInput
    create: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionRedemptionCreateManyPromotionInputEnvelope = {
    data: PromotionRedemptionCreateManyPromotionInput | PromotionRedemptionCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type PromotionRedemptionUpsertWithWhereUniqueWithoutPromotionInput = {
    where: PromotionRedemptionWhereUniqueInput
    update: XOR<PromotionRedemptionUpdateWithoutPromotionInput, PromotionRedemptionUncheckedUpdateWithoutPromotionInput>
    create: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionRedemptionUpdateWithWhereUniqueWithoutPromotionInput = {
    where: PromotionRedemptionWhereUniqueInput
    data: XOR<PromotionRedemptionUpdateWithoutPromotionInput, PromotionRedemptionUncheckedUpdateWithoutPromotionInput>
  }

  export type PromotionRedemptionUpdateManyWithWhereWithoutPromotionInput = {
    where: PromotionRedemptionScalarWhereInput
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyWithoutPromotionInput>
  }

  export type PromotionCreateWithoutRedemptionsInput = {
    id?: string
    code: string
    description?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    duration: string
    durationMonths?: number | null
    maxRedemptions?: number | null
    redemptionCount?: number
    validFrom?: Date | string
    validUntil?: Date | string | null
    stripePromotionCodeId?: string | null
    stripeCouponId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUncheckedCreateWithoutRedemptionsInput = {
    id?: string
    code: string
    description?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    duration: string
    durationMonths?: number | null
    maxRedemptions?: number | null
    redemptionCount?: number
    validFrom?: Date | string
    validUntil?: Date | string | null
    stripePromotionCodeId?: string | null
    stripeCouponId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCreateOrConnectWithoutRedemptionsInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutRedemptionsInput, PromotionUncheckedCreateWithoutRedemptionsInput>
  }

  export type SubscriptionCreateWithoutPromotionRedemptionsInput = {
    id?: string
    organizationId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPromotionRedemptionsInput = {
    id?: string
    organizationId: string
    planId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryUncheckedCreateNestedManyWithoutSubscriptionInput
    history?: SubscriptionHistoryUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPromotionRedemptionsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPromotionRedemptionsInput, SubscriptionUncheckedCreateWithoutPromotionRedemptionsInput>
  }

  export type PromotionUpsertWithoutRedemptionsInput = {
    update: XOR<PromotionUpdateWithoutRedemptionsInput, PromotionUncheckedUpdateWithoutRedemptionsInput>
    create: XOR<PromotionCreateWithoutRedemptionsInput, PromotionUncheckedCreateWithoutRedemptionsInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutRedemptionsInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutRedemptionsInput, PromotionUncheckedUpdateWithoutRedemptionsInput>
  }

  export type PromotionUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: StringFieldUpdateOperationsInput | string
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptionCount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePromotionCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: StringFieldUpdateOperationsInput | string
    durationMonths?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptionCount?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripePromotionCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCouponId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpsertWithoutPromotionRedemptionsInput = {
    update: XOR<SubscriptionUpdateWithoutPromotionRedemptionsInput, SubscriptionUncheckedUpdateWithoutPromotionRedemptionsInput>
    create: XOR<SubscriptionCreateWithoutPromotionRedemptionsInput, SubscriptionUncheckedCreateWithoutPromotionRedemptionsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutPromotionRedemptionsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutPromotionRedemptionsInput, SubscriptionUncheckedUpdateWithoutPromotionRedemptionsInput>
  }

  export type SubscriptionUpdateWithoutPromotionRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPromotionRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUncheckedUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type PlanCreateWithoutChangeRequestsCurrentInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    limits?: PlanLimitCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    changeRequestsNew?: PlanChangeRequestCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryCreateNestedManyWithoutNewPlanInput
  }

  export type PlanUncheckedCreateWithoutChangeRequestsCurrentInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    limits?: PlanLimitUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
    changeRequestsNew?: PlanChangeRequestUncheckedCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryUncheckedCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryUncheckedCreateNestedManyWithoutNewPlanInput
  }

  export type PlanCreateOrConnectWithoutChangeRequestsCurrentInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutChangeRequestsCurrentInput, PlanUncheckedCreateWithoutChangeRequestsCurrentInput>
  }

  export type PlanCreateWithoutChangeRequestsNewInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    limits?: PlanLimitCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestCreateNestedManyWithoutCurrentPlanInput
    historyPrevious?: SubscriptionHistoryCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryCreateNestedManyWithoutNewPlanInput
  }

  export type PlanUncheckedCreateWithoutChangeRequestsNewInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    limits?: PlanLimitUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedCreateNestedManyWithoutCurrentPlanInput
    historyPrevious?: SubscriptionHistoryUncheckedCreateNestedManyWithoutPreviousPlanInput
    historyNew?: SubscriptionHistoryUncheckedCreateNestedManyWithoutNewPlanInput
  }

  export type PlanCreateOrConnectWithoutChangeRequestsNewInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutChangeRequestsNewInput, PlanUncheckedCreateWithoutChangeRequestsNewInput>
  }

  export type PlanUpsertWithoutChangeRequestsCurrentInput = {
    update: XOR<PlanUpdateWithoutChangeRequestsCurrentInput, PlanUncheckedUpdateWithoutChangeRequestsCurrentInput>
    create: XOR<PlanCreateWithoutChangeRequestsCurrentInput, PlanUncheckedCreateWithoutChangeRequestsCurrentInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutChangeRequestsCurrentInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutChangeRequestsCurrentInput, PlanUncheckedUpdateWithoutChangeRequestsCurrentInput>
  }

  export type PlanUpdateWithoutChangeRequestsCurrentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutChangeRequestsCurrentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUncheckedUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUncheckedUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUncheckedUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanUpsertWithoutChangeRequestsNewInput = {
    update: XOR<PlanUpdateWithoutChangeRequestsNewInput, PlanUncheckedUpdateWithoutChangeRequestsNewInput>
    create: XOR<PlanCreateWithoutChangeRequestsNewInput, PlanUncheckedCreateWithoutChangeRequestsNewInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutChangeRequestsNewInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutChangeRequestsNewInput, PlanUncheckedUpdateWithoutChangeRequestsNewInput>
  }

  export type PlanUpdateWithoutChangeRequestsNewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUpdateManyWithoutCurrentPlanNestedInput
    historyPrevious?: SubscriptionHistoryUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutChangeRequestsNewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedUpdateManyWithoutCurrentPlanNestedInput
    historyPrevious?: SubscriptionHistoryUncheckedUpdateManyWithoutPreviousPlanNestedInput
    historyNew?: SubscriptionHistoryUncheckedUpdateManyWithoutNewPlanNestedInput
  }

  export type SubscriptionCreateWithoutHistoryInput = {
    id?: string
    organizationId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutHistoryInput = {
    id?: string
    organizationId: string
    planId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput
    usageSummaries?: UsageSummaryUncheckedCreateNestedManyWithoutSubscriptionInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutHistoryInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutHistoryInput, SubscriptionUncheckedCreateWithoutHistoryInput>
  }

  export type PlanCreateWithoutHistoryPreviousInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    limits?: PlanLimitCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestCreateNestedManyWithoutRequestedPlanInput
    historyNew?: SubscriptionHistoryCreateNestedManyWithoutNewPlanInput
  }

  export type PlanUncheckedCreateWithoutHistoryPreviousInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    limits?: PlanLimitUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestUncheckedCreateNestedManyWithoutRequestedPlanInput
    historyNew?: SubscriptionHistoryUncheckedCreateNestedManyWithoutNewPlanInput
  }

  export type PlanCreateOrConnectWithoutHistoryPreviousInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutHistoryPreviousInput, PlanUncheckedCreateWithoutHistoryPreviousInput>
  }

  export type PlanCreateWithoutHistoryNewInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureCreateNestedManyWithoutPlanInput
    limits?: PlanLimitCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryCreateNestedManyWithoutPreviousPlanInput
  }

  export type PlanUncheckedCreateWithoutHistoryNewInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly: Decimal | DecimalJsLike | number | string
    currency?: string
    isPublic?: boolean
    sortOrder?: number
    stripeProductId?: string | null
    stripeMonthlyPriceId?: string | null
    stripeYearlyPriceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PlanFeatureUncheckedCreateNestedManyWithoutPlanInput
    limits?: PlanLimitUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedCreateNestedManyWithoutCurrentPlanInput
    changeRequestsNew?: PlanChangeRequestUncheckedCreateNestedManyWithoutRequestedPlanInput
    historyPrevious?: SubscriptionHistoryUncheckedCreateNestedManyWithoutPreviousPlanInput
  }

  export type PlanCreateOrConnectWithoutHistoryNewInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutHistoryNewInput, PlanUncheckedCreateWithoutHistoryNewInput>
  }

  export type SubscriptionUpsertWithoutHistoryInput = {
    update: XOR<SubscriptionUpdateWithoutHistoryInput, SubscriptionUncheckedUpdateWithoutHistoryInput>
    create: XOR<SubscriptionCreateWithoutHistoryInput, SubscriptionUncheckedCreateWithoutHistoryInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutHistoryInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutHistoryInput, SubscriptionUncheckedUpdateWithoutHistoryInput>
  }

  export type SubscriptionUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUncheckedUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type PlanUpsertWithoutHistoryPreviousInput = {
    update: XOR<PlanUpdateWithoutHistoryPreviousInput, PlanUncheckedUpdateWithoutHistoryPreviousInput>
    create: XOR<PlanCreateWithoutHistoryPreviousInput, PlanUncheckedCreateWithoutHistoryPreviousInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutHistoryPreviousInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutHistoryPreviousInput, PlanUncheckedUpdateWithoutHistoryPreviousInput>
  }

  export type PlanUpdateWithoutHistoryPreviousInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUpdateManyWithoutRequestedPlanNestedInput
    historyNew?: SubscriptionHistoryUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutHistoryPreviousInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUncheckedUpdateManyWithoutRequestedPlanNestedInput
    historyNew?: SubscriptionHistoryUncheckedUpdateManyWithoutNewPlanNestedInput
  }

  export type PlanUpsertWithoutHistoryNewInput = {
    update: XOR<PlanUpdateWithoutHistoryNewInput, PlanUncheckedUpdateWithoutHistoryNewInput>
    create: XOR<PlanCreateWithoutHistoryNewInput, PlanUncheckedCreateWithoutHistoryNewInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutHistoryNewInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutHistoryNewInput, PlanUncheckedUpdateWithoutHistoryNewInput>
  }

  export type PlanUpdateWithoutHistoryNewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUpdateManyWithoutPreviousPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutHistoryNewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeMonthlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeYearlyPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PlanFeatureUncheckedUpdateManyWithoutPlanNestedInput
    limits?: PlanLimitUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
    changeRequestsCurrent?: PlanChangeRequestUncheckedUpdateManyWithoutCurrentPlanNestedInput
    changeRequestsNew?: PlanChangeRequestUncheckedUpdateManyWithoutRequestedPlanNestedInput
    historyPrevious?: SubscriptionHistoryUncheckedUpdateManyWithoutPreviousPlanNestedInput
  }

  export type PlanFeatureCreateManyPlanInput = {
    id?: string
    name: string
    description?: string | null
    featureType: string
    value: JsonNullValueInput | InputJsonValue
    isHighlighted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanLimitCreateManyPlanInput = {
    id?: string
    resourceType: string
    maxValue: number
    overagePrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    organizationId: string
    billingCycle: string
    status: string
    trialEndsAt?: Date | string | null
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelsAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanChangeRequestCreateManyCurrentPlanInput = {
    id?: string
    organizationId: string
    requestedPlanId: string
    changeType: string
    requestedBy: string
    reason?: string | null
    status: string
    processedBy?: string | null
    processedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanChangeRequestCreateManyRequestedPlanInput = {
    id?: string
    organizationId: string
    currentPlanId: string
    changeType: string
    requestedBy: string
    reason?: string | null
    status: string
    processedBy?: string | null
    processedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionHistoryCreateManyPreviousPlanInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    newPlanId?: string | null
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionHistoryCreateManyNewPlanInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    previousPlanId?: string | null
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type PlanFeatureUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanFeatureUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featureType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanLimitUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    maxValue?: IntFieldUpdateOperationsInput | number
    overagePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanLimitUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    maxValue?: IntFieldUpdateOperationsInput | number
    overagePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanLimitUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    maxValue?: IntFieldUpdateOperationsInput | number
    overagePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput
    usageSummaries?: UsageSummaryUncheckedUpdateManyWithoutSubscriptionNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
    history?: SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelsAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanChangeRequestUpdateWithoutCurrentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedPlan?: PlanUpdateOneRequiredWithoutChangeRequestsNewNestedInput
  }

  export type PlanChangeRequestUncheckedUpdateWithoutCurrentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    requestedPlanId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanChangeRequestUncheckedUpdateManyWithoutCurrentPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    requestedPlanId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanChangeRequestUpdateWithoutRequestedPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPlan?: PlanUpdateOneRequiredWithoutChangeRequestsCurrentNestedInput
  }

  export type PlanChangeRequestUncheckedUpdateWithoutRequestedPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    currentPlanId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanChangeRequestUncheckedUpdateManyWithoutRequestedPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    currentPlanId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryUpdateWithoutPreviousPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutHistoryNestedInput
    newPlan?: PlanUpdateOneWithoutHistoryNewNestedInput
  }

  export type SubscriptionHistoryUncheckedUpdateWithoutPreviousPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    newPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryUncheckedUpdateManyWithoutPreviousPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    newPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryUpdateWithoutNewPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutHistoryNestedInput
    previousPlan?: PlanUpdateOneWithoutHistoryPreviousNestedInput
  }

  export type SubscriptionHistoryUncheckedUpdateWithoutNewPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    previousPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryUncheckedUpdateManyWithoutNewPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    previousPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManySubscriptionInput = {
    id?: string
    organizationId: string
    stripeInvoiceId?: string | null
    number?: string | null
    currency?: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status: string
    invoicePdfUrl?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordCreateManySubscriptionInput = {
    id?: string
    organizationId: string
    resourceType: string
    quantity: number
    recordedAt?: Date | string
  }

  export type UsageSummaryCreateManySubscriptionInput = {
    id?: string
    organizationId: string
    resourceType: string
    periodStart: Date | string
    periodEnd: Date | string
    includedQuantity: number
    usedQuantity?: number
    overageQuantity?: number | null
    overageUnitPrice?: Decimal | DecimalJsLike | number | string | null
    overageAmount?: Decimal | DecimalJsLike | number | string
    status: string
    stripeUsageRecordId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionRedemptionCreateManySubscriptionInput = {
    id?: string
    promotionId: string
    organizationId: string
    appliedAt?: Date | string
  }

  export type SubscriptionHistoryCreateManySubscriptionInput = {
    id?: string
    organizationId: string
    previousPlanId?: string | null
    newPlanId?: string | null
    previousStatus?: string | null
    newStatus?: string | null
    changeType: string
    changeReason?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type InvoiceUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    invoicePdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageSummaryUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    includedQuantity?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    overageQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    overageUnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    stripeUsageRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageSummaryUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    includedQuantity?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    overageQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    overageUnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    stripeUsageRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageSummaryUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    includedQuantity?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    overageQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    overageUnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overageAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    stripeUsageRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutRedemptionsNestedInput
  }

  export type PromotionRedemptionUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    previousPlan?: PlanUpdateOneWithoutHistoryPreviousNestedInput
    newPlan?: PlanUpdateOneWithoutHistoryNewNestedInput
  }

  export type SubscriptionHistoryUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    previousPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    newPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    previousPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    newPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: NullableStringFieldUpdateOperationsInput | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionCreateManyPromotionInput = {
    id?: string
    organizationId: string
    subscriptionId: string
    appliedAt?: Date | string
  }

  export type PromotionRedemptionUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutPromotionRedemptionsNestedInput
  }

  export type PromotionRedemptionUncheckedUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}